<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Keil系列教程]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【Keil系列教程】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看。 二、教程列表Keil系列教程01_Keil介绍、下载、安装与注册Keil系列教程02_新建基础软件工程Keil系列教程03_主窗口和工具栏详细说明Keil系列教程04_菜单概述Keil系列教程05_工程目标选项配置（一）Keil系列教程06_工程目标选项配置（二）Keil系列教程07_Configuration（一）Keil系列教程08_Configuration（二）Keil系列教程09_调试仿真Keil系列教程10_文件类型及相关描述 正在努力更新中，可关注我微信公众号查看最新消息…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程10_文件类型及相关描述]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%8F%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面1.你在提交项目、打包保存项目时，你会删掉不必要的文件吗？2.你知道这些uvoptx、uvprojx、map、dep……是什么文件吗？ 12345现象or疑问：1.购买一块开发板，厂家提供的源代码例程没有几个，但文件却有几百兆。2.百度网盘下载一个别人提供的代码压缩包，几十兆。3.打开别人下载的源代码工程，各种类型文件混杂在一起。4.有些人提供的源代码没有dep文件，这个文件可以删除吗？ 删除了会有什么影响？ 其实有许多文件都是编译产生的中间文件，我习惯放一个双击删除“编译产生文件”.bat”来管理工程。即每次需要保存，或提交工程，会双击该文件，删除不需要的中间文件。 当你看完本文，理解这些文件类型的含义，你就不会有上面这些烦恼了。（本文内容可参考Keil帮助文档“File Types”文件类型章节） 二、Keil文件类型概述Keil中用到的文件类型很多，大概有五、六十种。下面会重点讲述常用的文件类型，一些不重要的，或者不常见的只简单概述。 Keil文件可以分为7类：1、Project Files工程类型文件；2、Source Files源代码类型文件；3、Listing Files链接类型文件；4、Object and HEX Files目标和Hex类型文件；5、Build Files编译类型文件；6、Debugger Files调试类型文件；7、Other Files其他类型文件； 三、Project Files工程类型文件工程类型文件是比较重要的，特别是工作空间、 工程文件、工程选项配置这三种文件不能删除。项目界面布局文件可以删除。 3.1 工作空间文件（这类文件不能删除）*.uvmpw：µVision Project file for Multiple Projects多工程文件，也就是我们说的工作空间文件。 3.2 工程文件（这类文件不能删除）*.uvprojx：µVision5工程文件 *.uvproj：µVision4工程文件 *.uv2：µVision3工程文件 3.3 工程选项配置文件（这类文件不能删除）*.uvoptx：µVision5工程选项配置文件 *.uvopt：µVision4工程选项配置文件 3.4 项目界面布局文件（这类文件可以删除）*.uvguix[.user-name]：µVision5项目界面布局文件。删除之后，重新打开工程，界面布局会恢复到默认布局。如Demo.uvguix.Administrator。 *.uvguix[.user-name]：µVision4项目界面布局文件。 四、Source Files源代码类型文件这一类文件相信大家都熟悉，简述一下。 *.c：C源文件 *.h：C头文件 *.cpp：C++源文件 *.s：汇编源文件 *.a51：汇编源文件 *.a66：汇编源文件 *.inc：汇编头文件 *.src：C编译器生成的其他源文件 五、Listing Files链接类型文件这一类文件属于中间文件，一般在编译过程中产生。可以在工程目标选项中配置对应的链接文件。Project -&gt; Options for Target -&gt; Listing，如下图： *.map：存储镜像文件这个文件比较重要，我会在后面专门讲述一篇map相关文章。 *.i：C预处理器输出文件 *.scr：链接器分散加载器文件 *.lst：C编译器或汇编器生成的文件 *.m51：同样也是map文件 *.m66：同样也是map文件 *.htm：链接器的列表文件 六、Object and HEX Files目标和Hex类型文件这一类文件同样属于中间文件，一般在编译过程中产生。但这类文件比较重要，调试信息、预览信息、可执行文件等都在这里面。 Project -&gt; Options for Target -&gt; Output，如图： *.hex：可执行文件 *.axf：包含调试信息的程序文件有时候我们调试出错，可能是axf没有文件。 *.d：编译生成的依赖文件一般一个.c文件对应一个.d文件。 *.o：也是目标的依赖文件重定位定址的依赖文件。 *.lib：库文件生成的库就在这里。 *.elf：ELF/DWARF链接的文件 *.crf：浏览信息文件使用Go to Definition Of 功能，就需要有这类文件。 七、Build Debugger编译调试文件编译和调试，其实是两类不同文件，由于比较少，综合在一起写。 *.bat：批处理文件 ._IA, .__I, ._II, .SCR：工具调用文件 *.ini：于初始化源码文件 八、Other Files其他类型文件这类文件比较多，但使用较少，简单列几个吧。 *.pack：软件（支持）包文件 *.sct：链接控制文件 *.lnp：连接器传递命令文件 *.dep：目标编译依赖文件 *.cdb：µVision设备数据库文件 九、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 十、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程09_调试仿真]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_%E8%B0%83%E8%AF%95%E4%BB%BF%E7%9C%9F.html</url>
    <content type="text"><![CDATA[一、写在前面调试对于程序员来说是一个比较重要的环节，因此就很有必要掌握Keil的这些调试功能。 点击Debug调试按钮，进入调试状态，就会出现如下图Debug Toolbar调试工具栏。 我们调试需要用到的按钮包含上图框出来的这些按钮，但常用的按钮就是调试工具栏前八个：复位、全速运行、停止运行、单步运行、逐步运行、跳出运行、运行到光标行、跳转到暂停行。 二、相关描述这些工具栏按钮的主要含义可以参看《Keil系列教程03_主窗口和工具栏详细说明》。 调试工具栏按钮位于菜单Debug中，同时调试视图窗口位于菜单View。可以参看文章《Keil系列教程04_菜单概述》。 同样，这些调试工具栏按钮可通过快捷键实现，有些默认没有快捷键，可以通过Configuration添加快捷键。请参看文章《Keil系列教程08_Configuration（二）》Shortcut Keys 快捷键章节内容。 下面带领大家掌握那八个调试按钮、四个断点按钮，以及部分调试视图窗口的内容。 三、八个调试按钮保证代码编译无误，点击“启动/停止调试”按钮（如下图），或快捷键Ctrl + F5，进入调试模式。此时就会出现如文中开头的调试工具栏。 3.1 Reset复位 Reset复位，让程序复位到起点，恢复到初始状态。 3.2 Run全速运行 Run全速运行（F5），让程序处于运行状态。此按钮在程序停止运行时有效。 3.3 Stop停止运行 Stop停止运行，让正在运行的程序停止下来。此按钮在程序运行时有效。 3.4 Step单步运行 Step单步运行（F11），每点一次按钮，程序运行一步（单步），遇到函数会跳进函数执行（箭头进入括号）。此按钮在程序停止运行时有效。 3.5 Step Over逐步运行 Step Over逐步运行（F10），每点一次按钮，程序运行一行（单行），遇到函数跳过函数执行（箭头跳过括号）。此按钮在程序停止运行时有效。 3.6 Step Out跳出运行 Step Out跳出运行（Ctrl + F11），每点一次按钮，程序跳出当前函数执行（箭头跳出括号），直到跳出最外面的函数（main函数）。此按钮在程序停止运行时有效。 3.7 Run to Cursor Line运行到光标行 Run to Cursor Line运行到光标行（Ctrl + F10），将光标放在某一行，点击该按钮，程序全速运行，直到运行到光标的位置停止下来。（前提是程序能运行到光标所在行）。 3.8 Show Next Statement跳转到暂停行 Show Next Statement跳转到暂停行，点击该按钮，跳转到程序暂停（停止）所在行。主要用我们打开多个文件，不知道程序暂停在哪里。此按钮在程序停止运行时有效。 四、四个断电按钮 调试时，这四个按钮也常用，从左到右依次是：插入/移除断点、 使能/失能断点、 失能所有断点、 取消所有断点。 4.1 插入/移除断点Insert/Remove Breakpoint插入/移除断点（F9），点击一下按钮，在光标所在行插入一个断点，再点击一次，则移除断点。 该按钮操作等于用鼠标在代码所在行前面点击一次，注意只有在灰色所在行才有效（也就是程序能执行的地方），如下图： 4.2 使能/失能断点Enable/Disable Breakpoint使能/失能断点（Ctrl + F9），在有断点基础上，点击一下按钮，失能该断点，再点击一次，则使能该断点。 失能断点就是保留该断点，但该断点无效（程序执行到该处不停止）。 4.3 失能所有断点Disable All Breakpoints失能所有断点，保留所有断点，但都无效（和上面一个道理），但这里不能再次使能所有断点。 4.4 取消所有断点Kill All Breakpoints取消所有断点（Ctrl + Shift + F9），和上面失能不一样，这里是不保留断点，即取消工程所有断点，也叫杀掉所有断点。 五、调试视图窗口调试视图窗口只有进入调试模式时才会出现，其窗口名称详情可参看文章《Keil系列教程04_菜单概述》中View菜单章节。 这里讲述几个在调试时常用的视图窗口。 5.1 Watch窗口Watch查看变量的窗口，有Watch1和Watch2两个窗口，都一样，方便用户多个窗口同时查看。 查看这些调试视图窗口可以通过菜单，或点击工具栏按钮打开。 选中变量 -&gt; 右键 -&gt; Add ‘xxx’ to -&gt;Watch1，此时自动会弹出Watch1窗口： 5.2 System Viewer窗口System Viewer系统（外围IO、USART、TIM等）窗口，可以理解查看外设寄存器的窗口，如下图，查看USART寄存器值的窗口。 这些调试视图窗口只针对于调试时，方便大家查看一些调试信息，掌握这些内容会提高你的调试效率，以及更精确定位Bug。 六、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程08_Configuration（二）]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_Configuration%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面本文接着上一篇文章《Keil系列教程07_Configuration（一）》讲述的工程目标选项的后三项配置：Shortcut Keys快捷键、Text Completion代码完形、Other其他。 这后面三部分内容在该系列教程其它也会牵涉，也是一些常用、重要的配置选项，下面讲述过程中会介绍相关内容。 二、Shortcut Keys快捷键Configuration中Shortcut Keys主要作用：查看、添加、修改、删除快捷键。而这些快捷键主要就是针对各项菜单的内容（命令）。 在默认情况下，不是所有菜单都有快捷键，可以自行添加、修改，或删除。左边列表中的Command（菜单命令）属于系统，用户不能增加、删除和修改。 2.1 创建快捷键快捷键可以增加（创建）、删除（移除）和修改。我们这里简单举例说明一下创建快捷键。 比如：增加（创建）File Colse 关闭文件快捷键为Ctrl+W。点击“Create Shortcut” -&gt; 键盘按住“Ctrl + W” -&gt; 点击“OK”。 增加（创建）快捷键动画效果： 2.2 常用快捷键Keil默认的所有快捷键在列表中都能查找到，这里为了方便大家，也让大家回顾一下，列出常用的快捷键。 在该系列教程前面文章就讲述了快捷键的相关内容，请参看：《Keil系列教程03_主窗口和工具栏详细说明》《Keil系列教程04_菜单概述》 按照菜单列表顺序：1.File类Ctrl + N ：新建文件Ctrl + O ：打开文件Ctrl + S ：保存文件 2.Edit类Ctrl + Z ：撤销编辑Ctrl + Y ：恢复编辑Ctrl + X ：剪切Ctrl + C ：复制Ctrl + V ：粘贴Ctrl + - ：跳转到上一步Ctrl + Shift + - ：跳转到下一步Ctrl + F2 ：添加书签F2 ：跳转到下一个书签Shift + F2 ：跳转到上一个书签Ctrl + Shift + F2 ：清空所有书签Ctrl + F ：查找Ctrl + H ：替换 3.Project类Alt + F7 ：工程目标F7 ：编译目标Ctrl + F7 ：编译文件 4.Flash类F8 ：下载程序 5.Debug类Ctrl + F5 ：启动/停止调试F5 ：运行F11 ：Setp运行F10 ：Setp Over运行Ctrl + F11 ：Setp Out运行Ctrl + F10 ：运行到光标处Ctrl + B : 查看所有断点F9 ：插入/移除断点Ctrl + F9 : 使能/失能单个断点Ctrl + Shift + F9 ：取消所有断点 只是简单列了一些常用快捷键，列表中默认没有的快捷键可以自己添加。 三、Text Completion代码完形这个选项相关的功能比较实用，能帮助你在编程时快速完成编辑。直白的意思就是能提高编程的效率。 3.1 Show Code Completion List：自动完成代码编辑Struct / Class Members编辑时显示结构体/类成员变量列表，直接点击列表中的成员就可以完形代码。 Function Parameters就是显示参数和参数类型 Symbols after [x] Characters自动匹配x字符，在输入时达到x个字符会匹配输入的字符串。 3.2 Dynamic Syntax Checking：语法动态错误检测你编辑代码时会动态（实时）检测你代码是否正确。比如：错误会有红色标识提示。 3.3 Text Templates：代码模板代码模板很好理解，相当于你写了一个模板，以后直接使用就是了。 代码完形、模板动画效果： 四、Other其他这个选项不常用，可以了解一下。 1.UVSOCK (TCP/IP) Settings启动或关闭UV socket端口，这个选项可以说基本很少人使用。 2.Startup (Require Restart)启动启动软件（重新打开）时对应的操作。 Show splash screen：显示启动画面。如下图： Open most recent project：启动软件后打开最近的工程项目。 3.Debug调试调试时，如果都选上，则运行停止后不打开匹配的源文件。 4.Parallel Build Configuration并行编译配置在编译多个工程时，这个选项就会起到作用。 Disable Parallel Build：禁止并行编译Number of parallel jobs：并行编译数量 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程07_Configuration（一）]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_Configuration%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面本文带来的内容为“Configuration”，即配置。而这里的“配置”和前面“工程目标选项配置”是完全不同的两种配置。 工程目标选项配置是针对工程目标，保存在工程文件（.uvprojx和.uvoptx）。这里的Configuration是针对IDE，保存在安装目录下。 我们常见的字体大小、颜色、关键字、快捷键等这些都是在“Configuration”中进行设置。本文讲述Configuration中的前面3项：Editor编辑、 Colors &amp; Fonts字体和颜色、 User KeyWords用户关键字。 二、打开“Configuration”方法1.点击“Configuration”快捷按钮 2.快捷键Keil打开Configuration，默认是没有设置快捷键。不过可以进入Configuration，对其打开方式设置快捷键。比如Alt + C（在下一篇文章会讲述设置快捷键）。 3.从菜单中打开， Edit -&gt; Configuration，如下图： 三、Editor编辑如下图，我将Edit分为五部分来讲述：General Editor Settings、 Function Display、 Look &amp; Feel、 File &amp; Project Handing、 C/C++ &amp; ASM &amp; Other File。 3.1 General Editor SettingsGeneral Editor Settings：通用编辑设置。这个选项里面内容比较实用，可以参看下面动画效果。 1.Encoding：编码方式选择Keil提供十几种编码方式供大家选择，默认：Encode in ANSI. 2.Auto Indent：自动缩进也就是换行时自动缩进（对齐）功能，提供3个选项。None：不对对齐，光标每次换行在第一列。Smart：灵活对齐（常用）。包含大括号自动对齐。Block：光标对齐于前一行。 3.Virtual Spaces：虚拟空间光标在上下移动时不管有没有“空间”都对齐。也就是说光标可以在任何位置。 4.View White Space：显示空白（空格）勾选会将“空格”和“Tab”显示出来。 5.View End of Line：显示结束行勾选会在每行最后显示换行符。 Encoding、Auto Indent动画效果： Virtual Spaces、View White Space、View End of Line动画效果： 3.2 Function DisplayFunction Display：函数显示，就是在Function Display窗口的一些显示方式。 这一区域是三个参数组合配置，可以实现多种显示效果。 1.Display Modules：显示模块【显示方式】简单的说模块显示就是显示C源文件名，将函数名折叠在文件里面。勾选：以模块（分组/文件夹）方式显示。不选：以函数名方式显示。 2.Scan function names in project files：浏览工程项目中所有函数【显示内容】就是显示工程中所有函数。 3.Scan function names in current editor files：浏览当前编辑（已打开）文件的函数【显示内容】比如：我打开了main.c和bsp.c两个文件来编辑，那么就显示这两个文件的内容（函数）。 Function Display动画效果： 3.3 Look &amp; FeelLook &amp; Feel：看&amp;感觉（视觉），请看下面描述就能直观的理解这一区域意思。 1.Show Message Dialog during Find：在查找时显示消息对话框就是在查找结束，或未查找到相关内时容弹出的提示框。 比如：我在main.c文件中查找main1（文件中实际是没有main1），勾选上就会弹出消息对话框（如下图），不勾选就不会弹出高亮对话框。 2.Highlight Current Line：高亮当前行勾选上，光标放在那一行，这一行就高亮的意思。如下图： 3.Highlight matching and mismatched braces：高亮显示匹配和不匹配括号将光标放在括号处，会高亮括号，如下图： 4.Print with syntax coloring：打印语法颜色打印颜色对应为编辑器中的颜色。 5.Colored Editor Tabs：颜色编辑器选项卡启用或禁用文件名称标签的颜色，如下图，勾选就显示颜色： 6.Right Margin：右边距编辑分隔符标记的位置号。位置号的默认值是80,范围[1-999]。None：无标记；Vertical Line：垂直线标记；Colored Background：背景颜色标记。 3.4 File and Project HandlingFile and Project Handling：文件和工程操作，针对的是文件和工程。 1.Create Backup files：创建备份文件(* . bak)在保存文件时，在文件的目录中创建备份文件，扩展名为.bak。这个选项只影响源文件，对项目文件没有影响。 2.Automatic reload of externally modified files：自动加载修改过的文件比如：Keil软件打开了main.c文件，再使用其它编辑器打开该main,c修改其中内容并保存，这时Keil软件自动加载修改过的main.c文件。 不勾选，则不会自动加载，就会有如下重新加载提示： 3.Save Project before entering Debug：进入调试之前保存工程项目 4.Save Files before entering Debug：进入调试之前保存所有文件 5.Auto save modified File every [x] Minutes：每x分钟自动保存文件 3.5 C/C++ &amp; ASM &amp; Other File这里三组配置类似，只讲述一组，比较简单。 1.Use syntax coloring：使用语法颜色不使用语法就等于txt文本那种纯黑色。见下图不使用和使用区别： 2.Insert spaces for tabs：符插入空格这个符号需要配合上面3.1General Editor Settings的View White Space显示出来才能看到效果。 3.Tab Size：Tab符大小一个Tab符占几个空格。 4.Show Line Numbers：显示行数 5.Use monospaced Font：使用等宽字体 6.Open with Outlining：打开伦廓 四、Colors &amp; Fonts颜色和字体这个选项就是修改字体和颜色。 Window窗口：列出所有可配置窗口名称或窗口类型。这个列表是预定义的,用户不能修改。我们常见修改的地方就是“C/C++ Edit files”。 Element元素：一个窗口的列表元素。这个列表是预定义的,用户不能修改。 Font字体：包含Font字体、Size大小和Style风格三项。 Colors颜色：包含Foreground 前景色、Background 背景色。 很多人不喜欢白色背景，比较刺眼。可惜Keil不支持修改主题，就只能在这里修改背景色来调节。 修改这里字体和颜色，其实就是修改了Keil_v5\UV4目录下的global.prop文件。 如下图所示，就是通过修改字体颜色和背景色来达到“黑色”主题。我将下图“黑色”主题提供给大家，只需替换你Keil_v5\UV4目录下global.prop即可。 链接：https://pan.baidu.com/s/16AqpplKTNNsqbi5CTrHmCg密码：fxc7 五、User Keywords用户关键字这个选项比较简单，就是用户自定义关键字。 Text File Types：文本文件类型。User Keywords：用户关键字。 举例：在C/C++文件里定义关键字“uint8_t”，在编辑C/C++文件时“uint8_t”就会以关键字颜色显示。 请参看我公众号分享过的一篇文章《Keil自定义关键字、快捷键》。 六、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程06_工程目标选项配置（二）]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E7%9B%AE%E6%A0%87%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面本文接着上一篇文章《Keil系列教程05_工程目标选项配置（一）》讲述的工程目标选项的后五项配置：C/C++编译、 Asm汇编、 Linker链接、 Debug调试、 Utilities公共。 二、C/C++编译 这里“C/C++选项”和“Asm选项”类似，主要是与编译相关的一些配置。 第1处：预处理（Preprocessor Symbols）这里主要就是预定义功能，相当于在程序中的#define xxxx。我上面预定义STM32F10X_HD，在stm32f10x.h文件中就不用定义了。 第2处：语言/代码生成（Language / Code Generation）Language/code Generation语言/代码生成。可以理解成编译、链接到最后生成代码。这部分功能对于代码优化比较重要，初学者可以不用过多理解，对代码大小、运行速度等性能要求较高的人就需要深入理解。 Execute only Code：只生成执行代码【设置编译器命令行：–execute_only】只生成执行代码防止编译器生成任何数据访问代码部分。 Optimize：优化选择项，有Level0 - Level3四个选项【设置编译器命令行：-Onum】初学者、在线调试建议使用Level0，也就是不优化，这样执行的效果才和代码一样。如果配置成Level3，在线调试可能有些地方优化而不能打断点。 Optimize for Time：优化时间，即优化代码中费时的地方【设置编译器命令行：-Otime】比如有些算法，本身代码量就比较大，运行需要很长时间（假如需要2秒），这个时候勾选上该功能，会发现运行时间有比较明显的减少（或许不到1秒时间）。 Split Load and Store Multiple：加载和存储多个分裂【设置编译器命令行：–split_ldm】非对齐数据采用多次访问方式。当 LMD/STM 指令有 4 个以上产生时，列分裂LMD 和 STM 指令，以减不中断延迟。 One ELF Section per Function：优化每一个函数 ELF 段【设置编译器命令行：–split_sections】每个函数都会产生一个 ELF 段，勾选上，允许优化每一个 ELF 段。这个选项可以减少潜在的共享地址、数据和函数之间的字符串。 直白的意思：可以减少代码量ROM的大小（内存RAM不会减小）。 举一个例子，勾选之前和勾选之后，编译后存储大小对比：勾选之前：Program Size: Code=2540 RO-data=336 RW-data=40 ZI-data=1024 勾选之后：Program Size: Code=908 RO-data=320 RW-data=40 ZI-data=1024 Strict ANSI C：标准（严格）的ANSC【设置编译器命令行：–strict】也就是说：编译时严格按照标准的ANSI C进行检查。 Enum Container always int：枚举总是int型【设置编译器命令行：–enum_is_int】很容易理解，我们枚举时成员变量类型为int型。 Plain Char is Signed：纯字符标记为字符【设置编译器命令行：–signed_chars】代码举例：char a[] = “abcd”; 也就是说将“abcd”标记为字符型。 Read-Only Position Independent：为常量生成独立的代码空间【设置编译器命令行：–apcs=/ropi】比如：我们定义字库变量为常量，勾选该选项，会将这些字库变量放在独立的代码空间。 Read-Write Position Independent：为可读写代码生成独立的代码空间【设置编译器命令行：–apcs=/rwpi】 Warnings：警告【No Warnings设置编译器命令行：-W】No Warnings：不会有警告提示和输出；All Warnings：所有警告提示和输出。 Thumb Mode：Thumb模式指定设置文件或文件夹（组）为Thumb模式。【注意：在工程中该模式为默认，也就是不能选择】 No Auto Includes：不自动添加头文件不勾选该选项，编译器就会在Keil安装路径寻找你工程中.h文件。举例：我们定义uint8_t是定义在stdint.h文件里面的，但是我们工程目录下一般是没有stdint.h文件。这时候，编译器就会在Keil路径下去寻找stdint.h文件。 C99 Mode：C99标准模式【设置编译器命令行：–c99】C语音有标准有多个版本，如C89、C90、C99等。 GNU extensions：支持GUN扩展GUN ARM C编译器是这后面新增支持的功能。 第3处：包含路径（Include Paths）包含路径是使用Keil（及类似）软件必须掌握的一项。包含路径就是指定我们工程中使用文件所在的位置，让编译器找到相应的文件。 可以参看我之前分享的文章《Keil系列教程02_新建基础软件工程》里面添加路径的方法。 添加路径动画效果: 第4处：多功能控件（Misc Controls）例如：用日本语言来显示消息：–message_locale=ja_JP. 第5处：编译器控制字符串（Compiler control string）这里是针对编译器执行的命令，显示当前在编译器命令行指令。 在上面“第2处：语言代码生成”中有一个中括号【设置编译器命令行：】里面的命令就显示在这里。 三、Asm汇编 Asm选项和“C/C++”类似，只是这里针对的是Asm汇编。因此，这一章节只简述，不会重点强调，可以参看上一章节进行对比，第3、4、5处和C/C++选项一样，这里不讲述。 第1处：条件控制符号（Conditional Assembly Control Symbols）指定汇编条件，这里类似上一章节C/C++选项中的预处理。 第2处：语言代码生成（Language / Code Generation）Read-Only Position Independent：为常量生成独立的代码空间。 Read-Write Position Independent：为可读写代码生成独立的代码空间。 Thumb Mode：Thumb模式。 Split Load and Store Multiple：加载和存储多个分裂。 Execute only Code：只生成执行代码； No Auto Includes：不自动添加头文件（一般不勾选）。 四、Linker链接 Linker链接器配置选项。可以修改、编辑和查看链接的文件。第1、2处是重点，第3、4处和C/C++选项一样，这里不讲述。 第1处：内存配置对话框（Use Memory Layout from Target Dialog）Make RW Sections Position Independent：使RW段独立【设置编译器命令行：–rwpi】启用时：变量区域（包含RW和ZI）具有独立地址。禁用时：变量区域（包含RW和ZI）位于绝对的内存地址。 Make RO Sections Position Independent：使RO段独立【设置编译器命令行：–ropi】启用时：常量和代码区域（RO）具有独立地址。禁用时：常量和代码区域（RO）位于绝对的内存地址。 Don’t Search Standard Libraries：不搜索标准库【设置编译器命令行：–noscanlib】禁用默认编译器运行时库的扫描。 Report ‘might fail’ Conditions as Errors：报告’might fail’条件认为是错误【设置编译器命令行：–strict】报告的条件可能导致失败的错误，而不是警告。 X/O Base：X/O基地址【设置编译器命令行：–xo_base=address】 R/O Base：R/O基地址【设置编译器命令行：–ro_base=address】 R/W Base：R/W基地址【设置编译器命令行：–rw_base=address】 disable Warnings:警用警告【设置编译器命令行：–diag_suppress】 第2处：分散文件（Scatter File）这里可以加载、查看和编辑分散文件。点击后面就的三点“…”可以加载文件；点击“Edit…”查看和编辑对应的文件。 五、Debug调试 这个选项比较重要，主要用于（软件仿真、硬件在线）调试使用。由于软件仿真和硬件在线调试配置类似，这里只讲述硬件在线调试（右边部分）。 第1处：选择硬件在线调试选择下载调试器，以及对应的设置“Setting”。很多人常用J-Link下载调试器，而调试STM32时，可以使用四线SWD模式。如果使用J-Link进行SWD调试。这个时候就需要在“Setting”里面选择“SW”模式，如下如： 第2处：选择硬件在线调试Load Application at Startup：启动时加载应用程序。 Run to main()：程序执行到main()函数。进入调试模式时，程序自动运行到main函数处。 Initialization File：加载、编辑初始化文件。这里在某些情况下可以使用，比如：在RAM中调试代码。可以参看我的文章《STM32内部RAM在线调试配置方法》。 第3处：复位调试会话设置（Restore Debug Session Settings）这里复位设置就是恢复设置的意思，如果勾选上，点击一下“复位”就会恢复到之前的状态。 包括：断点Breakpoints、窗口Watch Windows、性能分析器 Performance Analyzer、内存窗口Memory Window、工具箱Toolbox、系统查阅器System Viewer等。 第4处：DLL文件这里的配置属于Keil自身的配置，最好不要修改。CPU/Driver DLL - Parameter：CPU驱动文件和参数。Dialog DLL - Parameter：会话框DLL文件和参数。 第5处：管理组件描述文件Manage Component Viewer Description Files这里一般不用去管理。 六、Utilities公共 第1处：配置FLASH菜单命名（Configure Flash Menu Command）这里是二选一选项，一般我们使用上面的“Update Target Driver for Flash Programming”。 Use Debug Driver：使用调试驱动 Update Target Before Debugging：调试之前更新目标一般都勾选上，因为我们下载程序之前检测到代码修改了，就会重新编译程序（也就是更新目标） Setting：设置很多人下载程序之后，需要复位一下程序才运行，原因在于没有勾选“Reset and Run”，如下图： Init File：加载/编辑初始化文件 第2处：配置镜像文件（Configure Image File Processing）通过在编译过程中调用FCARM，输入配置映像文件处理(FCARM)的选项。这将把镜像文件转换成c源代码。 七、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程05_工程目标选项配置（一）]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_%E5%B7%A5%E7%A8%8B%E7%9B%AE%E6%A0%87%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面本文讲述的内容是“Options for Target”，即工程目标选项的配置内容，也就是我们常见的工程配置内容。 由于目标配置的选项比较多，我将其分为工程目标选项配置（一）和工程目标选项配置（二）两篇文章来讲述。 目标选项包含了一个工程目标所有的配置信息，这些信息是保存于我们工程（.uvprojx）和对应的（.uvoptx）文件。 二、本文要点本文主要讲述的是目标选项的配置，但为了让更多人明白什么是目标选项，首先将简述工作空间、工程、目标的意思和区别。 2.1 打开目标选项的三种方法A.点击“目标选项”快捷按钮，如开篇第一张图。 B.快捷键：Alt + F7提示：如果是配置工程，需选中工程，再按Alt + F7。（如果你选中文件，是对文件的一些配置） C.从菜单中打开，Project -&gt; Options for Target，如下图： 2.2 本文所讲述的目标选项 由于目标选项里面内容较多，本文只讲述前五项：Devie设备、 Target目标、 Output输出、 Listing列表、 User用户。后五项在下一篇文章讲述。 本文旨在让大部分人明白目标选项的配置，为了使文章内容精简，过于简单和不常用过于复杂的只简述。 三、工作空间、工程、目标含义和区别什么是工程目标选项配置？或许有些人分不清工作空间、工程、目标这三个名词的意思和区别，这里就简单讲述一下它们的含义和区别。 可以关注该系列教程后面新建多工程，多目标的文章。 工作空间、工程、目标它们三个是从大到小，依次包含的关系：工作空间 &gt; 工程 &gt; 节点。也就是说：一个工作空间可以有多个工程，一个工程可以有多个目标。示意图，如下： 举个例子：一个项目，由主机和从机组成，但项目为了区分产品的高低端，将产品做成简单和复杂两个版本（简单版只保留复杂版的部分功能）。举例示意如下图： 本节内容不过多描述，在大型的实际项目中容易看见，一般不是很大项目，基本就是一个工程，一个目标或多个目标。 初学者一般都是一个工程对应一个目标，这样简单明了。若初学者不能理解可以略过。 四、Device设备（器件） 《Keil新建软件工程》第一步就是选择设备（器件）。强调一点就是：器件可以通过输入查找，也可以通过列表查找。 五、Target目标 这里说的目标和上面说的工程目标不一样，是工程目标的目标。从内容可以看得出来是工程目标的调试晶振频率、选择的编译器、RAM和ROM分配的地址空间等。 第1处：晶振频率这个值主要用于仿真调试用，一般我们使用硬件调试可以不用管这个值。第2处：操作系统很好理解，是否选择Keil自带的RTX操作系统，一般我们都不选。第3处：系统预览文件这里我们一般是默认使用系统自带，不选择自己定义的。第4处：生成代码所选择的编译器 第5处：使用交叉模块优化、使用微库交叉模块一般我们不使用，微库这个功能常用与printf函数。 第6处：ROM存储地址这里的ROM存储指的是程序储存的地址，分片外、片内两种。 程序存储在片内好理解（初学者一般下载程序都是下载到片内FLASH）,片外存储程序对于初学者来说比较少见，一般都是项目做大了，或有特殊要求时，片内不够使用了才将程序存储在片外。 第7处：RAM存储地址RAM存储地址和ROM道理一样，可以分片内和片外。 六、Output输出 输出分两类：1.输出（创建）可执行文件：我们下载到处理器里面的程序就是该类； 2.输出库：对于初学者来说一般不使用库，但对于很多从事特殊行业技术开发的公司来说，可能比较常用该功能。 第1处：输出路径输出路径就是在工程编译的过程中，输出这些文件保存的文件夹。（Keil V5一般默认是保存在Objects文件夹下面） 第2处：输出可执行文件名输出的可执行文件和库的名称就是在这里定义。比如我们常见输出Hex文件，其名称就是这里定义的。 第3处：输出可执行文件这里和输出库是二选一，选择了输出可执行文件就不能选择输出库。 Debug Infomation：输出调试信息。勾选上这个选项，我们才可以进行调试。 Create HEX File：输出可执行Hex文件。很多初学的朋友问：“在哪里设置生成Hex?”，这里勾选上就行了。 Browse Information：输出浏览信息。勾选上这个我们才能使用go to definition of这个功能。很多人问：“为什么我不能跟踪代码了”，原因就在这里。 提示：输出这些中间文件都很费时间，如果都不勾选这些选项，编译速度会很快。 第4处：输出库选择输出库，上面可执行文件就不能输出。提示：这里输出（生成）的是静态库，并非动态库。 七、Listing列表 这个选项是关于生成列表相关的选项，对代码分析比较透彻的工程师就需要了解这个选项。常见的map地址的分布，就是在这里配置生成的。 第1处：输出路径、宽高选择列表文件输出的文件夹。可设置文件页面的宽度，长宽。 第2处：输出汇编列表勾选上会输出汇编列表信息（产生后缀为 .lst的文件）。如果工程中没汇编文件，则不会输出信息。 第3处：C编译列表C编译程序列表选项，勾选上可生成.txt, .i文件。 第4处：链接列表可选择生成或禁止生成.map文件。可设置生成代码的详细信息。可选择性的选取输出MAP文件。 八、User用户选项 这个选项是针对用户而设计的，方便用户执行一些程序。比如：编译完代码之后，我要将生成的Hex文件拷贝到其它地方。 纵观上图可以看见，第1、2、3处功能类似，都是让用户运行程序，只是运行的条件不同而已。 这里可以参看曾在微信公众号分享过的一篇文章《MDK-ARM如何通过配置命令生产Bin文件》 第1处：编辑之前运行用户程序 第2处：编译之前运行用户程序 第3处：编译之后运行用户程序 第4处：编译之后执行条件Run “After Build” conditionally：执行条件；Beep When Complete：编译完成发出声音；Start Debugging：启动调试程序。 九、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 十、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【CANOpen系列教程】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、教程列表1.CANOpen系列教程01_初识CAN与CANOpen及相关内容2.CANOpen系列教程02_理解CAN总线协议3.CANOpen系列教程03_CAN收发器功能、原理及作用4.CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明5.CANOpen系列教程05_CAN总线同步与位填充、优先级的决定6.CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）7.CANOpen系列教程07_CANOpen协议概述8.CANOpen系列教程08_CANOpen通信接口引导学习9.CANOpen系列教程09_CANOpen对象字典10.CANOpen系列教程10_关于Canfestival及对象字典生成工具环境搭建11.CANOpen系列教程11_深度分析CanFestival_3架构12.CANOpen系列教程12_对象字典编辑器操作说明13.CANOpen系列教程13_协议源码移植（一） 正在努力更新中，可关注我微信公众号查看最新消息…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程13_协议源码移植（一）]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B13_%E5%8D%8F%E8%AE%AE%E6%BA%90%E7%A0%81%E7%A7%BB%E6%A4%8D%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 基于Canfestival框架的CANOpen协议栈移植教程网上流传着许多，而且有一份不知道被复制、粘贴了多少遍的“CANOpen移植教程”相信许多朋友都知道。 同时，百度、谷歌还能搜出许多所谓“移植代码”。其实，这许多内容，对初学者并没有多大帮助。相反，我觉得还有误导的作用。 我认为基于Canfestival框架的CANOpen协议栈移植需要做的工作并不多，但许多初学者无从下手，究其原因还是有许多内容没有理解到位。 本教程站在初学者角度，尽量将重要内容讲述到位，后面提供移植好的Demo供大家参考学习。 二、移植准备移植前，先让大家认识一下移植的一些准备条件。 2.1 硬件两块带有MCU、CAN控制器和收发器的板卡。 该移植教程以STM32F1（自带CAN控制器），带有CAN收发器的开发板为例来讲述。 条件允许的情况下，可以购买一个CAN总线分析仪。没有分析仪的朋友，可以用我《CANOpen系列教程06》提供的一个例程来抓取CAN总线数据。 因例程在中断里用串口打印传输数据。所以，用例程抓取的CAN总线传输速率不能太快（建议低于20帧/秒）。 2.2 MCU资源1.CAN：CAN总线通信（必备）；2.TIM：CANOpen协议调度（必备）；3.UART：调试信息（选配）；4.GPIO：板卡状态指示灯（选配）； 2.3 STM32标准外设库+FreeRTOS工程本教程基于STM32标准外设库和FreeRTOS系统搭建的工程为例（很早之前我分享过），这里不讲述。 运行RTOS主要是牵涉到CAN总线数据的发送和接收需要两个线程来处理，以及增加一个CANOpen应用程序线程。 基于其他MCU以及RTOS原理类似，也可参考本文。 2.4 下载Canfestival源码并搭建好环境这里的内容，如果你不明白，请务必先阅读该教程前几篇相关文章。 三、生成对象字典本移植教程重点是将CANOpen协议源码移植到MCU中，使其成功运行。因此，对象字典只配置最基础的“心跳”。 下面教大家在对象字典编辑器中生成带“心跳”的对象字典。 1.打开编辑器，文件 -&gt; 新建 2.新建“主站”节点 3.配置心跳信息 4.保存对象字典：文件 -&gt; 保存 -&gt; 保存在一个指定位置 5.建立对象字典 到这里就生成了三个文件：TestMaster.od、 TestMaster.c 和 TestMaster.h需保存好，在后面需要使用这个对象字典源码。 提示：A.上面牵涉到三个地方保存名字：节点名字、对象字典工程名字、对象字典源文件名字，建议都一样。 B.主站和从站的生成原理一样，上面是生成主站TestMaster对象字典，从站TestSlave对象字典请按照同样方式生成即可。 四、提取CANOpen源码本节内容主要针对初学者使其更加理解移植的代码工程，将CanFestival中源代码提取做一定说明，并且尽量将源码文件对应到自己工程下。 当然，本文按照常规方式提取，你也可以按照自己方式提取。同时，整个工程下其它，如STM32标准外设库、FreeRTOS这些文件在这里不作说明。 1.提取头、源文件（如下图） CANOpen\inc目录下19个.h头文件，来自Canfestival-&gt;include下目录19个头文件； CANOpen\inc\stm32目录下3个.h头文件来自Canfestival-&gt;include\cm4；其中canfestival.h文件是函数接口定义（声明），函数内容需要自己实现（位于：App\canopen目录下canopen_drv.c）； CANOpen\src目录下12个.c源文件，来自Canfestival-&gt;src目录12个源文件（symbols.c源文件为linux下使用的文件，不需要提取）；其中需要删除dcf.c文件下第59、98行前面的“inline”关键字； 2.头文件说明 要修改一下其中的canfestival.h文件： 3.建立canopen文件夹并提取文件 在工程下建立canopen文件夹，提取相应的文件，同时建立自己的文件：canopen_app和canopen_drv. 还需要修改一下congfig.h文件，如下图： 4.建立CAN和TIM底层驱动文件 在上面canfestival.h文件提供了CAN和TIM的驱动接口，但我们这里不用它那一套接口，自己定义在bsp_can和bsp_timer源代码下。 五、下载为照顾初学者，将移植过程讲述的更加详细，移植工作在下一篇文章还会继续讲述，提前把移植好的、带有“心跳”的Demo工程给大家下载。 https://pan.baidu.com/s/1LzD0Epc-Z8vlHsb-sD3WVw提取码：l2dc 提示：如果链接失效，公众号回复【CANOpen系列教程】获取更新链接； 六、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程04_菜单概述]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面Keil菜单如下图所示，本文以Keil MDK-ARM为例，Keil C51菜单的大部分内容一样，因此也适用于Keil C51。 Keil有些菜单在编辑模式和调试模式下可能有所不同，也就是说在不同模式下有些功能不能使用。 提示：在上一篇教程《Keil系列教程03_主窗口和工具栏详细说明》中讲述的工具栏按钮属于各菜单的子菜单内容。 二、File文件菜单 1.New：新建文件 Ctrl + N2.Open：打开文件 Ctrl + O3.Close：关闭文件 Ctrl + W4.Save：保存当前文件 Ctrl + S5.Save As：文件另存为6.Save All：保存所有（文件及工程设置）7.Device DataBase：器件数据库（信息）8.License Management：许可证管理9.Print Setup：打印设置10.Print：打印 Ctrl + P11.Print Preview：打印预览12.Exit：退出（关闭）软件 三、Edit编辑 Edit编辑子菜单的大部分内容都位于该教程上一篇文章讲述的《工具栏》按钮，这些子菜单内容使用频率较高，所以很多都有快捷键。 1.Undo：撤销编辑 Ctrl + Z2.Redo：恢复编辑 Ctrl + Y3.Cut：剪切 Ctrl + X4.Copy：复制 Ctrl + C5.Paste：粘贴 Ctrl + V6.Navigate Backwards：跳转到上一步 Ctrl + -7.Navigate Forwards：跳转到下一步 Ctrl + Shift + -8.Insert/Remove Bookmark：插入/移除书签 Ctrl + F29.Go to Next Bookmark：跳转到下一个书签 F210.Go to Previous Bookmark：跳转到上一个书签 Shift + F211.Clear All Bookmarks：清除所有标签 Ctrl + Shift + F212.Find：查找 Ctrl + F13.Replace：替换 Ctrl + H14.Find in Files：在文件中查找文本 Ctrl + Shift + F15.Incremental Find：逐个查找文本 Ctrl + I16.OutLining：提纲（如显示函数名称，隐藏函数体）17.Advanced：（更多）先进功能18.Configuration：配置 四、View视图 View菜单包含状态栏、工具栏、窗口等视图，在调试模式下比在编辑模式下要多出一些调试视图窗口，而上面常规的视图窗口都一样。 编辑模式基础菜单1.Status Bar：状态栏2.Toolbars：工具栏3.Project Window：工程窗口4.Books Window：书籍窗口5.Functions Window：函数窗口6.Templates Window：模板窗口7.Source Browser Window：源码浏览窗口8.Build Output Window：编译信息输出窗口9.Error List Window：错误列表窗口 调试模式增加菜单10.Command Window：命令显示窗口11.Disassembly Window：反汇编窗口12.Symbols Window：模块窗口13.Registers Window：寄存器窗口14.Call Stack Window：被调用函数堆栈窗口15.Watch Windows：查看（变量）窗口16.Memory Windows：内存窗口17.Serial Windows：串行UART窗口18.Analysis Windows：逻辑分析仪窗口19.Trace：跟踪窗口20.System Viewer：系统（外围IO、USART、TIM等）窗口21.Toolbox Window：工具箱窗口22.Periodic Window Update：窗口周期更新选择 常规View视图动画效果： 五、Project工程 Project菜单只能在编辑模式下才能使用，调试模式为灰色不能用。子菜单里面许多内容在后面会详细讲述。 1.New μVision Project：新建工程（单工程）2.New Multi-Project Workspace：新建工作空间3.Open Project：打开工程4.Close Project：关闭工程5.Export：导出（工程）6.Manage：管理（工程）7.Select Device for Target：选择工程目标8.Remove item：移除目标9.Options for Target：工程目标选项配置 Alt + F710.Clean Targets：清除工程11.Build Target：编译工程目标 F712.Rebuild all Target files：重新编译所有目标文件13.Batch Build：分批编译（多工程编译）14.Translate：编译当前活动文件 Ctrl + F715.Stop Build：停止编译（正在编译时有效） 六、Flash编程 Flash菜单只有在编辑模式下可以使用，比较简答 1.Download：下载程序 F82.Earse：擦除芯片FLASH3.Configure Flash Tools：配置FLASH工具（打开目标对话框选项） 七、Debug调试 Debug菜单在两种模式下差异很大，该菜单基本上用于调试模式。 1.Start/Stop Debug Sesion：开始/停止调试 Ctrl + F52.Reset CUP：复位CPU3.Run：全速运行 F54.Stop：停止运行5.Step：单步调试（进入函数） F116.Step Over：逐步调试（跳过函数） F107.Step Out：跳出调试（跳出函数） Ctrl + F118.Run to Cursor Line：运行到光标处 Ctrl + F109.Show Next Statemt：显示正在执行的代码行10.Breakpoints：查看工程中所有的断点 Ctrl + B11.Insert/Remove Breakpoint：插入/移除断点 F912.Enable/Disable Breakpoint：使能/失能断点 Ctrl + F913.Disable All Breakpoint：失能所有断点 Ctrl + Shift + F914.Kill All Breakpoint：取消所有断点15.OS Support：系统支持（打开子菜单访问事件查看器和RTX任务和系统信息）16.Execution Profiling：执行分析17.Memory Map：内存映射18.Inline Assembly：内联汇编19.Function Editor：函数编辑器20.Debug Setting：调试设置 八、Peripherals外设 Peripherals菜单只能在调试模式下使用。Peripherals外设直白的意思就是查看这些寄存器的值。 1.System Viewer：查看系统外设2.Core Peripherals：内核外设 九、Tools工具 Tools菜单在两种模式下差不多，复杂且不常用，只简述。 1.Setup PC-Lint：配置PC-Lint2.Lint：PC-Lint运行在当前编辑器文件3.Lint all C Source Files：在您的项目中运行PC-Line C源文件4.Configure Merge Tool：配置合并工具帮助迁移RTE软件组件文件的特定于应用程序的设置5.Customize Tools Menu：自定义工具菜单。 这里相对来说常用一点的就第5项“Customize Tools Menu”，可以自定义工具菜单。比如：我之前在公众号分享过一篇文章《MDK-ARM代码格式化插件AStyle》，就是添加一个自定义的工具菜单。 十、SVCS版本管理 1.Configure Software Version Control：配置软件版本控制 我们一般都不使用这个自带的版本控制系统，较常用的版本管理软件“TortoiseSVN”和“Git”。 十一、Window窗口 Window菜单在两种模式下差不多，Window窗口菜单要和前面View视图菜单区别开来。 1.Reset View to Defaults：重置窗口布局（µVision默认的Look &amp; Feel)2.Split：活动编辑器文件分割成两个水平或垂直窗格。3.Close All：关闭所有打开的编辑器。 重置窗口布局动画效果： 十二、Help帮助 我写的这系列文章大多数也是参考这里Help帮助菜单，只是这个帮助文档都是英文的。当然，很多内容也是根据我的经验而写成。建议大家有不懂的地方多参考这里的帮助文档。 1.µVision Help：打开帮助文档2.Open Books Window：打开帮助书籍3.Simulated Peripherals for object：关于外设仿真信息4.Contact Support：联络支持5.About µVision：关于 十三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 十四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程03_主窗口和工具栏详细说明]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_%E4%B8%BB%E7%AA%97%E5%8F%A3%E5%92%8C%E5%B7%A5%E5%85%B7%E6%A0%8F%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[一、写在前面 本文先让大家简单认识一下Keil的主窗口界面，然后再进一步认识Keil的文件、编译和调试工具栏。 Toolbars工具栏就是在菜单下面的两行快捷图标按钮，这些快捷按钮之所以在工具栏里面，在于它们使用的频率较高。比如保存按钮、编译按钮、下载按钮等。 本文讲述的Toolbars工具栏和大部分上位机软件的工具栏类似，就是一些常用的快捷按钮。 本文以Keil MDK-ARM为例，因Keil C51的工具栏和MDK-ARM类似。因此，本文大部分内容也适用于Keil C51。 二、主窗口界面为了让大家对Keil集成开发环境有一个大概的了解，这里先概述一下Keil 默认编辑状态（模式）主窗口界面下各个窗口的含义。 说明：Keil主窗口界面在编辑状态与调试状态下存在一定差异，本章节主要基于【编辑状态】进行简单的概述，里面详细的内容、以及调试状态下的窗口在该系列教材后续会逐步讲述。 在编辑模式下，一般会出现类似下图的主窗口界面，如下图： 1.Menu Bar菜单栏相信大家对菜单栏都不陌生，包含File文件、 Edit编辑、 View视图、 Project工程、 Help帮助等这样的一栏窗口。 菜单栏是 Keil 比较重要的一个窗口，几乎 Keil 所有操作的内容都包含在里面。同时。在编辑状态和调试状态下存在一些不同，后续会详细讲述。 2.Tool Bar工具栏该窗口是一些常见的快捷按钮，本文下面会重点讲述。 3.Project工程窗口一个工作空间可以包含多个工程，该窗口主要显示工作空间下面工程项目的内容（工程、 组、 源代码文件等）。 后续也会讲述新建多工程。 4.Edit Window编辑窗口该窗口不用多解释，就是我们平时编辑代码的窗口。 5.Message Window信息窗口该窗口包括编译信息、调试信息、查找信息等一些信息的窗口。 6.Status Bar状态栏该窗口包含就绪状态、错误警告数量、光标行列、字符编码、键盘Num锁定等一些状态信息。 三、工具栏Keil的Toolbars工具栏共有三种：File Toolbar文件工具栏、 Build Toolbar编译工具栏、 Debug Toolbar调试工具栏。 在两种状态（模式）下呈现不同工具栏。在编辑状态时，呈现文件、编译两种工具栏；在调试状态时，呈现文件、调试两种工具栏。 3.1 两种状态下的工具栏1.编辑状态包含：File Toolbar文件工具栏、 Build Toolbar编译工具栏； 2.调试状态包含：File Toolbar文件工具栏、 Debug Toolbar调试工具栏； 3.2 工具栏详细内容如下图，将编辑状态和调试状态的工具栏按钮分为12类，下面将这12类工具栏按钮依次进行详细说明。 1.文件操作类按钮这一类按钮可以说在大部分上位机软件都可见，比较简单，不过多描述。 名称 描述 快捷键 New… 新建文件 Ctrl + N Open 打开 Ctrl + O Save 保存当前文件 Ctrl + S Save All 保存所有文件 – Cut 剪切 Ctrl + X Copy 复制 Ctrl + C Paste 粘贴 Ctrl + V 2.文件编辑跳转类按钮撤销恢复按钮比较常用，可以使用快捷键代替。 名称 描述 快捷键 Undo 撤销编辑 Ctrl + Z Redo 恢复编辑 Ctrl + Y Navigate Backwards 跳转到上一步 Ctrl + - Navigate Forwards 跳转到下一步 Ctrl + Shift + - 撤销恢复动画效果 跳转动画效果 3.书签类按钮书签的作用主要是标记位置方便查看。 名称 描述 快捷键 Insert/Remove Bookmark 插入/移除书签 Ctrl + F2 Go to Next Bookmark 跳转到上一个书签 Shift + F2 Go to Previous Bookmark 跳转到下一个书签 F2 Clear All Bookmarks 清空所有书签 Ctrl + Shift + F2 书签动画效果 4.选中行操作类按钮选中行操作的作用主要就是为了使选中行缩进、注释。 名称 描述 快捷键 Indent Selection 插入缩进 Tab Unindent Selection 取消缩进 Shift + Tab Comment Selection 确定注释 – Uncomment Selection 取消注释 – 缩进动画效果 注释动画效果 5.查找文本类按钮查找文本意思就是搜索，比较简单，也比较常用。 名称 描述 快捷键 Find in Files 在文件中查找文本 Ctrl + Shift + F – 查找文本输入框 – Find 查找单个文本 Ctrl + F Incremental Find 逐个查找文本 Ctrl + I 6.仿真类按钮这些按钮针对仿真时，具有断电标记作用。 名称 描述 快捷键 Start/Stop Debug Session 开始/停止调试 Ctrl + F5 Insert/Remove Breakpoint 插入/移除断点 F9 Enable/Disable Breakpoint 使能/失能断点 Ctrl + F9 Disable All Breakpoints 失能所有断点 – Kill All Breakpoints 取消所有断点 Ctrl + Shift + F9 7.窗口配置类按钮 名称 描述 快捷键 Project Windows 工程窗口 – Configuration 配置 – 工程窗口按钮支持快速打开/关闭某些窗口，和View视图菜单功能一样，工程窗口内容下图： 8.编译类按钮这些按钮使用频率较高，特别是编译目标F7快捷键。 名称 描述 快捷键 Translate 编译当前文件 Ctrl + F7 Build Target 编译工程目标 F7 Rebuild all Target files 重新编译所有目标文件 – Stop Build 停止编译（正在编译时有效） – Batch Build 分批编译(多工程) – Download 下载 F8 9.工程选项类按钮 名称 描述 快捷键 – 工程目标选择框 – Options for Target 工程目标选项(配置) Alt + F7 一个工程下面可以建立多个目标，工程目标选择框的目标（STM32F103ZE）也就是当前所选中（使用）的工程目标（后期会讲述多目标）。 Options for Target即对选中目标（STM32F103ZE）的配置。 10.工程项目管理类按钮 名称 描述 快捷键 Manage Project Items 单工程管理 – Manage Multi-Project 多工程管理 – Manage Run-Time 管理运行时环境 – Select Software Packs 选择软件包 – Pack Installer 软件包安装 – 11.调试按钮 名称 描述 快捷键 Reset 复位 – Run 全速运行 F5 Stop 停止运行 – Step 单步运行 F11 Step Over 逐步运行 F10 Step Out 跳出运行 Ctrl + F11 Run to Cursor Line 运行到光标行 Ctrl + F10 Show Next Statement 跳转到暂停行 - 12.调试窗口开关按钮调试视图窗口开关按钮这里就不说了，快捷按钮内容就是View视图菜单下的内容（如下图）。在后面《菜单》、《调试》还会继续讲述。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程12_对象字典编辑器操作说明]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8%E7%BC%96%E8%BE%91%E5%99%A8%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[一、写在前面 教程前面文章讲述了《对象字典生成工具环境搭建》，因为对象字典在CANOpen中的分量比较重。所以，关于对象字典的内容，及对象字典编辑工具也需要我们深入了解。 对象字典编辑器这个工具的操作并不难，这里需要强调两点：1.先了解「CANOpen通信接口」相关知识； 2.理论结合实践，只看不动手实践操作，想要掌握这些知识就很难。 本文讲述的内容在该教程前一篇文章《CanFestival_3架构》中“开发一个新节点”就有提到。本文将更加全面讲解这部分内容。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、对象字典编辑器操作步骤依然，针对初学的朋友，讲述的非常基础，希望初学的朋友先阅读该教程前面的文章。我们基于Windows的GUI图形化界面为例， 1.下载并搭建好环境请参看《对象字典生成工具环境搭建》！ 2.运行对象字典编辑器保证环境搭建没有问题，双击objdictgen目录下的objdictedit.py（或进入该目录，以命令方式运行）： 3.创建一个新节点文件 -&gt; 新建，出现创建节点界面，如下图： A.类型：可选主、从节点；B.名字：自己定义节点名称；C.Profile：配置，如DS401等；D.网络管理：是否选择相关网络管理（请先了解网络管理）； 初学者可以从基础学起，如上图最简单方式配置，这里以新建从节点“SlaveNode”为例。 提示：这里SlaveNode是从节点的名字，是生成对象字典（代码）的名字，和保存的名字有区别。 4.配置对象字典创建节点确认后，会进入对象字典配置界面。此时，你会发现里面内容就是之前讲述的对象字典索引，如下图： 对象字典内容很多，大概就分为如上图几类。图形化界面，配置方式可以说很简单。也就是对字典的16 位索引和 8 位子索引进行配置。 当然，我这里不会一一讲述每项内容，后面会结合例程，针对性讲述相关内容。配置方法大致如下三步骤： 5.保存对象字典文件 -&gt; 保存，输入对象字典（工程）名称。 我们这里的名称，我把叫做其“工程名称”，建议与前面创建节点名字一样（当然，这两个名字意义不一样，所以也可以不一样）。 这个对象字典（工程）是用于后面升级或者更改使用，所以建议保存好。 6.生产对象字典文件 -&gt; 建立词典，选择保存的路径。 此时，就会看到两个源代码文件：SlaveNode.c和SlaveNode.h文件。这两个文件就是我们最终需要的对象字典源文件。 7.其他操作A.文件 -&gt; 导出成EDS文件，这里可以到处EDS用于其他对象编辑工具使用；B.帮助，关于这个工具很多内容，都可以通过帮助菜单找到答案。 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程02_新建基础软件工程]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 目前Keil的四款产品（软件）：MDK-ARM、C51、C251、C166，在用法上极为相似，包括本文讲述的新建软件工程。 本文以目前（2018年10月）最新Keil MDK-ARM V5.26、STM32F103标准外设库为例，来给大家讲述新建软件工程的具体步骤。 本文讲述的新建软件工程，只是最基础的软件工程（一个工程，一个目标）。其中只修改了必要的配置，大部分配置默认。 如果你是Keil C51、或者其它MCU器件，本文也适用，只是针对MCU器件有略微差异。 二、准备工作俗话说“磨刀不误砍柴工”，做好了准备工作，后面新建基础软件工程的工作就很容易实现了。 这里针对STM32会下载“标准外设库”这个准备工作，如果你是C51，或者不用库，这个准备工作就可略过。 2.1 下载安装Keil工具本文必备工具，详情请参看该系列教程上一篇文章《Keil系列教程01_Keil介绍、下载、安装与注册》。 2.2 下载STM32标准外设库这一节是准备源代码（库），如果你使用C51、寄存器开发，本节内容可以略过。下面提供官方下载链接，嫌麻烦的朋友可以在我百度网盘下载。 A.官网下载http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software.html?querycriteria=productId=SC961 根据芯片型号下载对应的标准外设库（如芯片为STM32F103ZE，则下载对应的STM32F10x_StdPeriph_Lib），如下图： B.百度网盘http://pan.baidu.com/s/1qYbBKMK 提示：如果以上链接失效，可以关注微信公众号，获取更新链接。 2.3 整理工程文件夹这一小节的内容可根据自己习惯来整理，我整理的文件及文件夹结构是按照常规的整理方式。你如果觉得合理，可以引用； 首先建立一个存放工程文件的总文件夹：STM32F103ZE（Keil）_Demo A.提取ST标准外设库文件ST标准外设库里面源代码文件我们只需要使用部分文件。因此，提取需要使用的文件及文件夹到我们的工程中。 解压“STM32F10x_StdPeriph_Lib”，可以看到在主目录下面有四个文件夹：_htmresc：图片文件夹（不提取）Libraries：库文件夹（提取大部分）Project： 示例工程（提取少部分）Utilities： 公共代码、评估板代码（不提取） 我们需要使用Libraries和Project目录下的文件，但也有部分不用。因此，我们需要删除不用的文件。（具体保留了哪些，可以下载我提供例程查看） B.新建文件和文件夹除了上面提取的文件之外，我们需要建立存放自己代码的文件和文件夹。我这里主要新建三个文件夹：App: 应用部分代码Bsp: 底层部分代码Doc: 说明文档 在新建的文件夹下面还需要新建自己的源文件，源文件里面添加源代码。我们提供的Demo工程，实现的一个LED闪烁的功能。（这里不描述）。 上面两个步骤完成之后，我们就可以看到在“STM32F103ZE（Keil）_Demo”下面整理的文件夹： 至此，准备工作算完成了，上面提取的文件、新建的文件里面具体的内容请下载Demo工程查看。 三、新建软件工程新建一个简单、基础的软件工程大概需要有三个步骤：建立工程、添加文件和配置工程。 上面的准备工作做好之后，就可新建自己的软件工程了，下面将一步一步讲述从零开始新建一个软件工程的详细过程。 3.1 建立工程建立工程的步骤是基础，也比较简单，下面一步一步教大家新建一个空的工程。 A.打开软件,新建立工程（Project -&gt; New uVision Project） B.选择保存路径，保存名称 C.选择芯片型号 D.基础工程 一个基础的工程就完成了，但还不够，还需要下面的步骤。 3.2 添加文件准确的来说，应该是添加组（文件夹）和添加文件。直接的说，就是将你自己的源代码（前面提取的库、新建的文件等）添加到工程中。 这里的工程项目管理可根据自己的想法来定义（类似于自己分类、命名文件夹和文件），我这里按照常规的方式进行管理项目。 点击“项目管理”快捷按钮，或者Project -&gt; Manage -&gt; Project Items 进入“项目管理”界面。 ·· 一步一步添加，直到最后完成·· 3.3 配置工程配置工程对于初学者来说，大部分内容只需要默认即可，这里只讲述几个常见的配置，能满足基本的功能。 A.点击“工程目标选项”进入配置（或Project -&gt; Options for Target） B.输出Hex文件很多朋友初学的朋友都会问怎么输出Hex，只需要勾选上【Project -&gt; Options for Target -&gt; Output】“Create HEX File”即可。 C.C/C++配置这个选项的配置参数比较多，对于大型项目来说比较重要，但对于初学者来说，只需要简单配置两项就行。 第一处配置—预定义：【这里以STM32F103大容量芯片为例】 预定义STM32F10X_HD，等同于#define STM32F10X_HD. 有些工程还预定义USE_STDPERIPH_DRIVER。由于都是使用“标准外设库”，我个人习惯把USE_STDPERIPH_DRIVER，定义在stm32f10x.h文件里面，所以在这里就看不到我定义的这一项了。 第二处配置—包含路径：由于我们前面工程中有很多文件夹，因此需要添加对应的路径，这样编译器才能找得到。 ·· 一步一步添加，直到最后完成·· D.选择下载调试工具这个选项根据自己的下载调试器来选择（比如：ST-Link） E.下载复位并运行设置有些初学的朋友说“为什么我下载程序之后，需要按一下复位键才能运行？”，只需要在工程中勾选上“Reset and Run”就可实现，下载完程序马上运行了。 至此，一个新建立的工程就算完成了（当然，我新建的文件是添加了正确的源代码），只需要编译，接上下载器就可以下载运行了。 四、下载为方便广大STM32学习者，我将常见的STM32“Demo软件工程”已经建好，里面还包含EWARM建立的工程供大家下载。 STM32F0工程模板:http://pan.baidu.com/s/1pKSkSxt STM32F1工程模板:http://pan.baidu.com/s/1c1AWupM STM32F2工程模板:http://pan.baidu.com/s/1o8yGWg6 STM32F3工程模板:http://pan.baidu.com/s/1boVXh2f STM32F4工程模板:http://pan.baidu.com/s/1qYzYMuS STM32L1工程模板:https://pan.baidu.com/s/1rNPC3JQD7iLchVUEJlTjCQ 提示：如果以上链接失效，可以关注微信公众号，获取更新链接。 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程11_深度分析CanFestival_3架构]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90CanFestival_3%E6%9E%B6%E6%9E%84.html</url>
    <content type="text"><![CDATA[一、写在前面 教程上一篇文章《关于Canfestival及对象字典生成工具环境搭建》中我们简单认识了一下Canfestival这套免费开源CANOpen协议的框架。 那么，本文将会以下载的PDF手册（源码里面也有）为导向，来深入解析Canfestival这套框架。 本文大概分两部分来讲述： 1.manual手册概要内容； 2.解析Canfestival源码； 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、manual手册概要内容请先下载我们教程上一篇文章《关于Canfestival及对象字典生成工具环境搭建》提到的PDF手册（解压源码，在目录objdictgen\doc下面也有manual_en.pdf手册文档）。 打开PDF手册，我们可以清楚的看到手册共有12章。对于使用STM32开发的初学者来说，相对重要一点的章节有：2, 3, 4, 9这些章节。 为了照顾初学者，这里先把每一章节内容概述一下，后面在重点讲述部分的内容。 2.1 内容概要第1章Introduction介绍主要介绍了CanFestival是一个开源(LGPL和GPL) CANopen框架，CanFestival项目的起源及支持。同时，也介绍了什么是CANOpen协议，以及协议相关的规范。 第2章CanFestival特征1.工具：提供对象字典GUI图形化编辑器、代码生成，以及脚本等配套工具；2.多平台：库源代码是ANSI标准C，支持多平台编译和开发；3.CANopen标准：支持DS-301、302、305等标准的CANOpen协议。 第3章How to start如何开始这一章节其实主要就是对一些环境的要求和配置，及如何获取CanFestival等。 其实，对我我们使用MCU开发的人来说，重要的就是对象字典编辑和生成工具的环境（具体请参看教程上一篇文章《对象字典生成工具环境搭建》）。其它基于Windows、Linux开发的环境，大家可以参考文档配置一下，这里不讲述。 第4章理解Canfestival主要讲述：理解源代码文件目录划分情况、在应用程序中实现CanFestival以及源文件结构关系、CAN底层驱动接口的调用和实现、对事件调度的实现方法。 本章节内容直接牵涉源代码相关内容，所以说比较重要，下面章节将进一步详解。 第5、6章这两章节主要是针对Linux、Windows平台的配置和开发相关内容，感兴趣朋友可以认真研究一下，这里不讲述。 第7章主要讲述源码提供的HCS12例程相关的编译、下载、硬件连接以及演示。这里参考意义也不大，如果你有对应的板卡，可以参考进行演示一下。 第8章例程和测试程序这一章节讲述了配套提供的一些例程的相关说明。比如TestMasterSlave主从站测试例程中心跳发生器时间为1000毫秒等。 这些说明在源代码中也有，通过查看提供的源代码一目了然。所以，参看价值也不是很大。 第9章开发一个新节点这一章比较重要，我们开发一个新的节点，就需要编辑其对象字典，那么就需要通过编辑器编辑对象字典并生成代码。 简单的说，这章节的重要内容就是让你学会如何使用这个对象字典编辑器工具。 第10章FAQ常见问题这一章节，初学者能看懂的还建议看下有些问题可能对你有帮助，比如：CanFestival3是否符合DS301 V4.02版本? 第11章文档资源主要就是一些参考网址。 第12章关于这个项目不是重点，可以了解一下这些信息。 三、解析Canfestival源码3.1 源文件目录解压下载的源码压缩包，会看到如下图文件及文件夹： 我们主要需要的三个.c .h源文件目录：drivers：底层驱动；include：.h头文件；src：.c源代码； 一个对象字典生成工具：objdictgen：object dictionary generate. examples：例程，初学者可以参考； 3.2 源代码结构关系及应用程序如何实现这里有一张源文件的结构关系图，大致就是将源文件按照其作用进行了划分，初学者需要多看多理解。 从图中我们可以看出，将源代码划分成三块。中间的Library库文件我们不会去动它。主要修改左右两边的代码。 左边CAN底层驱动接口（前面我提供过STM32例程）。Target目标接口，如定时器。 右边底部对象字典，我们需要通过工具事先配置好，不需要人为编写。最后就是我们通过调用API函数，实现应用程序。 提示：最右边的英文希望大家理解一下，对初学者有帮助，如打开CAN接口（也可以叫初始化）、初始化定时器……等。 3.3 CAN底层接口实现和要求我们底层发送要求非阻塞的方式实现，一般我建议跑一个操作系统，加一个队列的方式实现。 需要一个发送线程、一个接收线程，同时需要定时器实现事件的调度。 这一节的内容，对于初学者理解起来相对较难，可以先了解，有一个概念，后面我会结合代码让大家更容易理解其中含义。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程01_Keil介绍、下载、安装与注册]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_Keil%E4%BB%8B%E7%BB%8D%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[一、写在前面 对于学习单片机和嵌入式开发的朋友来说，掌握Keil这款软件可以说是必备的技能。鉴于目前网上没有完整的Keil教程，因此我打算整理一套完整的Keil系列教程。 目前Keil有四种产品（软件）：MDK-ARM、C51、C251、C166。四种软件都是基于µVision，在用法上极为相似。 所以，该系列教程结合目前使用最多的MDK-ARM来讲述，大部分内容也适用于其它三种软件。 二、Keil介绍2.1 概述对于我们程序员来说，大家常说的Keil，其实指的是一款开发工具。同时，Keil也是一家公司名称。 Keil公司是一家业界领先的微控制器（MCU）软件开发工具的独立供应商。Keil公司由两家私人公司联合运营，分别是德国慕尼黑的Keil Elektronik GmbH和美国德克萨斯的Keil Software Inc。 Keil公司2005年由ARM公司收购。其两家公司分别更名为ARM Germany GmbH和ARM Inc。 2.2 MDK-ARMMDK-ARM软件为基于Cortex-M、Cortex-R4、ARM7、ARM9处理器设备提供了一个完整的开发环境。 MDK-ARM专为微控制器应用而设计，而且功能强大，能够满足大多数苛刻的嵌入式应用。 与Keil MDK4及之前版本不同，Keil MDK5分成MDK Core和Software Packs两部分。MDK Core主要包含uVision5 IDE集成开发环境和ARM Compiler5。Software Packs则可以在不更换MDK Core的情况下，单独管理（下载、更新、移除）设备支持包和中间件更新包。 MDK-ARM有四个可用版本，分别是MDK-Lite（免费评估版）、MDK-Essential（基础版）、MDK-Plus（标准版）、MDK-Professional（专业版）。所有版本均提供一个完善的C / C++开发环境，其中MDK-Professional还包含大量的中间库。 MDK产品组件： 关于MDK-ARM的更多详细介绍，及四个版本的差异，请参看我之前在公众号分享的一篇文章《你们都认真了解过MDK-ARM吗？》 2.3 支持芯片Keil MDK-ARM 支持的器件包含 Cortex-M、 Cortex-R、 ARM7、 ARM9、 Cortex-A8系列等多达几千种。 官方支持芯片地址： http://www.keil.com/dd2 三、下载Keil MDK-ARM这个软件建议到官网下载最新版本，我这里也提供百度网盘下载地址（和官网一样）。 上面说了：Keil MDK5分成MDK Core和Software Packs两部分，也就是安装包和支持包。 3.1 MDK-ARM安装包下载目前（2018年10月）Keil MDK-ARM官方最新版本是V5.26，更多老版本及MDK-ARM V4版本，可以在我百度网盘下载【定期更新】。 官方网站：http://www.keil.com/download/product百度网盘：http://pan.baidu.com/s/1eRLbgIY 3.2 MDK-ARM支持包下载MDK-ARM V4 和 V5版本在安装的时候最大的区别在于：V4版本安装包里面集成器件的支持包，而V5版本是独立出来，自己下载安装的。 因此需要下载自己芯片型号对应的器件支持包（我百度网盘提供STM32的器件支持包供大家下载）。 官方网站：http://www.keil.com/dd2/Pack百度网盘：http://pan.baidu.com/s/1o8fd6jS 提示：如果下载链接失效，可关注公众号回复【Keil系列教程】查看更新链接。 四、安装软件4.1 支持的操作系统目前（2018年10月）最新版本MDK-ARM V5.26只支持Windows 7、 Windows 8 和 Windows 10这三个版本操作系统。已经不再支持Windows Vista和 Windows XP系统了。 我记得MDK-ARM V5前面几个版本（好像是V5.19之前版本）还能安装在Windows Vista和 Windows XP这种老系统上，只是部分功能兼容性不好，但也能用。 目前最新版本Keil软件支持的操作系统，可以参看官网说明：http://www2.keil.com/system-requirements 4.2 安装详细步骤Keil四款软件（MDK-ARM、C51、C251、C166）安装方法基本一样，很简单，一路Next下去就行了。 本章节主要针对初学者，下面以图文方式讲述一下安装全过程。 1.以管理员身份运行软件， 进入安装向导界面， 点击“Next” 2.勾选“I agree to…”，许可同意，点击“Next” 3.选择软件和支持包安装路径（可以默认），点击“Next” 4.填写客户信息（可以随便填写），点击“Next” 5.安装过程需要等待几分钟 6.安装完成，点击“Finish” 7.自动更新“支持包”列表，可以直接退出，自己下载安装。 安装软件之后，如果我们不关闭上面自动更新，自动更新完成之后，就会出现“支持包”列表，如下图： 五、安装支持包我把MDK-ARM中用于支持MCU芯片的软件包叫“器件支持包”，所以，我简称“支持包”。 支持包可以通过在线安装，或者下载离线包自己离线安装，这两种安装方式。 5.1 在线安装1.打开MDK-ARM软件，点击“软件支持包”按钮 2.更新列表，选择芯片，安装 在线安装过程就上面几个步骤，点击“Install”之后，需要等待一会儿，下面状态栏有提示，提示安装完成即可直接使用。 5.2 离线安装离线安装支持包就如安装软件一样：下载支持包（上面提供下载），双击下载好的离线包，此时会识别安装路径（前提是已经安装MDK），点击“Next”，一会儿就安装完成。 六、注册Keil MDK是一个收费的软件，官方严厉打击盗版，若你是商业用途，建议购买正版软件。 针对个人学习的朋友，可以使用MDK-Lite免费评估版，只是代码大小有32KB的限制。如果还不能满足你自己需求，建议自行在网上查找注册机或购买正版软件。 同时，ST意法半导体与ARM公司合作，使用MDK-ARM开发STM32F0和L0系列芯片，可以免费获取License。具体请参看：http://www2.keil.com/stmicroelectronics-stm32/mdk 在国内由米尔科技、亿道电子、英倍特提供Keil 的销售和技术支持服务。具体如何购买Keil正版软件，以及它的价格，可以向这些经销商咨询。 七、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程10_关于Canfestival及对象字典生成工具环境搭建]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E5%85%B3%E4%BA%8ECanfestival%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、写在前面 这一篇文章讲述如标题所描述的两大知识点，这两点内容对于初学者来说非常重要，希望想学习CANOpen协议的朋友认真把文章看完。 1.讲述Canfestival框架、官网简述，及衍生出的CANOpen源码基础知识； 2.基于Canfestival框架中对象字典生成工具的环境搭建。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、关于CanfestivalCanfestival是一套免费开源的CANOpen协议栈框架，遵循ANSI-C，支持多平台，我们完全可以借助这一套开源框架来学会CANOpen。 官方主页：https://canfestival.org/index.html.en 从上面主页可以看得出来，网址主要包含三部分内容：Code源码、Documentation文档、Applications应用。 这个网站目前访问有点慢，但还是能访问。可能是因为服务器在法国（IP地址），及这套协议免费开源，没有得到更多资金支持。 下面我将针对初学者，重点讲述一下这三部分内容，以及我们需要重点关注的内容。 2.1 Code源码网址：https://canfestival.org/code.html.en Code代码提供4个资源库（如上图），4个资源库中CANOpen协议源码都沿用一套，简单说协议源码大致相同。 推荐下载第2个的原因：1.有人负责更新维护，目前（2018年）版本最新；2.提供STM32F0、F1、F4系列驱动代码；（下面提供下载） 2.2 Documentation文档网址：https://canfestival.org/doc.html.en 这一项里面主要讲述Canfestival这套框架里面的一些内容，如遵循许可、CanFestival提供了一些GUI和命令行工具，帮助创建一个新的CANOpen节点并编辑对象字典，供主从使用。 我们需要获取的重要内容，都在那个PDF手册里面，建议下载仔细阅读。（这个手册在源码压缩包里面也有：manual_en.pdf） 2.3 Applications应用网址：https://canfestival.org/apps.html.en 这里的“应用”，不是说教你如何编写应用程序，主要是Canfestival应用在哪些地方。如Product产品、Research研究方面。 Beremiz是法国一家公司开发的一款开源的PLC编程工具。在Beremiz里面就集成了CanFestival这套框架（相信折腾过CANOpen的都知道Beremiz）。（这里的“应用”大家可以不用过多深究） 三、CANOpen源码说明及下载3.1 CANOpen源码说明许多初学者都有这么一个疑问：CANOpen协议的源码我们必须要用CanFestival的吗？ 因为CANOpen协议是遵循CiA301、302、CiA401…这些协议，我们的源代码只要符合这些协议规范即可。 CANOpen协议源码也可以自己写，但是耗时耗力完全没必要。所以，我们就使用了免费开源的CanFestival。当然，也可以购买商业化的CANOpen协议源码来开发产品。 不管我们使用免费的CanFestival，还是购买的源码，只要支持CANOpen协议，我们就能与支持CANOpen协议的设备通信。 3.2 下载我们从官网的“Code”进去，会出现4个选项，我推荐下载第2个（上面有说明为什么下载第2个）。进去之后，会看到如下图一些描述： 对于关注我的朋友，大部分都在使用STM32，提供相关的源码参看，想必会有更浓学习的兴趣。 这个源码有多人在更新和维护，所以你会看到有许多分支，我们下载最新版本即可。 下载地址：https://bitbucket.org/Mongo/canfestival-3-asc/downloads 百度网盘下载：https://pan.baidu.com/s/1b9K0vIzu_EVWK1BLURJEPQ 提取码：j2w2 四、对象字典生成工具的环境搭建这里的环境搭建可以参考Canfestival手册（manual_en.pdf）里面的指导，具体位置在3.1.1节：Object Dictionary Editor GUI. 我们需要下载安装第1，2个，第3个就不用单独下载了。 因为我们是在STM32上进行开发，手册中3.1.2节Linux、3.1.3节Windows这些内容我们就不用管了。 4.1 下载Python和wxPython因为和其它工具兼容性的原因，我目前在Win10系统上安装可使用的是python-2.7.15 + wxPython2.8。 其它高版本的Python 3我之前试过好像不行，还有32位和64的也有差异。这里提供给大家（我安装的版本）下载，大家有时间可以在官网下载其它版本试试。 1.百度网盘链接：https://pan.baidu.com/s/1bRS403m4B31m4ovSJ-_HwA提取码：38sn 2.官方下载Python：https://www.python.org/downloadswxPython：https://wxpython.org/pages/downloadswxPython镜像：https://sourceforge.net/projects/wxpython/files/wxPython 4.2 安装1.Python安装Python的安装需要注意两点：1.以管理员身份运行； 2.添加（环境变量）路径。 具体可以参看我公众号之前推送文章《工具下载、环境搭建》中3.2 安装Python. 2.wxPython安装可以通过下载离线包直接安装，也可以通过命令行直接安装。（请看上面给的地址） 4.3 如何成功运行1.解压（上面3.2 下载的）Canfestival-3；2.在解压objdictgen目录下的Gnosis_Utils-current.tar.gz 3.将第2步解压目录下的gnosis拷贝到objdictgen目录下（注意路径），如下图： 4.双击，或者以命令方式运行objdictgen下的objdictedit.py，如果环境没问题，此时就会出现如下界面： 如果不能出现上面界面，请检查环境是否搭建成功。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程09_CANOpen对象字典]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_CANOpen%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章主要是引导大家学习CANOpen协议通信接口的相关内容。通信接口的内容有点多，对于初学者来说，如果看不懂，请多看几遍（最好有个印象）。 CANopen设备最重要的一个部分就是对象字典。对象字典本质上是一种被预先安排的对象序列，可通过网络访问。字典里面的每一对象均可使用一个16-bit主索引和8-bit子索引寻址到。 初学者学习如果难理解通信接口（上一篇）有些内容，如：PDO、SDO及网络管理对象，可以结合对象字典索引来学习和记忆。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、对象字典重要内容对象字典OD：Object dictionary。 一组带有 16 位索引和 8 位子索引的数据或对象。对象字典下面主要包含：数据类型、通信对象、应用对象。 对象字典主索引： 2.1 通信子协议区通信子协议区，如上图1000h 到 1FFFh这个区域。也就是通信接口（或通信对象）协议区。 对于初学者来说，通信对象子协议区是比较重要的一个区域，牵涉到上一篇文章《通信接口》讲述的大部分内容。同时，这之间的关系也非常紧密。 通讯对象子协议区： 如上图，通讯对象子协议区又划分为几个区域，而其中的1000h 到 1029h为通用通讯对象。 通用通讯对象里面的内容已经被约定好，如果我们需要用到，可直接配置使用即可。 通用通讯对象内容： 通信子协议区的内容非常重要，也比较多，需要拆分并一个一个掌握。可结合周立功提供相关教程，以及前面提到的CiA 301手册理解。 我这里就不一一列出来了，简单再列一个通信子协议区中PDO通信参数（对象）与映射参数： 写到这里，想必很多朋友都能理解，也能明白这些内容。更多的内容，可以结合这种拆分的思路去理解。 三、对象字典生成工具上面介绍了对象字典的一些内容，可能还是有很多初学者不明白。同时，也就可能会产生疑问：这个对象字典我们需要字典和我们代码有什么关系呢？ 可以简单来说，就是一些16位索引和8位子索引对应的变量数据，来下看下代码（下面两图），加深理解： 3.1 对象字典的代码需要自己写吗？很多初学者，包括我（之前初学时）也会产生疑问：对象字典的代码需要我们自己写吗？ 答案：不用自己写。 当然，对象字典的代码可以自己写，但完全没必要。1.自己写不一定正确；2.有现成工具可以节约大量时间。 3.2 Canfestival对象字典生成工具我微信公众号分享《CANOpen系列教程》的封面中有一行英文：Canfestival.相信学过CANOpen的朋友都应该知道我接下来会结合这套Canfestival免费开源的CANOpen架构来讲述。 其中，Canfestival里面包含我们需要的CANOpen协议源码和对象字典生成工具。 有了对象字典生成工具，对象字典的代码就可以通过它来自动生成。搭建Canfestival对象字典生成工具的环境是一个重点。 对于很多初学者来说搭建环境也是一个难点，不少初学者就卡在这一关，然后，学习CANOpen就没有继续下去了。 简单的说，搭建对象字典生成工具的环境步骤不多，可能会因为诸多因素导致搭建失败。搭建成功，运行之后会出现如下图界面： 在学习对象字典生成工具时，会看见一个词：EDS，即Electronic Data Sheet电子数据单。 像周立功的CANOpen从站模块就配有工具生成EDS文件。当然，Canfestival提供的工具也能导出EDS文件。 Canfestival对象字典生成工具搭建过程，及相关内容我将在下一篇文章详细讲述。 四、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程08_CANOpen通信接口引导学习]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_CANOpen%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%BC%95%E5%AF%BC%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[一、写在前面 上一章上一篇文章让大家了解了一下CANOpen协议的模型，也就是说CANOpen协议的内容都包含在这个模型里面，而模型里面的内容可以细分出来许许多多的知识。 但是对于初学者来说，并不是必须要掌握的所有的细节知识才行。只需要掌握其中必备的一些基础知识，就可以编写CANOpen的应用程序代码了。 那么本文将带你掌握其中部分基础知识，让你大脑中有CANOpen协议的这些概念知识（先有初步认识，以便于后面综合理解）。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、通信接口主要内容我这里按照CANOpen CiA 301协议文档，提取了通信接口的主要内容，我把它用思维导图方式列出来了，如下图： 初学者需要掌握通信接口后面的四项内容：网络管理(NMT)、服务数据对象 (SDO)、过程数据对象(PDO)、特殊协议； 这四项内容细分出来的知识点不多（相对来说），但对初学者来说，理解起来的难度较大。难点就在于：有许多抽象概念，且知识点关联性较强。 比如：什么是报文？ CAN-ID、COB-ID、Node-ID是什么思，各有什么区别？ COB-ID和对象字典索引有关联吗？ 三、CANopen轻松入门相信学习CANOpen的朋友都在网上看到过周立功的这么一本电子书：《CANopen 轻松入门》。 本来我是打算再造一次轮子，重新结合CANOpen CiA 301标准写一遍。但我之前有做计划，发现太费时了，而且做出来的效果也没有《CANopen轻松入门》这么好。我思前想后，还是觉得没有必要。 所以，本文主要目的在于引导初学者，网上下载《CANopen轻松入门》这本电子书来好好研究一下。关于通信接口主要内容，目录如下图： 《CANopen轻松入门》这本电子书是我站在初学者的角度考虑，觉得比较适合初学者，并不是为周立功打广告。当你把这本电子书里面内容都掌握了，我觉得你就已经入门了。 《CANopen轻松入门》网盘下载地址（百度、谷歌随处可见）：https://pan.baidu.com/s/15Or8ox3LgXKR6Z7ul7Zt1g 提取码：9ja0 四、CiA 301入门之后若要深入理解，我建议参看官网的《CANOpen CiA 301》标准这本文档。为什么是CiA 301标准呢？ 因为这些入门知识大部分都是CiA 301标准里面的内容。 CiA 301标准有多个版本，建议下载已经公开的V4.2.0版本： CiA技术文档下载地址（需要登录）：https://www.can-cia.org/standardization/specifications CiA 301网盘下载地址（含中、英文版本）：https://pan.baidu.com/s/1efnJAmB7tkSsMwIf39p8sg 提取码：x1m0 提示：CiA（CAN in Automation） 301也是大家所说的DS301，为CANopen 基础协议。 我们还常看到类似CiA 401 402这些协议，其实它们是在CiA 301 之上，对各个行业不断推出设备子协议。 所谓的子协议，就是针对不同行业的应用对象，对 CANopen 内部的数据含义进行重新定义，或者添加新的控制逻辑。 五、提取通信接口要点这里针对通信接口简单罗列一些基础知识，方便初学者理解。 5.1 网络管理(NMT)1.CANOpen网络一般是一个主站，多个从站的局域网络； 2.NMT节点具有6种状态：初始化、应用层复位、通讯复位、预操作状态、操作状态、停止状态。可以自己切换状态，也可主站切换状态； 3.任何一个 CANopen 从站上线后发出节点上线报文（boot-up）; 5.2 过程数据对象 PDO1.PDO用来传输实时数据，属于“生产消费”模型； 2.COB-ID 定义只是预定义，TPDO5、6、7这些也是可以存在。PDO 的COB-ID 与 Node-ID 无必然规则上的联系， 3.PDO 的两种传输方式：同步传输和异步传输； 4.PDO 的通信参数可通过对象字典工具配置； 5.PDO 的映射参数是一个相对难理解的参数，请结合《CANopen 轻松入门》图文（请关注颜色）理解； 5.3 服务数据对象 SDO1.SDO为请求应答方式； 2.发送方（客户端）、接收方（服务器） ； 3.通常从节点为 SDO 服务器，主节点为客户端； 4.两种协议：快速、普通 SDO 协议； 5.CS命令符含义需熟记（查表）； 5.4 特殊协议1.常见的就是罗列出来的3种：同步协议、时间戳协议、紧急报文协议； 2.特殊协议CAN-ID定义（查表）； 3.紧急报文错误代码分类及含义； 以上许多内容都有一张对应的表格，可以搜索一下“CANopen备忘录”，就有详细列出各自对应的内容。 六、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程07_CANOpen协议概述]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面 上一章节提供的例程是标准、数据帧格式的传输例程，结合前面理论知识，相信你根据参考例程可以实现远程帧及其他类型的数据传输。 前面教程讲述内容为CAN总线协议，属于底层硬件相关的一些内容。从本文开始，将正式讲述CANOpen协议。 CANOpen协议是基于CAN总线的上一层软件协议。该教程前面内容是建立底层通信，只有在底层通信成功基础上，才能实现上一层的通信协议。 提示：CANOpen协议内容很多，有许多内容都是一些抽象的概念。所以，有一些内容相对较难理解，随着慢慢深入即可消除那些疑虑。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CANopen协议总述CANopen 是一个基于 CAN 串行总线的网络传输系统的应用层协议，遵循 ISO/OSI 标准模型。 网络中不同的设备通过对象字典或者对象来相互交换数据，其中，主节点可以通过过程数据对象 (PDO) 或者服务数据对象 (SDO) 来获取或者修改其它节点对象字典列表中的数据。 CANOpen协议主要内容分为三大块，如下图CANopen 的设备模型。 CANOpen协议从大方向的划分，就如上图所示三大块。但是，这三大块里面的内容就牵涉到许多…… 初学者可以以上图模型为中心，再结合实际例程理解CANOpen协议的各种抽象概念。 下面章节将进一步讲述模型中三大块内容的一些概念，初学者能理解尽量理解，不能理解可以先做了解即可。 三、通信对象CANopen协议中常用的通信对象包含如下几点： 1） 网络管理对象(NMT)网络管理对象包括 Boot-up 消息， Heartbeat 协议及 NMT 消息，基于主从通信模式， NMT 用于管理和监控网络中的各个节点，主要实现三种功能：节点状态控制、错误控制和节点启动。 2） 服务数据对象 (SDO)·包括接收 SDO(R-SDO) 和发送 SDO(T-SDO)。·通过使用索引和子索引， SDO 使客户机能够访问设备对象字典中的项。·SDO 通过 CAL 中多元域的 CMS 对象来实现，允许传送任何长度的数据，当数据超过 4 个字节时分拆成几个报文。·协议是确认服务类型，为每个消息生成一个应答。 SDO 请求和应答报文总是包含 8 个字节。 3） 过程数据对象(PDO)·包括接收 PDO(RPDO) 和发送 PDO(TPDO)。·用来传输实时数据，数据从一个创建者传到一个或多个接收者。数据传送限制在 1 到 8 个字节。·每个 CANopen 设备包含 8 个缺省的 PDO 通道， 4 个发送 PDO 通道和 4 个接收 PDO 通道。·PDO 包含同步和异步两种传输方式，由该 PDO 对应的通信参数决定。·PDO 消息的内容是预定义的，由该 PDO 对应的映射参数决定。 4） 同步对象 (SYNC)同步对象是由 CANopen 主站周期性地广播到 CAN 总线的报文，用来实现基本的网络时钟信号，每个设备可以根据自己的配置，决定是否使用该事件来跟其它网络设备进行同步通信。 5） 紧急报文 (EMCY)设备内部通信故障或者应用故障错误时发送的报文。 四、对象字典对象字典是设备规范中最重要的部分。它是一组参数和变量的有序集合，包含了设备描述及设备网络状态的所有参数。 通过网络可以采用有序的预定义的方式来访问的一组对象。这里就牵涉到定义对象字典的生成问题，后面我会讲述关于对象字典生成工具相关内容。 CANopen 协议采用了带有 16 位索引和 8 位子索引的对象字典。你可以理解为一本汉语字典，我们需要查找里面的某个汉子（可以理解定义的某个数据），我们就会从拼音或笔画（索引）进去找到对应位置。 CANOpen 协议对象字典主索引如下图，这只是一个主要的索引。其实还能细分下去，这里不过多讲述，后续会进一步讲述。 五、应用应用这一块的内容包含应用程序、设备子协议实现。可以从CANopen 的设备模型明白，对外就是IO接口，也就是供我们调用的接口。 应用这一块包含CANOpen协议上层的内容，可以简单理解封装的一些供用户读写操作的函数。 应用这一块内容在后面结合实例分析会牵涉，初学者可以简单了解有这么一块，且知道这一块在CANOpen协议中大致的作用即可。 六、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 该教程前面讲述了许多关于CAN协议的一些概念，可能许多初学者看的云里雾里，那么本文将结合代码让大家理解之前讲述的内容。 因为关注我的人大部分都在学习STM32，我将结合STM32F103、标准外设库例程来让大家理解之前讲述的一些概念。 本文主要讲述内容： ·1.传输数据相关参数 ·2.位时序及传输波特率 为方便大家理解，我将在最后提供对应例程「CANOpen系列教程06_CAN底层收发例程」。当然，本文只讲述代码中部分内容，某些配置参数放在后面讲述。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、传输数据相关参数传输数据相关参数其实主要就是前面《CANOpen系列教程04》讲述的“帧类型及格式说明”那一章节内容，建议先看下那些概念内容。 CAN总线传输的内容主要就是发送和接收，下面我将结合代码中发送和接收参数来让大家理解我们编程控制CAN总线上那些参数。 2.1 CAN总线数据帧本文提供例程主要是CAN总线使用最多的数据帧为例，让大家理解数据帧传输由我们编程控制的参数。 先看下图回顾一下数据帧格式，其中有些字段内容由控制器自动完成，如：帧起始，CRC校验。而有些就是由我们编程控制，如：ID、数据等。 2.2 CAN发送代码A.CAN发送数据结构下图主要就是CAN发送由我们编程控制的参数。其实你会发现，主要就是上面帧格式中部分内容：ID、IDE、RTR、DLC、Data。 B.发送配置参数下图为实际发送配置的参数。 2.3 CAN接收代码CAN接收其实和发送类似，CAN总线上的字段就那些，在接收端接收的那些参数无非就是发送端发送出来的那些参数。针对STM32内部集成的CAN，接收数据结构多了一个FMI参数，大概意思就是接收消息邮箱筛选器索引。 接收操作为方便初学者理解，这里这要就是使用中断接收CAN总线数据，在中断函数里面打印也主要是用于测试，一般实际项目打印不会出现在中断函数（打印相对耗时）。 三、位时序及传输波特率同样，在前面《CANOpen系列教程04》中有讲述“位时序及传输波特率”的概念。其实，位时序间接决定了传输的波特率。换句话说，传输的波特率由位时序几个参数决定。 看下图，回顾一下波特率计算公式： 3.1 波特率配置代码结合上图计算公式和下图代码，可以看出位时序中几个参数和波特率的关系。波特率为1M时，几个位时序参数可以配置为如下图值： 提示：36M代表CAN时钟，具体要看时钟相关配置。 波特率固定，位时序参数可以不同。比如波特率固定为1M，位时序参数可以为上图配置；也可以修改其中的值，如修改位段1为CAN_BS1_5tq，位段2为CAN_BS2_3tq。只要遵循波特率计算公式即可。 四、例程下载CANOpen系列教程06_CAN底层收发例程：https://pan.baidu.com/s/1LzD0Epc-Z8vlHsb-sD3WVw提取码：l2dc 提示： 链接后期可能会失效，可关注公众号回复【CANOpen系列教程】查看更新链接。 五、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程05_CAN总线同步与位填充、优先级的决定]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A.html</url>
    <content type="text"><![CDATA[一、写在前面 继续为大家更新CAN总线协议相关内容，这些内容其实也比较重要，会直接影响到你后期CAN总线的编程，夸张一点的说会影响到你的软件架构。 本文内容相对来说比较容易理解，初学者有必要了解一下。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、位填充位填充是为防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据。 这个功能很好理解，如下图所示。位填充的数据不需要编程控制，由控制器自动完成。其目的也是提高CAN总线的稳定性。 (1) 发送单元的工作在发送数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，在下一个位（第 6 个位）则要插入 1 位与前 5 位反型的电平。 (2) 接收单元的工作在接收数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，需要删除下一个位（第 6 个位）再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送错误帧。 三、优先级的决定前面讲述“CAN 总线差分信号”时描述了显性和隐性，其实这是CAN总线的特点，也是决定CAN总线优先级比较重要的功能。 在CAN总线空闲态，最先开始发送消息的单元获得发送权。 多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。 上图描述了CAN控制仲裁的过程，单元2最终获得了抢占CAN总线的权利，也就是说单元2具有更高的优先级。 当单元1 仲裁失利时，自动转换为接收（本来该发送，优先级比别人低，就开始接收数据了。 同时，控制器将会在下一轮继续发送这次未完成的数据）。 3.1 数据帧和遥控帧的优先级具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。 数据帧和遥控帧的仲裁过程如下图： 3.2 标准格式和扩展格式的优先级标准格式 ID 与具有相同 ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR 位为显性位的具有优先权，可继续发送。 提示：不明白数据帧和遥控帧，标准格式和扩展格式之间差异的朋友，建议参看我上一篇文章《CANOpen系列教程04》。 四、其他CAN总线协议的重要内容在这前面基本是讲述的差不多了，还有一些不是很重要的内容，比如硬件设计需要在CAN_H和CAN_L之间添加一个120欧电阻，总线的传输距离等。 接下来的文章会结合STM32芯片集成CAN控制器、例程讲述如何编程控制CAN总线数据的收发等。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章讲述了CAN收发器的重要作用，也提及了一下CAN总线的优势主要在于CAN控制器。CAN控制器在CAN网络中所处的位置如下图： 本文讲述的CAN控制器实现的几个重要功能：CAN总线波特率、位时序、帧类型。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CAN总线波特率CAN总线属于异步通信，因此就有通信波特率，而这个波特率发生器就位于CAN控制器内部。我们不需要了解它是如何产生的，但需要了解它的含义。这章节针对初学者讲述以下两点内容。 2.1 异步通信在串行通信中，主要分异步通信和同步通信。 同步通信：通信设备之间通过同步信号（CLK时钟）来实现数据传输的通信叫同步通信。如I2C、SPI这类通信中都具有一个时钟信号，其实在STM32中USART也具有同步功能，只是我们大多数人都只用了它的异步功能。 异步通信：简单来说，就是通信设备之间通过约定一样的时间来收发数据。而这个时间就会决定本节说的波特率。 2.2 波特率很多工程师一直都没彻底搞明白什么是波特率，我这里还是结合UART波特率来简述一下其含义。 在电子通信领域，波特（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号。 UART每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。 从上面的描述可以总结：比特率：即单位时间内传送的二进制位数； 波特率：即单位时间内传输的符号个数； 只有在每个符号只代表一个比特信息的情况下，波特率与比特率才在数值上相等，但是它们的意义并不相同。 三、位时序上一章节讲述了波特率，而决定波特率大小的就是本节说的位时序。在CAN标准中一个位可分为4段：·同步段（SS）·传播时间段（PTS）·相位缓冲段1（PBS1）·相位缓冲段2（PBS2） 这些段又由可称为 Time Quantum（简称Tq）的最小时间单位构成。 1位分为4个段，每个段又由若干个Tq构成，这称为位时序。 而在STM32参考手册中，将位时序分为三段，但它将它传播段和位段1合并在一起了，如下图： 1位由多少个Tq构成、每个段又由多少个Tq构成等，可任意设定位时序。通过设定位时序，决定传输的波特率： 这几个参数会在以后编程中进行配置，从而决定通信的波特率。 关于同步，还有硬件同步、再同步等操作。但初学者可以不必过多理解，掌握上面基础内容就行了。更多关于位时序的内容可以参看 ISO 11898 标准。 四、帧类型及格式说明CAN总线是通过以下5种类型的帧进行通信：数据帧：用于发送单元向接收单元传送数据的帧。遥控帧：用于接收单元向具有相同 ID 的发送单元请求数据的帧。错误帧：用于当检测出错误时向其它单元通知错误的帧。过载帧：用于接收单元通知其尚未做好接收准备的帧。帧间隔：用于将数据帧及遥控帧与前面的帧分离开来的帧。 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。 4.1 数据帧 如上图，数据帧由7个段构成：(1) 帧起始表示数据帧开始的段。(2) 仲裁段表示该帧优先级的段。(3) 控制段表示数据的字节数及保留位的段。(4) 数据段数据的内容，可发送 0～8 个字节的数据。(5) CRC 段检查帧的传输错误的段。(6) ACK 段表示确认正常接收的段。(7) 帧结束表示数据帧结束的段。 理解数据帧的含义，请从认真理解它的定义：用于发送单元向接收单元传送数据的帧。 一般的CAN总线通信，总线上通信绝大部分时候都是数据帧。像在CANOpen协议中，用的最多的PDO过程数据对象就是通过数据帧进行的通信。 初学者可以先理解数据帧，然后其他就容易理解了。下面再来讲述一下数据帧7段的详情。 4.1.1 帧起始标准和扩展格式相同。表示帧开始的段，1个位的显性位（如下图）： 关于显性和隐性电平，请参看我上一篇文章差分信号章节。 总线上的电平有显性电平和隐性电平两种。总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。 “显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平。并且，“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强） 4.1.2 仲裁段标准格式和扩展格式在此的构成有所不同。仲裁段表示该帧优先级的段，扩展格式多了18位ID（如下图）： RTR = 0代表数据帧，RTR = 1代表远程帧。 为什么叫仲裁段，就是通过ID来判断总线上哪一个节点具有优先发送的权利。ID越小（0代表显性），优先级越高。 4.1.3 控制段标准和扩展格式的构成有所不同。控制段由 6 个位构成（如下图）： 它们除了都有4位表示数据段长度代码（DLC）外，标准帧有IDE（数值为0）位和r0保留位，扩展帧有r0和r1保留位。 保留位必须全部以显性电平发送。但接收方可以接收显性、隐性及其任意组合的电平。 4.1.4 数据段标准和扩展格式相同。数据段表示传输数据的内容，从 MSB（最高位）开始输出，可发送 0～8 个字节的数据，长度由前面控制段决定。 4.1.5 CRC段标准和扩展格式相同。CRC段是检查帧传输错误的帧，由 15 个位的 CRC 顺序和 1 个位的 CRC 界定符（用于分隔的位）构成。 相比485这类通信，CAN控制器就已经把CRC校验做了，不需要你的程序再次去计算，从而节约了处理器资源。 4.1.6 ACK段标准和扩展格式相同。ACK段用来确认是否正常接收。由 ACK 槽(ACK Slot)和 ACK 界定符 2 个位构成。 A.发送单元在 ACK 段发送 2 个位的隐性位。B.接收到正确消息的单元在 ACK 槽(ACK Slot)发送显性位， 通知发送单元正常接收结束。这称作“发送 ACK”或者“返回 ACK”。 4.1.7 帧结束标准和扩展格式相同。帧结束是表示该该帧的结束的段。由 7 个位的隐性位构成。 4.2 遥控帧 和数据帧相比，遥控帧是接收单元向发送单元请求发送数据所用的帧。所以，遥控帧没有数据段。因此，遥控帧由如下 6 个段组成：(1) 帧起始（SOF）表示帧开始的段。(2) 仲裁段表示该帧优先级的段。可请求具有相同 ID 的数据帧。(3) 控制段表示数据的字节数及保留位的段。(4) CRC 段检查帧的传输错误的段。(5) ACK 段表示确认正常接收的段。(6) 帧结束表示遥控帧结束的段。 这6个段和上面数据帧的内容基本一样，这里就不一一讲述了。讲一下遥控帧和数据帧的区别：遥控帧的 RTR 位为隐性位，没有数据段。没有数据段的数据帧和遥控帧可通过 RTR 位区别开来。 问题一：遥控帧没有数据段，数据长度码该如何表示？遥控帧的数据长度码以所请求数据帧的数据长度码表示。 问题二：没有数据段的数据帧有何用途？例如，可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。 4.3 错误帧 用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。 (1) 错误标志错误标志包括主动错误标志和被动错误标志两种。主动错误标志： 6 个位的显性位。被动错误标志： 6 个位的隐性位。 (2) 错误界定符错误界定符由 8 个位的隐性位构成。 4.4 过载帧 过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。(1) 过载标志6 个位的显性位。过载标志的构成与主动错误标志的构成相同。 (2) 过载界定符8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。 4.5 帧间隔 帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。 过载帧和错误帧前不能插入帧间隔。 (1) 间隔3 个位的隐性位。 (2) 总线空闲隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。 (3) 延迟传送（发送暂时停止）8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程03_CAN收发器功能、原理及作用]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8.html</url>
    <content type="text"><![CDATA[一、写在前面 前面文章是从大方向介绍了CAN网络，让大家对CAN网络有一定的认识。本文将范围缩小，讲述整个CAN网络其中的一个CAN收发器。如下图标记出来的部分： 本文结合众多初学者容易产生的疑问来讲述CAN收发器相关的知识点，大概有如下几点： ·什么是CAN收发器？ ·CAN总线差分信号 ·CAN收发器芯片和485芯片差异 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、什么是CAN收发器？CAN收发器在整个CAN网络中所处的位置如上图所示。CAN收发器就是一块类似232或485的转换芯片，它的主要功能是将CAN控制器的TTL信号转换成CAN总线的差分信号。 2.1 什么CAN控制器TTL信号？现在的CAN控制器一般都与MCU集成在一起，其发送和接收TTL信号就是MCU引脚（高或低）信号。 以前还有独立的CAN控制器，一个CAN网络节点会包含三块芯片：MCU芯片、CAN控制器、CAN收发器。现在是将前两者集成在一起了（看文章开篇图片）。 三、CAN总线差分信号CAN总线信号从CAN收发器出来，为「两线」「差分」信号，用隐形代表逻辑1，显性代表逻辑0。 1.CAN收发器两线芯片引脚CAN_H、CAN_L 2.CAN_H和CAN_L电压电压的大小根据芯片型号而定，一般常见的CAN收发芯片有3.3V和5V两种芯片。 如上图，为5V CAN收发芯片，在逻辑0和逻辑1时电压情况：逻辑0时：显性，CAN_H=3.5V，CAN_L=1.5V；逻辑1时：隐性，CAN_H=2.5V，CAN_L=2.5V； 当然，3.3V电压芯片的总线电压原理类似。而实际应用中，总线电压并非绝对的像上面说的3.5V、2.5V、1.5V这种电压，会受到导线电阻、外界干扰等影响。 3.隐性和显性学过生物都知道，基因有隐性和显性，隐性的基因实际存在，但不会表现出来。有显性的基因就会变现出来。这里CAN总线隐性信号和显性信号道理一样，当总线两者信号都有时，总线表现出来的就是显性信号。 提示：我们这里说的显性和隐性信号，指的是总线传输的bit位信号。 所以，CAN总线平时空闲表现为隐性状态。如果想要发送的信号为隐性位，那么总线才会呈现出来隐性。否则，只要其它有一个节点发送显性信号，你这个节点发送出来的隐性信号就无效。 4.CAN收发器R引脚CAN收发器R引脚就是与CAN控制器接收相连的引脚。如下图： R引脚的信号是表示总线当前的信号，用于控制器实时监测总线信号。主要两个目的：A.监测其它节点发送出来的信号：别人给它发送数据；B.监测自身节点发送出去的信号：自己发送是否失败。就像上面说的，自己发送一个隐形信号，结果监测出来是显性信号，那就说明是别人在发送数据。 四、CAN收发器芯片和485芯片差异CAN通信和485通信一样，属于半双工。但是，为什么CAN总线相比485通信不管在速度和稳定性上都具有明显优势呢？ 4.1 总线利用率CAN收发器工作原理与485具有较大差异。从上面的差分信号可以看得出来，两种芯片同时存在，只有显性信号有效，而不会影响总线传输。简单来说就是CAN总线具有自动仲裁功能，这样就提高了总线的利用率。 RS485总线是一种常规的通信总线，它不能够做总线的自动仲裁，也就是不能够同时发送数据以避免总线竞争，所以整个系统的通信效率必然较低，数据冗余量较大，对于速度要求高的应用场所不适应用RS485总线。 提示：CAN总线没有被发送出去的隐性信号，会由CAN控制器后续发送出去。这里牵涉到CAN总线优先级的问题，后续进一步讲述。当然，CAN相比485具有明显优势，主要原因还是在于CAN控制器。 4.2 可以不使用CAN收发器吗？UART可以直接通过TX连接对方的RX引脚，利用TTL信号进行通信，那么CAN也可以吗？ 答案：单向传输可以，双向传输就不行。原因很简单，上面说了，CAN控制器会实时监测发送出去的信号是否正确。也就是说TX要与RX信号一致才行，否则CAN控制器认为你发送失败。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程02_理解CAN总线协议]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章讲述了CAN和CANOpen，相信大家CAN和CANOpen有一定理解了。本文说的CAN即是一种总线，也是一种协议。因此，我们常听见CAN总线，也常听见CAN协议。 CAN协议和CANOpen协议是两套不同的协议。从软硬件层次来划分，CAN协议属于硬件协议，而CANOpen属于软件协议。 本篇文章先概述一下CAN网络，让大家对CAN总线协议有一个全局的概念，再到底层的CAN总线协议知识。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CAN网络CAN网络可以理解为多台CAN设备连接在同一条CAN总线上组合成的网络，其中的CAN设备我们称之为节点。CAN网络拓扑结构如下图： 如上图，一个CAN节点主要包含三类：MCU应用程序、CAN控制器、CAN收发器。 2.1 MCU应用程序MCU应用程序我将其分为三块：业务逻辑代码、协议层代码、底层驱动代码。 A.业务逻辑代码：是根据项目需求而定，也很好理解。比如我读取一个传感器数据，并对其做出相应逻辑处理。 B.协议层代码：比如后续要讲述的CANOpen。 C.底层驱动代码：配置CAN总线相应参数、控制收发的代码。 2.2 CAN控制器CAN控制器内部结构还是挺复杂的，一般现在CAN控制器都是与处理器集成在一起。 其实对于编程的人来说，无非也就是包含一些控制、状态、配置等寄存器。 比如我们看到有些STM32芯片带有CAN，也就是说CAN控制器已经集成在STM32芯片中了，我们只需要编程操作其中的寄存器即可。 2.3 CAN收发器CAN收发器：将CAN收发引脚（CAN_TX和CAN_RX）的TTL信号转换成CAN总线的电平信号。 PS：你可以把CAN总线通信认为是UART通过485进行通信：CAN控制器就如UART的控制器，而CAN收发器就如485转换芯片。 三、ISO标准化的CAN协议写这一章节的主要目的就是想让大家了解CAN总线位于OSI所在层次。 3.1 ISO/OSI基本参照模型 【注】ISO：International Standardization Organization国际标准化组织；OSI：Open Systems Interconnection开放式系统间互联； 3.2 CAN在OSI模型中的定义 【注】LLC：Logical Link Control逻辑链路控制；MAC：Medium Access Control媒介访问控制； 从上图可以知道CAN总线底层硬件的内容（CAN控制器、收发器）主要位于OSI的第1层和第2层。 四、概述CAN总线协议CAN总线协议：就是为了保证通信（收发）数据在CAN总线上能稳定传输而制订的一套协议。 CAN总线协议的内容很多，为方便初学者理解，本文先大概描述一下CAN总线协议，后续文章详细讲述CAN总线协议的内容。 4.1 总线信号CAN总线为「两线」「差分」信号，用隐形代表逻辑1，显性代表逻辑0。如下图： 4.2 优先级假如某一时刻，一个设备（节点）往总线发0，一个设备往总线发1。那么总线会呈现什么现象？ 答案：最后总线呈现为显性，也就是0。 4.3 位时序位时序逻辑将监视串行总线，执行采样并调整采样点，在调整采样点时，需要在起始位边沿进行同步并后续的边沿进行再同步。 简单的说就是对一个bit位分几段进行采样，目的就是提高数据传输稳定性。在STM32中底层驱动代码就需要进行位时序编程，在STM32参考手册中也会发现如下位时序图： 4.4 帧的种类和格式帧的种类有多种：数据帧：用于发送单元向接收单元传送数据的帧。遥控帧：用于接收单元向具有相同 ID 的发送单元请求数据的帧。错误帧：用于当检测出错误时向其它单元通知错误的帧。过载帧：用于接收单元通知其尚未做好接收准备的帧。帧间隔：用于将数据帧及遥控帧与前面的帧分离开来的帧。 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。 4.5 位填充位填充是为防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据。如下图： 4.6 错误的种类 CAN总线协议内容很多，初学者先了解这些，后面文章具体到每一个点上，相信大家就会更明白其中的含义。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程01_初识CAN与CANOpen及相关内容]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_%E5%88%9D%E8%AF%86CAN%E4%B8%8ECANOpen%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[一、写在前面 我之前学习CANOpen的时候，网上有用的资料极少，走了不少弯路。到目前为止，网上关于CANOpen的资料依然很少。所以，特地写下该系列教程，帮助初学者跨过这道坎。 从我个人学习CANOpen的经历来看，学会使用CANOpen难度其实不大。难点在于需要掌握的基础知识很多，而且许多都有关联性，容易把人绕晕。 那么，我希望通过结合之前我的学习经历，以及工作经验，站在小白的角度写下该系列教程。当然，该教程由我个人编辑并整理，难免有些废话，或者错误，还请谅解。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、初识CAN与CANOpen2.1 什么是CAN?CAN：是Controller Area Network的缩写，即控制器局域网络，属于工业现场总线，是ISO国际标准化的串行通信协议。 从OSI（Open System Interconnection开放系统互联）7层网络模型的角度来看，CAN现场总线仅仅定义了第 1 层（物理层）和第 2 层（数据链路层）。 而在实际设计中，这两层完全由硬件实现，设计人员无需再为此开发相关软件或固件（Firmware），只要了解如何调用相关的接口和寄存器，即可完成对CAN的控制。 上面介绍的内容可能太官方，初学者可能看了之后还是不明白。简单的说：CAN总线就是一层硬件协议。比如：差分信号电平的定义、数据帧的定义等等。 PS：初学者可以结合UART来理解，比如UART串口发送一个字符’A’，它就是一种串行通信的方式。 2.2 什么是CANOpen?CANopen是一种架构在CAN控制局域网上的高层软件通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线协议。 CANopen协议是在20世纪90年代末，由总部位于德国纽伦堡的 CiA 组织——CAN-in-Automation，在 CAL（CAN Application Layer）的基础上发展而来。 所以，关于CANOpen协议内容请参看：http://www.can-cia.org 由于CAN总线只定义了OSI中的物理层和数据链路层，因此对于不同的应用出现了不同的【应用层协议】，为了使不同厂商的产品能够相互兼容，世界范围内需要通用的CAN应用层通信协议。 在过去的二三十年中涌现出许多的协议，不过到现在为止能够广泛被承认的协议却不多，现在应用较广的CAN应用层协议主要有以下三种：CANopen协议：主要应用在汽车、工业控制、自动化仪表等领域，目前由 CIA 负责管理和维护； J1939协议：CAN总线在商用车领域占有绝大部分市场份额的应用层协议，由美国机动车工程师学会发起，现已在全球范围内得到广泛的应用； DeviceNet协议：在美国等地占有相当大的市场份额，主要用于工业通信及控制和仪器仪表等领域。 而本文说的CANOpen也是目前应用较广的一种协议。简单的说，CANOpen就是CAN总线应用层协议。 PS：学习CANOpen应用层协议之前请务必先了解CAN总线协议。 三、CAN总线特点CAN总线采用差分信号传输，通常情况下只需要两根信号线（CAN-H和CAN-L）就可以进行正常的通信。在干扰比较强的场合，还需要用到屏蔽地即CAN-G（主要功能是屏蔽干扰信号）， CAN协议推荐用户使用屏蔽双绞线作为CAN总线的传输线。 CAN总线通信的优势和特点：A.CAN总线上任意节点，均可在任意时刻主动的向其它节点发起通信，但在同一时刻优先级高的节点能获得总线的使用权。 B.标准CAN总线传输波特率可达到1Mbps。在5Kbps的通信波特率下最远传输距离可以达到 10Km，即使在1Mbps的波特率下也能传输40m的距离。 C.CAN总线定义使用了硬件报文滤波，可实现点对点及点对多点的通信方式，不需要软件来控制。 D.CAN总线所挂接的节点数量主要取决于CAN总线收发器或驱动器，目前的驱动器一般都可以使同一网络容量达到110个节点。 E.CAN总线通信介质可采用双绞线、同轴电缆或光纤，选择极为灵活。可大大节约组网成本。 当然，CAN总线的优势还有许多，当你掌握之后就会明白为什么CAN总线应用得如此广泛了。 四、教程规划CAN总线及CANOpen协议相关的内容相对比较多，如果每一个细节知识点都写出来，可能花掉我业余时间写一年也写不完。 我写该教程目的在于引导初学者入门，我会结合实例代码让大家边学边理解，至于实际项目编程应用不一定讲述的很多（这个看后面情况）。 首先从CAN底层讲起，再到CANOpen协议相关基础知识，最后实际应用。当然，中间每一个环节内容相对可能较多，也有可能会遗漏部分内容。 五、说明1.该文档部分文字来自周立功的相关教程，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【MAVLink学习之路】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、教程列表1.MAVLink学习之路01_认识MAVLink 2.MAVLink学习之路02_工具下载、环境搭建 3.MAVLink学习之路03_XML中定义MSG并生成C代码 4.MAVLink学习之路04_MAVLink移植到STM32具体步骤 5.MAVLink学习之路05_MAVLink应用编程接口分析 正在努力更新中，敬请等待…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路05_MAVLink应用编程接口分析]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[一、写在前面 前面写的几篇文章你掌握了，说明你离成功很近了。那么本文就带你真正进入编程的世界，让你进一步掌握MAVLink应用编程的重要知识点。 本文主要内容： ·MAVLink应用编程主要内容 ·MAVLink函数接口详细说明 提示：本文结合上一篇文章提供给大家下载的“MAVLink发送接收例程”进行讲解，请结合例程理解本文。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、MAVLink应用编程主要内容2.1 发送和接收说明利用MAVLink通信协议进行编程，主要实现的功能就是： 1.发送端将需要发送的数据（如：SysState, BatVol），添加MAVLink通信协议，通过硬件（如：UART、CAN）发送出去。 2.接收端硬件（如：UART、CAN）接收到的数据，通过MAVLink协议解析，得到一帧完整的MAVLink数据包，提取发送端发送的数据（如：SysState, BatVol），将得到的数据应用到我们程序中。 主要流程：数据 -&gt; MAVLink封装 -&gt; 发送 -&gt; 接收 -&gt; MAVLink解析 -&gt;数据 2.2 发送和接收流程图 该流程图是结合我上一篇文章提供的源代码例程画出来，包含的只是主要内容，更多细节没有在流程图中呈现。 提示：我提供例程是针对初学者提供比较单一发送和接收例程（MDK-ARM和EWARM包含各自的发送和接收工程）。 而实际项目可能会：1.发送和接收在一个工程；2.包含操作系统；3.发送、接收数据FIFO（队列）处理； 所以，实际项目，请按需修改我提供的源码。 三、MAVLink函数接口详细说明这一章节讲述发送和接收主要用到的函数接口，请参考我提供的源代码例程理解。为方便初学者理解，我将其分为发送和接收两个部分来讲述。 3.1 发送主要函数接口 上面是我提供例程的代码，主要讲4个接口。 1.MAVLink_SendTest这个接口是根据自己情况进行封装函数，用于应用程序调用，这里不多说。 2.mavlink_msg_sys_info_pack这个函数接口主要目的：将变量信息（SysID、CompID、SysState、BatVol）打包，最终得到MAVLink_Msg这个消息包。 3.mavlink_msg_to_send_buffer将上一步得到的MAVLink_Msg转换成我们要发送的数据BUF缓存。 4.MAV_USART_SendNByte这个函数接口也是我自己根据硬件（UART）封装的，如果你是其它硬件通信，只需要封装一个类似的接口（参数具有BUF，LEN）即可。 发送数据的流程：从应用代码 -&gt; 底层硬件（发送出去）。 如果要深入了解，可以先熟悉软件流程，再结合源代码工程，同时参看接口函数具体实现。相信你很快就明白了。 3.2 接收主要函数接口 上面是我提供例程的代码（方便截图，去掉了部分），主要讲以上4点内容。 1.MAV_USART_GetByte该函数接口也是硬件底层通信接口，请根据自己情况修改，只需要传递数据（流）进来即可。 2.mavlink_parse_charMAVLink解析是按照一个一个字符进行解析，我们接收到一个字符，就对其进行解析，直到解析完（根据返回标志判断）一帧数据为止。 3.if(MAVLINK_MSG_ID_SYS_INFO == MAVLinkMsg.msgid)这里就是对解析好的一包完整消息进行分类判断吧。其实，我是想说，这个地方还有两个ID需要进行判断，SysID系统ID和CompID部件ID。 我提供例程为方便初学者快速理解，未提供SysID和CompID判断，在后续应用编程中会用到。 4.mavlink_msg_sys_info_get_voltage_battery通过该接口获取消息变量，看图中说明文字，前面是消息，后面是消息变量。 接收数据的流程：从应用代码 -&gt; 底层硬件（发送出去）。 以上就是发送和接收的主要函数接口，如果你只是简单的进行通信，这几个接口就够你使用了。当然，更高级的编程应用还需要你进一步掌握其中的内容。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路04_MAVLink移植到STM32具体步骤]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.html</url>
    <content type="text"><![CDATA[一、写在前面 《MAVLink学习之路》前面三篇文章，可以说是一些基础知识，也是为本文做的准备工作（建议初学者先了解前面三篇文章）。 本文主要内容： ·MAVLink移植主要步骤 ·MAVLink移植过程要点 提示：为方便广大初学者朋友尽快掌握MAVLink，我在文末提供MAVLink发送接收例程（基于STM32硬件、MDK-ARM和EWARM开发环境）。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、MAVLink移植主要步骤2.1 移植说明 本文主要针对MAVLink C源代码移植进行讲述。其中，MAVLink的C源代码可以下载网上预生成的C源代码库，也可以通过生成器工具生成。 A.下载预生成C代码库 如果是使用标准MAVLink的MSG消息，则可以现在官方指定地址预先生成的C代码库。预先生成C代码库总共两个版本：MAVLink V1版：https://github.com/mavlink/c_library_v1MAVLink V2版：https://github.com/mavlink/c_library_v1 B.生成器生成C代码 如果你需要自定义MSG消息，则需要自己通过工具生成C代码，具体生成方法请参看文章：《MAVLink学习之路03_XML中定义MSG并生成C代码.》 提示： 官方预生成C代码库就是通过生成器而生成的，官方提供的生成器工具、预生成C代码库不定期更新。也就是说可能你不同时期看到的预生成库不同，不同时期的生成器及其生成的代码也有所不同。 如上图，官方预生成的C代码（V1版），与通过生成器生成的代码完全一样。如common.xml通过生成器生成的C代码就和上面紫红色框出来的代码一样。当然，生成器版本也是这最新的才对。 2.2 移植主要步骤1.下载相关工具2.环境搭建3.生成C代码（如果下载官方预生成代码，前面两步可以不用）4.将C代码添加到工程5.配置（如添加MAVLink路径、修改代码适配工程）6.添加MAVLink发送接收（及应用）代码 步骤1， 2， 3已经在前面文章详细讲述了，本文主要讲述步骤4， 5。步骤6下一篇文章详细讲述。 三、MAVLink移植过程要点本节主要内容讲述将C代码添加到工程，然后配置，到编译没有错误这一过程中的一些重要知识点。 3.1 代码添加到工程代码添加到工程其实很简单，将代码拷贝工程文件下，类似如下图，添加组，添加源文件。 但是，MAVLink源代码都是.h头文件，可以不用像上面那样添加到工程。当然，添加头文件到工程的好处就是可以快速打开头文件，查找相关代码。 说这一小节是想提示大家：MAVLink的C源代码都是.h头文件。头文件只需要添加对应路径，包含头文件即可（#include “mavlink.h”）。 3.2 配置1.添加路径Keil MDK-ARM和IAR EWARM添加路径这项内容我就不在这里详细讲述了，不会的朋友可以参看看我的文章：Keil MDK-ARM系列教程（一）_新建软件工程详细过程IAR EWARM系列教程（一）_新建软件工程详细过程 3.3 修改代码这小节内容可以参看网上一篇博文：https://www.cnblogs.com/lovechen/p/5809709.html那篇文章讲述的很多，我讲一下重点：它修改的代码是针对老版本主要需要修改两个地方。而且新版本MAVLink生成器已经优化了一个项，也就是只有一个地方需要修改：修改mavlink_types.h. 1.针对Keil MDK-ARM 2.针对IAR EWARM 12添加预定义：#pragma anon_unions替换代码：#define MAVPACKED( __Declaration__ ) __Declaration__ 那篇文章针对的是老版MAVLink还需要修改一个const的地方，我这里就不说了（新来的建议用新版的）。 为什么这里要修改呢？原因在于编译器的差异导致的。 3.4 补充知识点1.#pragma anon_unionskeil中默认是不支持匿名结构体的，需要编译指令#pragma anon_unions指名。 2.MAVPACKED如果不修改代码，直接编译，发现有许多错误，原因都来自MAVPACKED。结合修改的内容，再看下图，有什么启发没有。 四、源代码下载地址：https://pan.baidu.com/s/1xraErAnmL-BN9CMwE6aQ密码：cusq 提示：包含四个工程：Keil、IAR各自的发送和接收工程。如果链接失效，请到公众号回复【MAVLink学习之路】查看更新链接。 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路03_XML中定义MSG并生成C代码]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[一、写在前面 如果你前面两篇文章掌握了，说明你已经入门了。本文带你掌握如何在XML文件中定义Message（MSG消息）并生成C代码。 本文主要内容： ·如何在XML文件中定义Message（消息） ·如何通过生成器工具生成MAVLink C代码 提示：本文将结合上一篇文章提供下载的“MAVlink代码生成工具包”来讲述。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、XML文件中定义MSG2.1 关于MSGMAVLink的MSG消息定义在XML文件中，通过生成器工具（Mavenerate或Mavgen）生成MAVLink C代码； 在MAVLink协议中，每一条MSG消息都具有一个ID，且ID具有唯一性。MSG消息ID其实就是对应协议格式中msgid，如下图： 简单来说：在xml中定义一条Message消息，通过生成器工具就能生成该Message对应的C代码（一条Message也可以理解成一条通信命令）。 提示：在MAVLink V1版本中，消息ID有效数字的范围为0到255。 其中0到149为公共消息ID（飞控系统共有消息，一般不建议用于自定义）。而150到240为用于自定义消息的ID范围。 比如，打开前面下载的工具包消息定义的文件夹（如下图），可以看到：common.xml文件主要是一些公共消息ID范围为：0到149。而其它xml文件是针对不同系统定义的消息，主要集中在150到240之间。 2.2 MSG的定义方法 MAVLink的MSG消息定义在XML文件中，所以遵循XML语法规则。语法很简单（只需要记住部分常用的就行），我们可以参考MAVLink定义好的xml文件。 解压上一篇文章下载“MAVlink代码生成工具包”，打开（路径MAVLink \ message_definitions \ v1.0下）common.xml文件，我们以“心跳”为例： 从上图可以看出：“心跳”消息包含：消息ID、描述（注释）以及各项参数（可以理解为一个函数，及函数的参数）。 1.《message》《/message》标签每条消息都被定义在这样一个消息标签内。 2.id=“0”表示此消息的id或index编号为0。 3.name=“HEARTBEAT”该ID编号对应的名称。 4.《description》《/description》对该消息的描述，是一个非常重要，但可选的领域（意思是可以不用定义），可以理解为代码的注释。 5.《field》《/field》对消息的一个字段进行定义，它类似于C语言中的一个变量，可以是8,16,32和64位长度（有符号或无符号），以及浮点类型等。 6.type=“uint8_t”将此字段定义为8位无符号整数。数组的定义如下：type=“uint8_t[5]”。可以理解为一个函数参数的数据类型。 7.name = “type” 该字段的名称，可以理解为一个函数参数的名称。 8.Type of the MAV字段说明，可以理解为函数参数的注释。 上面文字描述可能理解起来比较困难，看下图心跳消息对应生成的C代码： 以上举例，只是提供其中一个函数接口，其实还会生成更多与该消息相关的接口、结构体等。 2.3 enum的定义方法上面2.2节在xml中定义消息明白了，这节enum（枚举）的定义就很容易理解了，原理一样。 枚举和消息只是内容有所差异，定义原理都类似。枚举包含：枚举名称，成员（元素）名称，成员值等。 枚举的定义就不详细描述出来，提供枚举xml定义和生成C代码，相信你一看就能明白。 xml中定义的MAV_AUTOPILOT： 生成的C代码： 提示：关于消息定义，更多的内容可以参看：http://qgroundcontrol.org/mavlink/create_new_mavlink_message 三、通过生成器工具生成MAVLink C代码上面第二章节在xml文件中定义好了MSG消息和enum枚举，那么，就需要通过生成器工具生成我们最终需要的代码（我主要讲述生成C代码）。 MAVLink项目提供有生成器有两种：Mavgenerate（GUI）和Mavgen（命令行）； 使用生成器工具前提需要搭建好环境，请参考：MAVLink学习之路02_工具下载、环境搭建 3.1 Mavgenerate生成C代码这个工具使用方法很简单，环境搭建好之后，解压下载工具包，在当前路径下输入命令“python mavgenerate.py”，或者双击mavgenerate.py即可打开： 3.2 Mavgen生成C代码 Mavgen生成器是一个通过命令实现的工具，命令很简单，比如：python -m pymavlink.tools.mavgen –lang=C –wire-protocol=1.0 –output=generated/include/mavlink/v1.0 message_definitions/v1.0/common.xml 命令的具体描述请看下图： 3.3 关于生成器几点提示1.Mavgen支持的语言及版本 2.路径因为命令行生成器支持相对路径，建议将xml文件拷贝到如下路径：MAVLink\message_definitions\v1.0 3.命令语法和选项说明 初学者不用深入理解，只需要知道如何生成C代码即可（参考我上面提供的哪一条命令）。 关于生成器工具更多的内容可以参考：https://mavlink.io/en/getting_started/generate_libraries.html 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路02_工具下载、环境搭建]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、写在前面初学者学习本文之前，建议参看我的上一篇文章：《MAVLink学习之路01_认识MAVLink》 本文主要两个内容： ·下载相应安装包及工具 ·环境搭建 其中环境搭建是很多初学朋友从入门到放弃的一个重要阶段。环境搭建难度不大，解决问题重要的一点：针对问题找解决办法。不要看到问题就撤退，否则，只有一个结果：就是放弃。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、下载2.1 下载说明1.git工具建议提前git工具，方便下载、环境搭建、启动GUI等。（当然，不使用git也行，下载压缩包，使用Windows自带命令行） 2.系统MAVLink开发环境可以搭建在Windoes和Linux系统，本教程只讲述基于Windows搭建环境以及后期的开发。（基于Linux系统的环境搭建可以自己研究一下） 3.下载内容第一类：MAVlink环境搭建工具包 ·Python ·Future 第二类：MAVlink代码生成工具包 ·MAVLink（含pymavlink） 我把它分为以上两类（当然，这是我自己的分类方式，可能不完全正确），主要就是下载Python、Future、MAVLink、pymavlink四项内容。 下载的方式： ·官网（推荐） ·百度网盘（可能会失效） 2.2 环境搭建安装包下载2.2.1 PythonPython版本分Python2和Python3。官方推荐安装：Python 2.7+ or 3.3+. 因为许多使用Python支持的工具对Python 2具有更好的兼容性（比如我接下来要讲述的CANOpen文章，生成对象字典同样需要Python 2的支持），我一般推荐使用Python 2.7。 官网下载地址：https://www.python.org/downloads 百度网盘：https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA密码: q8ic （目前2018年8月最新Python 2.7.15，网盘后期地址可能会失效，建议到官网下载最新版本） 2.2.2 Futurefuture可以下载安装文件进行离线安装，也可以输入命令在线安装。（下章节讲述安装） 官网下载地址：https://pypi.org/project/future/#files 百度网盘：https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA密码: q8ic 2.3 MAVlink代码生成工具包MAVlink代码生成工具包，环境搭建完成之后，用于代码生成的一项工具包（后面文章讲述代码生成会用到这工具包）。 官网下载地址：https://github.com/mavlink/mavlink 建议使用Git工具下载（当然，也可以直接下载压缩包）。 百度网盘：https://pan.baidu.com/s/1dIzR3YzYsyecBGZgReSpYg密码: t9pi 三、环境搭建3.1 环境搭建说明环境搭建也就是安装相关软件，主要是安装Python和Future这两个软件。 安装这两个软件很容易，难点在于有些细节问题，下面我会针对常见问题提出来（当然，因系统或配置等各种原因，所体现出来的问题也有所不同）。 3.2 安装Python1.直接双击Python安装，会出现类似如下图错误 所以，不建议直接双击Python安装包进行安装，按照下面方式：以管理员方式运行安装。 2.以管理员是身份运行cmd Win -&gt; 输入cmd -&gt; 选中“命令提示符”右键 -&gt; 以管理员身份运行 3.安装 路径 + 安装文件（含后缀）：D:\Desktop\python-2.7.15.msi（根据自己路径修改） 安装的很多步骤按照提示操作即可（一般点击next即可），重要的内容下面我提示一下。 4.添加路径 这一步添加路径的作用就是添加系统环境变量（也是很多朋友失败的原因）。不选择的话，就需要安装好之后自己在环境变量中添加路径。 安装Python主要注意以上两点即可。 5.检验是否安装成功A.查看系统环境变量，是否具有python路径。B.CMD输入python，验证是否安装成功，如下图： 3.3 安装Future安装future有两种方法：1.输入命令在线安装； 2.下载安装文件，离线安装。（这里可以使用windows自带命令行，也可以使用git命令行） 1.在线安装输入命令：pip install future （推荐使用该方法） 2.离线安装前提是下载好安装包，进入安装包路径，输入安装命令：python setup.py install 四、验证环境变量验证环境变量是否安装成功：下载“MAVlink代码生成工具包” -&gt; 解压 -&gt; 进入MAVlink路径 -&gt; 输入命令python mavgenerate.py，出现如下对话框则成功。 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路01_认识MAVLink]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html</url>
    <content type="text"><![CDATA[一、写在前面1.MAVLink是一种非常轻量级的通信协议，在简单的8位单片机上也可以运行。 2.MAVLink的初衷主要是用于无人机上，但它的通用性和可移植性非常好，它也可以应用于其它很多场合。 3.MAVLink的设计方式值得学习通信的朋友研究一下。 因此，学习无人机开发、学习通信原理、需要实现设备间通信的朋友都值得参看本文。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、关于MAVLink2.1 描述MAVLink：Micro Air Vehicle Link，即微型飞行器连接通信协议，于2009年初由Lorenz Meier首次发布。 Mavlink协议是在串口通讯基础上的一种更高层的开源通讯协议。 MAVLink是一种非常轻量级的通信协议，主要用于与无人机（以及板载无人机组件之间）进行通信。 2.2 主要特征1.效率很高MAVLink V1每帧最少只有8个字节的数据，包括帧头和数据包丢弃检测；MAVLink V2每帧最少只有14个字节的数据(是一个更加安全和可扩展的协议); 2.非常可靠自2009年以来，MAVLink一直被用于在各种不同且具有挑战性的通信信道上的许多不同车辆，地面站（和其他节点）之间进行通信。它提供了检测数据包丢失，损坏和数据包身份验证的方法。 3.支持多种编程语言可在多种MCU（如：STM32、Atmega、ARM7）和操作系统（如：Windows，Linux，MacOS，Android和iOS）上运行。 4.支持网络上最多255个并发系统 2.3 参考网址官网：https://mavlink.io/en 地面站：http://qgroundcontrol.org/mavlink/start 维基百科：https://en.wikipedia.org/wiki/MAVLink 三、MAVLink协议格式目前MAVLink有两个版本：V1和V2版本，差异及详情请看下图： MAVLink V2是V1的拓展版本，是一个更加安全和可扩展的协议。 由于市面上应用较广的还是V1版本，且支持的编程语言也是V1多余V2。因此，接下来（MAVLink学习之路）我都会结合MAVLink V1来讲述（学会V1，V2和容易就掌握了）。 3.1 MAVLink V1格式MAVLink通信内容包含常见通信协议帧头、帧尾、长度、校验等。协议格式及详情见下图： 四、MAVLink使用方法和步骤MAVLink之所以受广大无人机开发朋友的喜爱，原因就在于MAVLink移植方便、操作简单，以及它的兼容性很好（当然，这些都是它的优点，缺点肯定也是有的）。 要想使用MAVLink，一些基本的操作肯定还是得有。方便初学者对MAVLinK有进一步的认识，我先罗列主要步骤。 4.1 主要步骤1.下载相应安装包及工具 2.环境搭建 3.通过xml配置MSG 4.移植到STM32 5.结合实例应用编程 当然，以上几点只是概要内容，后续的文章会详细讲述其中的内容，敬请等待… 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【EWSTM8系列教程】做了整理并汇总，会随着系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、教程列表1.EWSTM8系列教程01_IAR介绍、下载、安装和注册 2.EWSTM8系列教程02_新建基础软件工程 3.EWSTM8系列教程03_主窗口、工具栏的概述 4.EWSTM8系列教程04_菜单概述（一） 5.EWSTM8系列教程05_菜单概述（二） 6.EWSTM8系列教程06_工程节点选项配置（一） 7.EWSTM8系列教程07_工程节点选项配置（二） 8.EWSTM8系列教程08_IDE选项配置（一） 9.EWSTM8系列教程09_IDE选项配置（二） 10.EWSTM8系列教程10_一个工程添加多个节点 11.EWSTM8系列教程11_一个工作空间添加多个工程 12.EWSTM8系列教程12_IAR文件类型描述 正在努力更新中，敬请等待…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。2.本文主要针对个人学习使用的朋友，若你是商业用途，建议购买正版软件。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程12_IAR文件类型描述]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面1.你保存、或者打包拷贝一个项目时，你会删掉不必要的文件吗？2.你知道这些eww、ewp、ewd……是什么文件吗？ 主要文件： 现象or疑问：1.购买一块开发板，厂家提供的源代码例程没有几个，但文件大小却有几百兆。2.百度网盘下载一个别人提供的代码压缩包，大小几十兆。3.打开别人下载的源代码工程，各种类型文件混杂在一起。4.我看有些人提供的源代码没有dep文件，这个文件可以删除吗？ 删除了会有什么影响？ 当你看完本文，理解这些文件类型的含义，你就不会有上面这些烦恼了。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、IAR文件类型概述 IAR中用到的文件类型很多，大概有四五十种，一般就是源代码和工程文件（含配置，编译生成文件）。下面会重点讲述常用的文件类型，一些不重要的，或者不常见的只简单概述。 分类：1.源代码类：.c、 .h、 .cpp、 .asm、 .a等；2.工程文件类：.eww、 .ewp、 .ewd、 .ewt、 .dep等；3.Exe文件类：hex、 .bin、 .out等；4.List类：.map、 .lst等；5.Obj类：.o、 .pbi、 .xcl等；6.settings类：.dbgdt、 .bat、 .ps1等； 下面我就按照上面分类，进行分章节讲述，重要的会标记出来，请注意查看标注内容。 三、源代码类文件这类文件类型编程时我们最先了解的，不多说，只概述。1.cC语言源代码文件 2.h头文件 3.cppC plus plus的意思，也就是C++源代码文件 4.asm汇编源代码文件 5.s汇编程序源代码文件 6.aIAR的库文件 7.inc汇编头文件 四、工程类文件这类文件比较重要，下面前两个eww、 ewp是一个项目中最重要的文件，是不可删除的文件。 1.eww全拼：Embedded Workbench Workspace，即IAR工作空间文件（不可删除）。 我们新建一个工作空间就会产生该文件，一个项目必须包含一个eww文件。所以，改文件不可删除。 参看文章：EWSTM8系列教程11_一个工作空间添加多个工程 2.ewp全拼：Embedded Workbench Project，即IAR工程文件（不可删除）。 新建一个工程，工程包含的信息就在这个文件里面。 参看文章：EWSTM8系列教程10_一个工程添加多个节点 3.ewd工程配置文件，主要是Debug相关的配置。删除之后Debug相关的配置恢复默认设置（一般不建议删除）。 4.ewt工程配置文件，主要是工程静态分析（C-STAT and C-RUN）配置文件。C-STAT and C-RUN文件 Project -&gt; Options -&gt; Static Analysis可以看见C-STAT，也就是静态分析相关的文件，如果不配置静态分析，可以删除这个ewt文件。 5.depDep：Dependency information，即依赖信息。 6.icf链接器配置文件： Project -&gt; Options -&gt; Linker -&gt; Config -&gt; configuration file。 五、Exe类文件默认位于Exe文件夹下面的文件，如Project\Debug\Exe，这类文件可删除。 1.hexIntel格式固件文件（用于下载的可执行文件）。Project -&gt; Options -&gt; Output Coverter。 2.Bin二进制格式固件文件（用于下载的可执行文件），与hex主要区别在于：bin文件不包含地址信息。 3.out编译输出的调试信息文件，若不输出调试信息，则没有。 六、List类文件默认位于List文件夹下面的列表文件，如Project\Debug\List，这类文件可删除。 1.map映射文件。该文件是分析代码内存占用情况的重要的文件，但可以删除。很多遇到问题之后会进入硬件故障（HardFault_Handler）等中断，就需要进一步分析map文件。 七、Obj类文件默认位于Obj文件夹下面的目标文件，如Project\Debug\Obj。在编译之后会输出许多这类目标文件，属于中间文件。因此，这类文件之后保存工程时可以删除。1.o目标模块文件，该文件就是对应每一个.c文件编译后的文件“Object module”。 2.browse浏览文件，主要用于“Go to Definition of”功能。使能开关：Tools -&gt; Options -&gt; Project -&gt; Generatie browse information。 3.pbi、.pbd主要也是用于浏览信息的文件。 4.inf链接器配置文件。 5.xcl扩展命令行文件 八、settings类默认位于settings文件夹下面的文件，如Project\settings。这类文件属于中间文件，可以删除。 1.wsdt工作区桌面设置文件，打开工作空间就会存在该文件。 2.bat批处理文件 好啦，就讲述到这里，更多文件类型及说明请看下图： 汇总文件类型： 九、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 十、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程11_一个工作空间添加多个工程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 如果你是初学者，还没有理解IAR中（工作空间 &gt; 工程 &gt; 节点）相关基础知识，建议先参看我的另外两篇文章： EWSTM8系列教程06_工程节点选项配置（一） EWSTM8系列教程10_一个工程添加多个节点 当你明白工作空间和工程之间的关系，这篇文章的知识你很快就能明白了。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、工作空间与工程的关系 本章节算是回顾知识点：工作空间与工程其实是包含的关系，一个工作空间可以包含多个工程。下图是工作空间、 工程、 节点三者的关系： 提示：在IAR中叫Node（节点），而在Keil中叫Target（目标）。其实这两者意思一样，都是隶属于工程的下一级。 三、为什么一个工作空间要添加多个工程简单回答：为了统一管理项目。 例如：1.某个项目有一个主机，多个从机，而且每个从机代码不一样。当公司有多个类似项目的情况下，公司为了统一管理项目，就会将一个项目规定为一个工作空间。 2.因公司很多工程都会使用到同样的代码（如算法库、标准外设库等），公司就会将这些工程整理到一个工作空间下。 当然，以上举例说的可能有点笼统，对于初学者，首先要掌握工程。 比如我之前文章提供的工程：STM8S-A01_GPIO基础知识、STM8S-A02_TIM精确延时、STM8S-A03_TIM定时中断……等。我可以将这些工程添加到一个工作空间下。 提示：关于工作空间添加多工程的作用和意义，初学者不必深入理解，当你学到一定程度自然就明白了。 四、工作空间如何添加多个工程工作空间添加工程可以说没有一点难度，添加一个工程10秒钟之内就能完成。而难点在于新建工程以及工程节点相关的配置。 本文工作空间添加工程，很多相关知识点是基于该系列教程前面分享的一些内容。主要两点内容：新建工程、节点选项配置。请参考下面文章：EWSTM8系列教程02_新建基础软件工程EWSTM8系列教程06_工程节点选项配置（一）EWSTM8系列教程07_工程节点选项配置（二） 按照上面文章新建好工程及相应节点配置好之后，就可在工作空间中添加这些工程了。 这里默认新建并配置好了三个工程：Project1、Project2、Project3。将这三个工程添加到工作空间Workspace中。 提示：最后我将提供这个例子代码下载。但这里只是提供例子，Project1、2、3这三个工程的源代码和功能都类似（一般实际项目源码和功能不会相同）。同时，Project1、Workspace这种命名也是方便理解（请根据项目实际情况命名）。 4.1 整理文件夹及文件 4.2 新建工作空间打开IAR软件 -&gt; File -&gt; New Workspace -&gt; Save Workspace As…保存在上面新建的Workspace文件夹下面。 具体请看下面动画效果： 新建工作空间动画效果： 4.3 添加已存在工程本文默认工程已经建立（具体过程请参考文章“新建基础软件工程”），所以只需要添加已存在工程即可。 菜单Project -&gt; Add Existing Project -&gt; 选择需要添加的工程（重复一样动作，添加三个已存在工程）： 添加已存在工程动画效果： 4.4 工作空间与工程预览按照上面步骤最后得出工作空间和工程的结构，如下图： 再次提示：此方法仅仅提供一种方法和思路，方便大家学习和掌握。具体内容根据实际项目情况而定。 五、多工程工作空间源代码下载为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。百度网盘下载地址：https://pan.baidu.com/s/1qIfaF0c-I_I4xGveFqwLDA密码: mpm2 GitHub下载地址：https://github.com/EmbeddedDevelop/STM8S_Multi-Project.git （提示：下载链接后期可能会失效， 若失效请关注微信公众号获取） 六、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程10_一个工程添加多个节点]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html</url>
    <content type="text"><![CDATA[一、写在前面 使用IAR新建一个工程，默认会创建Debug（调试）和Release（释放）两个Node（节点）。 什么是节点？ 为什么要创建这两个节点？ 创建多个节点目的和意义？ 如何创建多个节点？ 带着这些疑问来学习本文才会有更多收获。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、什么是节点 本文讲述添加多个节点，就需要了解什么是节点。之前文章《EWSTM8系列教程06_工程节点选项配置（一）》初略讲述了一下工作空间、 工程、 节点三者的关系： 提示：在IAR中叫Node（节点），而在Keil中叫Target（目标）。其实这两者意思一样，都是隶属于工程的下一级。 三、Debug与Release节点区别新建一个工程，默认创建两个节点，如下图： 在上一节了解了工程与节点之间的关系，那么为什么要一个工程下创建两个节点呢？ 两个节点的区别：Debug节点：主要用于调试使用，包含调试信息。Release节点：主要用于生成代码（正式产品），不包含调试信息。 细心的朋友会发现，这两个节点选项配置中有几个地方不同，如：C/C++ Compiler下的Output和Preprocessor选项、Assembler下的Output选项等。 关于节点选项配置内容可以参看文章《EWSTM8系列教程06_工程节点选项配置（一）》。 看了Debug和Release这两个节点的区别，相信你应该大概理解了为什么一个工程下要创建多个节点了。 其实，实际项目中还有很多用途，比如：同款产品，不同配置（不同芯片型号，不同编译等级…等节点选项配置不同）。 四、如何创建多个节点4.1 主要步骤1.创建一个工程2.添加组，添加文件3.工程节点选项配置4.基于某一个节点添加新的节点 其实这四个步骤中前三个都已经在文章《EWSTM8系列教程02_新建基础软件工程》中实现了，这里列出来主要是给初学者一个（从前到后的）提示。 下面就基于《EWSTM8系列教程02_新建基础软件工程》建好的工程，在Debug节点基础上添加一个Test节点。 4.2 添加Test节点1.Project -&gt; Edit Configurations进入编辑配置 2.点击“New”进入添加新节点配置 A.填写节点名称；B.基于某节点，这里相当于拷贝选择节点选项配置；C.默认设置为Debug或Release; 配置好之后，点击OK，再点击OK就行了。 3.修改节点选项配置比如：修改Test节点输出格式从hex格式修改为bin格式； 选择Test节点 -&gt; 选中节点右键 -&gt; Options -&gt; Output Converter -&gt;修改成bin格式。具体操作可以参看下面动画效果： 修改节点选项配置动画效果： 最后提示： 多个节点之间的区别总结来说就是：各自节点的选项配置不同。当然，可能就一个选项配置不同，也可能多个。节点选项的配置内容很多，请参看《EWSTM8系列教程06_工程节点选项配置（一）》。 五、多节点工程源代码下载为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。百度网盘下载地址：https://pan.baidu.com/s/16elpok-5IdPYoeNGXXFszw密码：m9pa GitHub下载地址：https://github.com/EmbeddedDevelop/STM8S_Multi-Node.git （提示：下载链接后期可能会失效， 请关注微信公众号公告消息） 六、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程09_IDE选项配置（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章《EWSTM8系列教程08_IDE选项配置（一）》讲述了IDE选项中前五项（Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息）的内容。 本文讲述剩余的几项内容：Project工程、Source Code Control源代码控制、Debugger调试器、Stack堆栈、Terminal I/O终端（Terminal I/O项只有在调试模式下才有）。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Project工程该IDE选项配置与工程相关，比如下面讲述的在编译工程的时遇到错误是否停止编译、在编译之前保存Workspace工作空间、Project工程等。 此页面用于Make和Build命令设置选项。 1.Stop build operation on：在如下情况停止编译操作A.Never：从不停止编译B.Warnings：遇到警告停止编译C.Errors：遇到错误停止编译 2.Save editor windows before building：在编译之前保存编辑（修改）过的文件A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 3.Save workspace and projects before building：在编译之前保存工作空间和工程A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 4.Make before debugging：在调试之前编译（Make）一下A.Never：从不编译B.Ask：询问是否编译C.Always：总是编译 5.Reload last workspace at startup：启动IAR时重新加载（打开）最近的工作空间 6.Play a sound after build operations：在编译操作之后播放声音 7.Generate browse information：生成浏览信息比如：Go to Definition跟踪代码的信息 8.No source browser and build status updates when the IDE is not the foreground process：当IDE不是前台进程时，不浏览源码和编译状态等更新操作 9.Enable project connections：使能工程链接使能该选项，需结合Project -&gt; Add Project Connection一起操作； 10.Enable parallel build：使能并行编译编译器在几个并行进程中运行，以便更好地使用CPU中的可用内核。后面参数为并行处理数。 三、Source Code Control源代码控制 1.Keep items checked out when checking in：当检查时保持项目输出 2.Save editor windows before performing source code control commands：在执行源代码控制命令之前保存编辑器窗口A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 提示：该IDE配置选项属于老版本配置选项，不适合新版本。 四、Debugger调试器 此页面特定用于调试器环境的配置。 1.When source resolves to multiple function instances：当源解析为多个函数实例时Automatically choose all instances：自动选择所有实例 2.Source code color in disassembly window：汇编窗口源代码颜色 3.Step into functions：跳入运行函数单步（Step into）调试时执行的操作：All functions：（一步一步）跳入所有函数Functions with source only：只跳入（当前）源代码函数 4.STL container expansion：STL容器扩展Depth：深入数 5.Update intervals：更新时间间隔指定Live Watch窗口和Memory窗口的内容更新的频率（单位：毫秒）。 6.Default integer format：默认整型格式Binary：二进制Octal：八进制Decimal：十进制Hexadecimal：十六进制 7.Window classification by background color：窗口分类的背景颜色比如：汇编窗口是一种背景色，内存窗口又是另外一种背景色。 五、Stack堆栈 此页面用于堆栈窗口的选项配置。 1.Enable graphical stack display and stack usage tracking：使能图形堆栈显示和堆栈使用跟踪stack usage threshold：堆栈使用阈值Warn when exceeding stack threshold：超过堆栈阈值时发出警告 2.Warn when stack pointer is out of bounds：当堆栈指针超出范围时发出警告 3.Stack pointer(s) not valid until program reaches：堆栈指针直到程序到达如下位置（main）时才有效在应用程序代码中指定您希望堆栈显示和验证发生的位置，如图，在程序运行到main函数才有效（进行校验）。 4.Warnings：警告选择应该发出警告的位置：Log：日志Log and alert：日志和警告 5.Limit stack display to：限制堆栈显示大小比如：如果你有一个大的堆栈，或者你只需要查看堆栈的最上面的部分，该选项就有用。 提示:堆栈窗口不会影响应用程序的执行性能，但它可能会读取大量数据，以便在执行停止时更新显示的信息。 六、Terminal I/O终端 此页面只有在调试模式才由，用于I/O终端的选项配置。 1.Input mode：输入模式终端I/O输入选择：Keyboard：键盘输入 Buffered：Buf模式 Direct：直接输入模式File：文件（内容）作为输入 Text：文本 Binary：二进制 2.Input echoing：输入呼应Log file：日志文件Terminal I/O window：终端窗口 3.Encoding：编码选择SystemUTF-8 4.Show target reset in Terminal I/O window：在终端I/O窗口显示复位目标 七、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程08_IDE选项配置（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 前面两篇文章针对的是工程节点各选项的配置，而本文讲述的是关于集成开发环境（IDE）各选项的配置。 本文讲述的内容包含字体、快捷键、语言、编辑、消息等许多与IDE相关的配置。因为属于Tools菜单，我也把它称为“工具配置选项”。也就是菜单Tools -&gt; Options下IDE选项，如下图： 由于IDE选项的配置较多，我将其分为IDE选项配置（一）和IDE选项配置（二）两篇文章来讲述，本文主要讲述前五项内容：Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Common Fonts普通字体2.1 Custom Tool Configuration自定义工具配置 本节内容主要是配置除编辑窗口（如代码）之外的其它窗口的字体设置（如工程窗口、编译窗口等）。 1.Fixed Width Font：固定宽度字体比如：Sysbolic Memory窗口中数据“0xCDCDCDCD”的字体。 2.Proportional Width Font：比例宽度字体比如：Sysbolic Memory窗口中数据“Data”这个标识的字体。 从字面意思翻译有点别扭，请结合下面动画效果理解。 普通字体配置动画效果： 提示：这里的字体不包含编辑器的字体，编辑器相关的字体见下面【5.3Colors and Fonts颜色和字体】说明。 三、Key Bindings快捷键配置 Key Bindings：直译为：键绑定，也就是配置快捷键。 Menu主菜单，下面对应的就是其中的子菜单。关于主菜单和子菜单里面具体内容，建议参看该系列教程：EWSTM8系列教程04_菜单概述（一）EWSTM8系列教程05_菜单概述（二） 具体操作：选择主菜单，再选中子菜单，按住需要配置的快捷键，点击Set或Add添加，点击Clear删除，点击Reset All复位所有快捷键（出厂默认）。具体可参看下面动画效果。 提示：primary：首要快捷键Alias：次要（别名）快捷键所以：点击Set是设置首要快捷键，点击Add是添加次要快捷键。 快捷键配置动画效果： 四、Language语言 这个配置选项比较简单，选择语言，目前EWSTM8只支持英语，像EWARM支持英语和日语。 五、Editor编辑器编辑器选项下面还包含External Editor外部编辑器、Setup Files设置文件、Colors and Fonts颜色和字体三个子选项。 第1区域：Tab1.Tab size：Tab键尺寸假如为2，则一个Tab键尺寸相当于2个空格大小。 2.Indent size：缩进尺寸 3.Tab Key Function：Tab键功能Insert tab：插入Tab符Indent with spaces：缩进为空格符 第2区域：边缘线1.Show right margin：显示右边缘线Printing edge：打印边缘（打印范围）Columns：根据列数显示 一条浅灰色的竖线，默认勾选上并显示（第80列） 第3区域：File Encoding：文件编码1.Default character encoding：默认字符编码有多种类型可选择，默认System（系统）； 2.Auto-detect character encoding：自动检测字符编码勾选上则自动检测文件。 3.EOL characters：结束符可选择：PC、 UNIX、 Preserve。 第4区域：show：显示1.Syntax highlighting：语法高亮显示默认勾选，按照语法规则高亮显示文字。如关键字（if、 while），注释语句，预定于#include等。 2.Auto indent：配置自动缩进 勾选上，则自动缩进。如上图，如果我在“case 0:”按下回车（换行），则在下一行自动缩进到return的r这个位置。（不勾选，则到每行的开始位置） 3.Show line numbers：显示行数（见下图）这个很好理解，就是显示代码、文本前面的行数； 4.Scan for changed files：扫描修改的文件比如：main.c在EWSTM8中打开（未修改），这时又通过其他软件把main.c打开，添加了一行i++代码，并保存。则这时将自动显示添加了一行i++的文件。 如果打开修改过，则会提示（是否更新，并显示那边添加了i++的文件）。 5.Show bookmarks：显示书签（见下图）包含错误、警告、断点、书签等一些标记符号。 6.Show fold margin：显示折叠边缘（见下图） 书签、行数、折叠说明图： 7.Enable virtual space：使能虚拟空间勾选上则光标可以放在编辑窗口任何一个位置编辑（则前面多处许多空格）。 8.Remove trailing blanks：去除末尾的空白当保存文件时（如Ctrl+S），删除每行后面的空格符号。 9.Auto code completion and parameter hints：自动代码完形和参数提示 10.Show source browser tooltips：显示源代码浏览器工具提示 11.Show line break characters：显示换行字符勾选则显示换行符。如下图：默认的换行符CR+LF（一般不建议勾选） 5.1 External Editor外部编辑器 勾选“Use External Editor”，则使用外部编辑器。 1.Type：类型有两种可选类型：Command Line：命令行DDE(Dynamic Data Exchange)：Windows动态数据交换 2.Editor：编辑器指定外部编辑器的文件名和路径。可以通过“浏览按钮”方便操作。 3.Arguments：参数指定要传递给编辑器的任何参数。这只适用于选择命令行类型。 类型为DDE时，对应的配置不同，如下图： 4.Service：服务指定由编辑器使用DDE服务名称，指定由编辑器使用DDE服务名称。 5.Command：命令指定要传递给编辑器的命令字符串序列。 5.2 Setup Files设置文件 1.Use Custom Keyword File：使用自定义关键字文件自定义关键字文件，如添加uint32_t这种自定义的数据类型，在文本中就会高亮显示。 提示：文件类型：txt本文文件一行一个关键字 2.Use Code Templates：使用代码模板使用方法请参考文章《EWSTM8系列教程04_菜单概述（一）》4.1 插入/编辑模板。 5.3 Colors and Fonts颜色和字体 1.Editor Font编辑字体字体和大小 2.语法颜色这里包含关键字、字符串、数字…等的字体颜色和背景颜色配置。 六、Messages消息 1.Enable All Dialogs使能所有对话框类似如下图对话框，如果勾选“Don’t show again”，就禁用该对话框。使用此选项可以重新启用所有被禁止的对话框。 七、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程07_工程节点选项配置（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章《EWSTM8系列教程06_工程节点选项配置（一）》讲述了节点选项中前五项（Target目标、Static Analysis静态分析、C/C++ Compiler编译器、Assembler汇编器、Output Converter输出转换器）的内容。 本文讲述剩余的几项内容：Custom build自定义、Build Actions执行动作、Linker链接器、Debugger调试器、ST-LINK工具。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Custom build自定义2.1 Custom Tool Configuration自定义工具配置 1.Filename extensions：文件扩展名如：extension.lex 2.Command line：命令行命令格式为：flex $FILE_PATH$ -o$FILE_BNAME$.c 3.Output file：输出文件格式：$FILE_BPATH$.c$FILE_BPATH$.h 4.Additional input files：额外的输入文件比如：$TOOLKIT_DIR$\inc\stdio.h 5.Run this tool before all other tools：在运行其他工具之前运行这个工具 以上5个选项内容其实是协同完成一个功能，比如：使用工具（命令）将一个输入文件，转化并输出。 三、Build Actions执行动作3.1 Build Actions Configuration执行动作配置 1.Pre-build command line：在“Build”之前执行命令行如：在编译之前拷贝一个文件，或者修改一个文件内容等。 2.Post-build command line ：在“Build”之后执行命令行如：在编译完成之后，拷贝hex，或者bin文件，或在bin文件末尾添加校验等。 四、Linker链接器4.1 Config配置 1.Linker configuration file：链接器配置文件根据项目设置自动选择默认链接器配置文件。如果要覆盖默认文件，勾选“Override default”即可。 2.Configuration file symbol definitions：配置文件的符号定义定义要在配置文件中使用的常量配置符号。这种符号的效果与使用链接器配置文件中的define symbol指令定义的符号相同。 4.2 Library库 1.Automatic runtime library selection：自动运行时库选择使链接器根据您的项目设置自动选择适当的库。 2.Include C-SPY debugging support：包括C-SPY调试支持包含用于调试应用程序和调试器本身之间通信的调试库。 3.Buffered write：写缓冲在程序执行期间缓冲终端输出，而不是立即将每个新字符打印到C-SPY终端I/O窗口。当您使用通信缓慢的调试器系统时，此选项非常有用。 4.Additional libraries：附加库指定您希望链接器在链接过程中包含的其他库。每行只能指定一个库，并且必须指定到库的完整路径。可以通过“Browse按钮”来添加（类似新建工程添加路径）。 5.Override default program entry：覆盖默认的程序入口默认情况下，程序条目是__iar_program_start。链接器确保包含了包含程序条目标签的模块，并且不丢弃包含该标签的部分。Entry symbol：输入符号Defined by application：由应用程序定义 4.3 Input输入 1.Keep symbols：保留符号 2.Raw binary image：原始二进制图像链接图像纯二进制文件，指定参数:File：文件Symbol：符号Section：部分区域Align：对齐 4.4 Optimizations优化这里就不贴图了，链接器优化只有一个勾选项： 1.Merge duplicate sections：合并重复的部分使链接器仅保留等效只读部分的一个副本。注意，这可能会导致不同的函数或常量具有相同的地址，因此依赖于不同地址的应用程序不能正确地使用所选的选项。 4.5 Output输出 1.Output filename：输出文件名设置链接器输出文件的名称。默认情况下，链接器将使用带有文件名扩展名的项目名称。 2.Include debug information in output：输出中包含调试信息使链接器生成一个ELF输出文件，包括用于调试信息的DWARF。 4.6 List列表 1.Generate linker map file：生成链接器映射文件 2.Generate log file：生成日志文件Automatic library selection：自动库选择Initialization decisions：初始化决策Module selections：模块选择Redirected symbols：重定向符号Section selections：段选择Unused section fragments：未使用的部分片段 4.7 #define预定义这里不贴图了，预定义一些符号。 例如：TESTVER=1注意：一行一条，“=”两边不能有空格。 4.8 Diagnostics诊断具体内容请参考《EWSTM8系列教程06》中“5.7 Diagnostics 诊断”的内容。 4.9 Checksum校验和 1.Fill unused code memory：填充未使用代码的内存Fill pattern：填充形式Start address：起始地址End address：结束地址 2.Generate checksum：生成校验和Checksum size：校验和尺寸（数据类型），可以是1、2、4字节。Alignment：校验和对齐方式。Algorithm：选择算法类型。Result in full size：结果为全尺寸Complement：补充Bit order：位顺序Reverse byte order within word：字节顺序颠倒Checksum unit size：校验和单元尺寸（8、16、32Bit） 4.10 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行对链接器相关选项进行配置。具体命令后续抽空单独整理成相关文章。 五、Debugger调试器本章节主要讲述与调试下载相关的一些选项配置。 5.1 Setup设置 1.Driver：驱动器选择调试仿真驱动器（工具） 2.Run to：运行到复位之后运行到指定位置 3.Setup macros：设置宏Use macro file：使用宏文件 4.Device description file：设备描述文件根据项目设置自动选择默认设备描述文件。要覆盖默认文件，勾选“Override default”并指定一个替代文件。 5.2 Images镜像 可以使用三组Download extra Images：下载外部镜像文件Path：路径Offset：偏移地址Debug info only：是否只调试 5.3 Extra Options额外选项配置这里不讲述，后续专门整理一篇命令行相关文章。 5.4 Plugins插件 1.Select plugins to load：选择要加载的插件2.Description：插件描述3.Location：插件位置4.Originator：插件来源5.Version：插件版本 六、ST-LINK工具其它两个工具simulator和STice就不讲述了，讲一下常用的ST-LINK。 6.1 setup设置 1.Download：下载默认情况下，当进入调试时，下载应用程序到RAM或flash中。下载选项允许您修改下载的行为。 Suppress：抑制禁止下载代码，同时保留flash的当前内容。如果您想调试已经下载在目标内存中的应用程序，这个命令非常有用。 Erase：擦除在下载代码之前删除内存(FLASH、EEPROM和选项字节)。 EraseVerify：擦除验证验证下载代码的地址是否被擦除。 Use option bytes configuration file：使用选项字节配置文件在下载前将在选项字节配置文件(obc)中定义的选项字节设置写入设备。 2.Communication options：通信选项配置Use SWIM interface：使用SWIM接口Communication log：通信日志 七、说明1.因IAR各种IDE针对的处理器差异较大，所以关于节点选项的配置差异也较大。本文讲述关于EWSTM8的许多节点选项可能在其他IDE中没有。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程06_工程节点选项配置（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 Options for node即节点选项，而node节点位于Project工程的下一级。本文讲述的工程节点选项配置，即菜单Project -&gt; Options下Options for node节点选项中的前五项配置，如下图： 由于节点选项较多，我将其分为工程节点选项配置（一）和工程节点选项配置（二）两篇文章来讲述。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、拓展内容 本文讲述的工程节点选项配置，其中的工程与节点是包含关系，而工作空间与工程也是包含关系。 2.1 工作空间、 工程、 节点三者的关系三者之间就是包含关系：工作空间 &gt; 工程 &gt; 节点。一个工作空间可以包含多个工程，一个工程可以包含多个节点，见下图： 请关注系列教程新建多工程，多节点的文章。 2.2 打开节点选项配置的三种方法1.选中节点 -&gt; 快捷键Alt + F7这种方法简单、快捷，推荐使用。 2.选中节点 -&gt; 右键 -&gt; Options 3.选中节点 -&gt; 菜单Project -&gt; Options 三、General Options普通选项3.1 Target目标 1.Device：器件即选择MCU芯片型号，如上图选择的是STM8S103F3P. 2.Code model：代码模式包含三种：小、中、大；Small：小Medium：中Large：大对于初学者，可以理解为：如果选择Large大的话，编译出来的Code代码就会更大。具体的差异可以查看生产的.map文件。 3.Date model：数据模式原理类似上面代码模式，同样有三种：Small：小Medium：中Large：大 3.2 utput输出 1.Output file：输出文件输出文件类型有两种，但只能二选一。A.Executable：生成可执行的文件。如Hex、Bin等；B.Library：生成库文件。 2.Output directories：输出目录（路径）编译过程中生成的文件分别存放的目录（路径）。默认在Debug文件夹下面就会发现三个文件夹：Exe、Obj、List。A.Executables/Libraies：生成可执行/库文件的路径B.Object files：生成目标文件的路径C.List files：生成列表文件的路径 提示：路径为相对工程文件（如Demo.ewp）的路径。 3.3 Library Configuration库配置 1.Library：选择运行时库运行时库有四种可选择：None：无Normal：选择常规配置的运行时库Full：选择完整配置的运行时库Custom：选择定制运行时库 2.Description：运行时库的描述 3.Configuration：运行时库的配置 提示：第2、3点是随第1点选择的库改变而改变，第3点配置只有在选择“定制运行时库”时才可修改。请参看下图动画效果： 选择运行时库动画效果： 3.4 Library Options库选项 1.Printf formatter：选择Printf（打印输出）格式器总共有8种类型：Auto：自动格式Full：完整格式Full without multibytes：完整无多字节格式Large：大格式（不区分a或A）Large without multibytes：大格式（不区分a或A）,无多字节格式Small：小格式（不区分a或A，无Float）Smallwithout multibytes：小格式（不区分a或A，无Float）,无多字节格式Tiny：微小格式； 2.Scanf formatter：选择Scanf（打印输入）格式器类似上面printf，总共有7种类型：Auto：自动格式Full：完整格式Full without multibytes：完整无多字节格式Large：大格式Large without multibytes：大格式,无多字节格式Small：小格式Smallwithout multibytes：小格式,无多字节格式 3.Math functions：数学函数有两种可选择类型：Default：默认。包含cos, sin, tan, log, log10等函数；Smaller：精简。函数体积小，执行速度快，精度低，输入范围小等。 3.5 Stack/Heap栈和堆 1.Stack size：栈大小。 2.Heap size：堆大小。 提示：堆和栈位于内存中两块不同区域，使用的大小根据实际情况而定，修改此值之前请认真了解堆栈的含义。 3.6 MISRA C标准 MISRA-C:1998和MISRA-C:2004年的选项控制IDE如何检查源代码与MISRA C规则的偏差，这些设置用于编译器和链接器。 General Options普通与C/C++ Compiler编译器中的MISRA C选项配置相关联，本文章不讲述，后续单独讲述关于MISRA C的内容。 四、Static Analysis静态分析4.1 C-STAT静态分析 1.Select C-STAT Checks：选择C静态检查项目里面可选择的项目较多，通过手动选择（使能/失能）相关选项，使用前需了解C-STAT相关知识。 2.Import Settings：导入设置导入静态检查配置文件（类型为.xml文件）。 3.Export Settings：导出设置导出（当前第1点中）静态检查配置文件。 4.Enable parallel analysis：使能并行分析后面参数为并行分析（进程）数。 5.Enable module timeout：使能模块超时值后面参数为单个模块超时时间（单位：秒） 6.Enable false-positives analysis：使能“误报”分析 7.Limit messages per check and file：限制每次检查文件的消息数 提示：静态分析各项参数配置好之后，在菜单Project -&gt; C-STAT Static Analysis中执行。 4.2 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行进行静态检查相关的配置，具体命令后续抽空单独整理成相关文章。 五、C/C++ Compiler编译器5.1 Language语言1 1.Language：选择语言三选一，选择C语言，就不能C++相关特性。选择Auto自动，会根据文件后缀自动判别。 2.Language conformance：语言一致性控制编译器如何严格遵守标准C或c++语言。Standard with IAR extensions：接受IAR（STM8）特定的关键字作为标准C或c++语言的扩展。Standard：禁用IAR系统扩展，但不严格遵循C/C++语言。Strict：严格遵守C/C++语言。 3.C dialect：选择C标准C 89 C 99 Allow VLA：运行可变长度数组； C++ inline semantics：支持内联函数； Require prototypes：需要原型强制编译器验证所有函数都有合适的原型。 4.C++ dialect：选择C++标准Embedded C++：嵌入C++Extended Embedded C++：扩展嵌入C++Destroy static objects：清除静态对象 5.2 Language语言2 1.Plain ‘char’解析为Signed或者Unsigned. 2.Floating-point semantics：浮点语句Strict conformance：严格一致，使编译器严格遵守浮点表达式的C和浮点标准。Relaxed：放松，使编译器放松语言规则并对浮点表达式执行更积极的优化。 3.Enable multibyte support：启用多字节的支持默认情况下不支持多字节，启用多字节支持使编译器可以根据主机的默认设置多字节支持来解释源代码中的多字节字符。 5.3 Optimizations优化 1.Level：优化等级None：无Low：低Medium：中High：高选择High优化等级为高时，可以选择Balanced平衡、Size大小、Speed速度（速度时可选择不收大小限制）,请参看下图动画效果。 2.Enabled transformations：使能转换选择不同的优化等级，对应优化转换不同，也可自定义转换项目。 3.Number of virtual byte registers：虚拟寄存器的字节数 优化选项动画效果： 5.4 Output编译输出 1.Generate debug information：生成（输出）调试信息如果需要调试，此选项需勾选。 5.5 List列表 1.Output list file：输出列表文件Assembler mnemonics：输出汇编助记符Diagnostics：输出诊断信息 2.Output assembler file：输出汇编文件Include source：包含源文件Include call frame information：包含调用信息 5.6 Preprocessor预处理 1.Ignore standard include directories：忽略标准包含目录（路径） 2.Additional include directories：添加路径最好是相对工程目录的相对路径。 3.Preinclude file：预包含文件 4.Defined symbols：预定义类似代码中#define，这里截图预定义STM8S103，相当于定义在stm8s.h文件中。 5.Preprocessor output to file：预处理输出到文件 5.7 Diagnostics诊断Diagnostics诊断选项卡，用于规定诊断信息的分类和显示。编译过程中可能产生三种错误诊断信息：remark(注意)、waining(警告)和error(错误)。 1.remark是一种次要的诊断信息，表明按源程序结构生成的代码可能出现不正常。 2.warning表示源程序中存在错误，但编译过程不会停止。 3.error表示源程序中存在违反C/C++语言规则的现象，将导致无法生成目标代码。error信息不能被禁止，也不能重新分类。 1.Enable remarks：使能注意信息勾选则允许编译器产生remark注意诊断信息。 2.Suppress these diagnostics：禁止显示这些（指定）诊断信息比如：我们希望禁止显示（输出）Pa091和Pe001这两类信息，可以在此写入【Pa091, Pe001】。 3.Treat these as remarks：将这些（指定）信息作为注意信息显示比如：我们希望将Pe177这类警告信息作为注意信息显示，只需要在此输入Pe177即可。 4.Treat these as warnings：将这些（指定）信息作为警告信息显示与上面第3点同理。 5.Treat these as errors：将这些（指定）信息作为错误信息显示与上面第3点同理。 6.Treat all warnings as errors：将所有警告作为错误处理（并显示） 5.8 MISRA C标准 MISRA-C:1998和MISRA-C:2004年的选项用于编译器和链接器。General Options普通选项与C/C++ Compiler编译器中的MISRA C选项配置相关联，本文章不讲述，后续单独讲述关于MISRA C的内容。 5.9 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行对编译相关选项进行配置。具体命令后续抽空单独整理成相关文章。 六、Assembler汇编器这一章节内容和上面C/C++编译器原理类似，只是这里是针对汇编。 6.1 Language语言 1.User symbols are case sensitive：用户符号区分大小写 2.Enable multibyte support：使能多字节的支持 3.Allow mnemonics in first column：允许在第一列中使用助记符 4.Allow directives in first column：允许在第一列中使用指令 5.Macro quote characters：宏引用字符选择有四种字符可选择：A.()B.[]C.{}D.&lt;&gt; 6.2 Output编译输出这里就不贴图了，和上面一章节C/C++的Output一样，Generate debug information：生成（输出）调试信息，如果需要调试汇编，此选项需勾选。 6.3 List列表 1.Output list file：输出列表文件A.Do not include diagnostics：不包括诊断B.Include cross-reference：包括交叉引用C.List macro definitions：宏定义列表D.Disable macro expansion：禁用宏扩展E.List only assembled parts：只列出部分列表（除假条件汇编）F.Truncate multiline data field：截断多行数据字段 6.4 Preprocessor预处理 1.Ignore standard include directories：忽略标准包含目录（路径） 2.Additional include directories：添加路径 3.Preinclude file：预包含文件 4.Defined symbols：预定义 5.Preprocessor output to file：预处理输出到文件 提示：这里选项和上面C/C++中预处理类似，只是这里针对的是汇编。 6.5 Diagnostics诊断这里就不贴图了，本节Diagnostics诊断几乎与上一章节中Diagnostics诊断一样，只是这里针对的是汇编，详情请参看上一章节C/C++的Diagnostics诊断描述。 6.6 Extra Options额外选项配置这里就不贴图了，本节Extra Options额外选项配置同样与上一章节一样。 七、Output Converter输出转换器7.1 Output输出 1.Generate additional output：使能生成额外的输出（文件） 2.Output format：输出格式A.MotorolaB.Intel-extendedC.BinaryD.Simple 3.Output file：输出文件Override default：默认覆盖 八、说明1.因IAR各种IDE针对的处理器差异较大，所以关于节点选项的配置差异也较大。本文讲述关于EWSTM8的许多节点选项可能在其他IDE中没有。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 九、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程05_菜单概述（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 在上一篇【EWSTM8系列教程04_菜单概述（一）】文章中概述了File文件、Edit编辑、View视图、Project工程前面四个重要菜单的内容。 本文讲述Debug调试、ST-Link下载调试工具、Tools工具、Window窗口、Help帮助后面五个菜单的内容。 其中“Debug调试”菜单是在调试模式时才有（编辑模式下没有）。“下载调试工具”是由你工程目标配置所决定的（上面截图是配置ST-Link）。 本文主要概述后五个菜单的内容： 1.Debug调试菜单 2.下载调试工具菜单 3.Tools工具菜单 4.Window窗口菜单 5.Help帮助菜单 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Debug调试菜单 Debug调试菜单只有在调试模式下才会显示出来，里面大部分常用子菜单会显示在【调试工具栏】，可以参看【EWSTM8系列教程03_主窗口、工具栏的概述】文章中“3.2调试工具栏”的章节。 1.Go：全速运行 F52.Break：停止运行3.Reset：复位4.Stop Debugging：结束调试 Ctrl + Shift + D5.Step Over：逐行运行 F106.Step Into：跳入运行 F117.Step Out：跳出运行 Shift + F118.Next Statement：运行到下一语句9.Run to Cursor：运行到光标行10.AutoSetp：自动按步骤运行11.Set Next Statement：设置下一条语句12.C++ Exceptions：C++异常13.Memory：内存保存/复位14.Refresh：调试更新15.Logging：调试日志 Debug菜单前面10个子菜单比较常用，也比较重要。这里再文字解释其中几个子菜单的含义，教程后面针对性详细讲述其中子菜单内容。 Step Over、Step Into、Step Out这三个子菜单都具有“逐步/单步”调试的意思。Step Into遇到函数会进入函数执行，而Step Over则不会进入函数。Step Out是跳出当前函数。 Run to Cursor运行到光标行：在暂定状态，将光标放在程序某一行，执行该操作程序运行到你所在行则会停下来（当然，如果那一行程序永远都执行不到，则程序一直执行，直到你执行其他操作）。 AutoSetp自动按步骤运行：可以设置按照指定方式（Step Over、Step Into）、 间隔时间自动运行。 三、下载调试工具菜单 这个菜单的内容会随你工程配置的下载调试器改变而改变，而不同下载调试器的子菜单内容也不一样，如下图： 可以看见我上面截图中两种类型（ST-Link和Simulator）菜单中的子菜单内容不一样。 这个菜单里面的内容使用频率相对较低，而目前来说主要是选择ST-Link来下载调试。下面概述一下ST-Link下各子菜单内容。 1.Leave Target Runing：离线运行（离开目标运行）2.Disable Interrupts When Stepping：当单步调试时禁止中断3.Option bytes：选项字4.Data Sample Setup：数据采样设置5.Data Sample：数据样本6.Sampled Graphs：采样图7.Breakpoint Usage：使用断点 四、Tools工具菜单Tools工具菜单包含了IDE相关的一些配置，包括字体、快捷键、语言、编辑、消息、工程等一系列配置。 1.Options：工具配置选项2.Filename Extension：文件扩展名3.Configure Viewers：配置预览4.Configure Custom Argument Variables：配置自定义参数变量5.Configure Tools：配置工具 4.1 Options工具配置选项Options工具配置选项是比较重要的一个子菜单，里面包含了我们字体大小、颜色、快捷键、工程输出信息等一系列比较重要且实用的内容。本文重点在于概述菜单内容，该系列教程后面会详细讲述里面具体内容。 五、Window窗口菜单Window窗口菜单需要和View视图菜单具有相似的地方（像打开/关闭工具栏，IAR之前版本就是在View视图菜单操作），但需要区分开来。 Window窗口菜单为操作IDE窗口和改变它们在屏幕上排列的一个菜单。 1.Close Document：关闭当前活动的文档编辑窗口 Ctrl + F42.Close Window：关闭当前活动的IDE窗口（工程、参考、浏览等窗口）3.Split：拆分窗口4.Move Tab to New Vertical Editor Window：移动选项卡到新的垂直编辑器窗口5.Move Tab to New Horizontal Editor Window：将选项卡移动到新的水平编辑器窗口6.Move Tab to the Next Window：将选项卡移到下/后一个窗口7.Move Tab to the Previous Window：将选项卡移动到上/前一个窗口8.Close All Tabs Except Active：关闭除活动以外的所有选项卡9.Close All Tabs to the Right of Active：关闭活动右边的所有选项卡10.Close All Editor Tabs：关闭所有选项卡编辑11.Toolbars：工具栏12.Status bar：状态栏 5.1 拆分窗口Split拆分窗口就是将一个窗口拆分为上下左右四个窗口，各个窗口大小可自由分配，如下图： 5.2 移动选项卡到Move Tab to New Vertical Editor Window和Move Tab to New Horizontal Editor Window类似，一个是垂直，一个是水平，下图为垂直效果： 5.3 工具栏、状态栏这两个子菜单的内容之前IAR版本是放在View视图菜单下面，它俩的功能类似视图菜单的功能，打开/关闭的功能。 注意：工具栏菜单在编辑模式下只有Main主工具栏，在调试模式下会增加Debug调试工具栏，如下图： 六、Help帮助菜单这个菜单里面内容比较实用哦，从字面意思理解“帮助”，我写的大部分内容都是参考这里面的，其实重要的就是帮助文档。 6.1 帮助文章Content内容、Index索引、Search搜索是对应帮助文档里面的内容，如下如： 6.2 Guide指导手册如上图子菜单中，红色框住的那一部分都属于IDE的指导手册，包含版本历史信息、管理、参考信息等。 6.3 其它IAR on the Web：IAR网站Information Center：信息中心Lincense Manager：许可证管理，注册的时候就是这里进入About：关于软件的版本信息 七、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程04_菜单概述（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 IAR软件针对不同处理器存在多个版本，比如EWARM、EWMSP430、EWSTM8等，但为了让软件在使用上“兼容”，IAR推出的多个版本软件在使用上很多地方都有相似之处。因此，本文针对EWSTM8讲述的大部分内容也适用于IAR其他系列软件。 由于菜单内容较多，我将其分为“菜单概述（一）”和“菜单概述（二）”两篇文章来讲述。为了使文章内容精简，下面大部分菜单内容只简单概述，该系列教程后面文章会逐步深入每一个细节的功能。 本文主要概述前四个菜单的内容： 1.File文件菜单 2.Edit编辑菜单 3.View视图菜单 4.Projcet工程菜单 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、主菜单内容 主菜单在不同状态下会有一些差异，比如在编辑模式和调试模式下存在差异，不同调试下载工具也存在差异。 2.1 编辑/调试模式差异在编辑模式下有8个主菜单，在调试模式下会增加Debug调试菜单，共有9个主菜单。 2.2 不同调试下载工具差异上面主菜单中有一个ST-Link菜单选项，其实这个菜单是根据你工程配置选择的调试下载工具改变而改变的。 如在仿真、J-Link、ST-Link下的区别： 三、File文件菜单File文件菜单是比较常见的菜单，主要包含对文件的新建、打开、关闭、打印等一些常见的操作，在编辑和调试模式下完全一样。 1.New File：新建文件 Ctrl + N2.New Workspace：新建工作空间3.Open File：打开文件/工作空间 Ctrl + O4.Open Workspace：打开工作空间5.Open Header/Source File：打开头文件或源文件6.Close：关闭文件7.Save Workspace：保存工作空间8.Save Workspace As：另存工作空间9.Close Workspace：关闭工作空间10.Save：保存文件 Ctrl + S11.Save As：另存文件12.Save All：保存所有文件/工作空间13.Page Setup：打印页面设置14.Print：打印 Ctrl + P15.Recent Files：最近打开文件16.Recent Workspaces：最近打开工作空间17.Exit：退出软件 四、Edit编辑菜单 这个Edit菜单在编辑和调试模式下相同，在编辑的时候使用较多，也比较常用。 这个菜单下面大部分内容和默认主工具栏按钮一样，可以参看我的另一篇文章：EWSTM8系列教程03_主窗口、工具栏的概述. 1.Undo：撤销编辑 Ctrl + Z2.Redo：恢复编辑 Ctrl + Y3.Cut：剪切 Ctrl + X4.Copy：复制 Ctrl + C5.Paste：粘贴 Ctrl + V6.Select All：全选 Ctrl + A7.Find and Replace&gt;Find：查找 Ctrl + F Find and Replace&gt;Find Next：查找下一目标 F3 Find and Replace&gt;Find Previous：查找上一目标 Shift + F3 Find and Replace&gt;Find Next (Selected) ：在选中对象里查找下一目标 Ctrl + F3 Find and Replace&gt;Find Previous (Selected)：在选中对象里查找上一目标 Ctrl + Shift + F3 Find and Replace&gt;Replace：替换 Ctrl + H Find and Replace&gt;Find in Files：在对话框中指定条件查找 Find and Replace&gt;Replace in Files：在对话框中指定条件替换 Find and Replace&gt;Incremental Search：在对话框中查找字符 Ctrl + I8.Navigate&gt;Go To：前往行列 Ctrl + G Navigate&gt;Toggle Bookmark：标记/取消书签 Ctrl + F2 Navigate&gt;Previous Bookmark：跳转到上一个书签 Shift + F2 Navigate&gt;Next Bookmark：跳转到下一个书签 F2 Navigate&gt;Navigate Backward：跳转到上一步 Alt + 左箭头 Navigate&gt;Navigate Forward：跳转到下一步 Alt + 右箭头 Navigate&gt;Go to Definition：跳转到定义 F129.Code Templates&gt;Insert Template：插入模板 Ctrl + Alt + V Code Templates&gt;Edit Templates：编辑模板10.Next Error/Tag：显示下一错误/目标 F411.Previous Error/Tag：显示上一错误/目标 Shift + F412.Complete Word：完型语句 Ctrl + Alt + 空格13.Complete Code：完型类/结构体代码 Ctrl + 空格14.Parameter Hint：参数提示 Ctrl + Shift + 空格15.Match Brackets：括号匹配16.Toggle All Folds：折叠/打开当面编辑代码 Ctrl + Alt + F17.Auto Indent：自动缩进（对齐） Ctrl + T18.Block Comment：块注释 Ctrl + K19.Block Uncomment：块取消注释 Ctrl + Shift + K20.Toggle Breakpoint：添加/取消断点 F921.Enable/Disable Breakpoint：使能/失能断点 Ctrl + F9 上面是简述每一个子菜单的内容（有一部分子菜单和工具栏按钮一样，这里不再详细讲述，可以点击文章链接查看）。下面将详细讲述几个常用、重要的Edit子菜单菜单。 4.1 插入/编辑模板如果你经常使用同样一段代码，就可以使用这个功能。 IAR默认只有if、for这两个模板，我们可以自己添加（编辑）模板，比如添加一个while模板，点击“编辑模板”菜单就可以进入编辑状态，编辑的语法很简单，可以参考自带模板。添加内容如下：1234#TEMPLATE "&amp;Statement&gt;&amp;while"while(1)&#123;&#125; 插入/编辑模板动画效果： 4.2 完形语句完形填空就是词组补全，类似上小学时词语完形填空。比如完整的代码为LED_Initializes（前提是具有这个词组），而实际只需要输入LED_字母就可以补全。 完形填空动画效果： 4.3 自动缩进这个功能比较实用，在你代码比较凌乱（也就是不对齐的情况），使用该功能就可使代码自动对齐。自动缩进是空格（空几格）还是Tab需要在Tools-&gt;Options中配置，后面详细讲述。 自动缩进动画效果： 五、View视图菜单 View这个菜单的意思就是打开（已关闭的）视图窗口，比如我们的工作空间窗口不见了，就可以通过该菜单打开。 由于在调试模式下增加了一些视图窗口，所以在编辑模式和调试模式下存在一些差异。 本节内容简单，参看下面动画效果就很容易理解。但有些视图窗口功能有点相似，可能初学者理解起来比较困难，下面列出视图菜单的内容，接着会讲述一些相似子菜单的区别。 1.Messages&gt;Build：编译信息 Messages&gt;Find in Files：查找信息 Messages&gt;Tool Output：工具信息 Messages&gt;Debug Log：调试信息2.Workspace：工作空间窗口3.Source Browser&gt;Source Browser：浏览源码窗口 Source Browser&gt;References：引用窗口 Source Browser&gt;Declarations：声明窗口 Source Browser&gt;Call Graph：调用图窗口4.C-STAT Message：静态分析窗口5.Breakpoints：调试断点窗口6.Call Stack：调用栈窗口7.Watch：普通查看表达式/变量值窗口8.Live Watch：查看实时表达式/变量值窗口9.Quick Watch：快速查看表达式/变量值窗口10.Auto：自动显示表达式/变量窗口11.Locals：局部变量窗口12.Statics：静态变量窗口13.Memory：内存窗口14.Registers：寄存器窗口15.Disassembly：反汇编窗口16.Stack：堆栈地址窗口17.Symbolic Memory：内存标记窗口18.Terminal I/O：终端窗口19.Macros：宏指令窗口20.Symbols：符号表窗口21.Code Coverage：代码覆盖（利用）率窗口22.Images：图片窗口23.Cores：内核状态窗口 View视图菜单可以打开被关闭了的窗口，打开的窗口也可以随意拖动（后面新增的功能）：上、下、左、右、浮动等。 打开视图窗口并拖动动画效果： 细心的朋友其实会发现，View视图子菜单是进行了分类的（用横线隔开），而分类里面的内容具有相似的地方。下面我将详细讲述一下Watch和Memory这两类。 5.1 Watch类窗口 View视图菜单中Watch、 Live Watch、 Quick Watch、 Auto、 Locals、 Statics这6个子菜单功能其实类似，但各有差异。 6个视图子菜单窗口的显示内容都类似，总共四个属性： Expression：表达式名称，一般指变量和函数等。Value：对应的值；Location：对应所在位置，寄存器、RAM、Flash等。Type：变量/函数类型。 这里可以将6个子菜单再次细分，前面3个菜单分为一类：Watch查看窗口；后面3个菜单分为一类：Atuo自动窗口。 1.Watch普通查看表达式/变量值窗口Watch菜单下面有4个子菜单：Watch1 ~4，但都是一样的，可以分别开4个窗口出来同时查看表达式/变量值。一般这个窗口我们比较常用，添加自己想要查看的变量值。A.通过手动添加需要查看的表达式/变量；B.只有暂停调试才会更新对应的值； 2.Live Watch查看实时表达式/变量值窗口与上面Watch窗口类似，差别在于：A.变量须为静态（全局）;B.变量实时更新（程序在运行时）; 3.Quick Watch快速查看表达式/变量值窗口快速浏览变量窗口主要结合另外一个视图菜单Macro Quicklaunch一起使用，达到精确地控制变量值。 4.Auto：自动显示表达式/变量窗口当程序暂停在某一个地方，自动显示暂停坐在位置的表达式/变量，而不需要像Watch要手动添加。 5.Locals：局部变量窗口这个子菜单和Atuo类似，也是自动显示，区别在于：Locals是显示的局部表达式变量，而静态/全局变量不会显示。 6.Statics：静态变量窗口该子菜单同样具有Atuo的特性，自动显示。但是，它显示的内容是静态变量（静态局部、静态全局、全局变量）。 5.2 Memory类窗口这一类窗口主要是显示内存（ROM、 RAM、 Flash、 外设等）地址的值，同时还包含堆栈、反汇编等与内存相关的内容。 1.Memory内存Memory菜单下面有4个子菜单，包含Memory1~4。都一样，可同时打开4个。严格来说翻译成内存是不正确的，里面的内容其实不是我们常说的内存。见下图： 2.Register寄存器窗口这里不用多说，就是内核里面寄存器，如：SP、 PC等寄存器。 注意：我们常说的外设寄存器不在这里，外设寄存器是有地址的，可以在Memory中查看。 3.Disassembly反汇编反汇编窗口显示了通过C语言汇编出来的具体代码。对分析每一条汇编语言的人有帮助，但相信很小有人仔细研究汇编语言了。 4.Symbolic Memory这个有点不好翻译，简单来说：内存上面有数据，那么就会标记相应的表达式，及对应的数值，而没有数据的则不标记。 还有，被标记的内容就是Menmory中那些，见下图： 六、Projcet工程菜单 工程菜单在实际使用中比较常用，而且内容相对较多，部分内容也相对较复杂。本章节只概述子菜单主要内容，该系列教程后面还会有多篇文章专门讲述里面详细内容。 Project菜单下的子菜单内容在编辑模式和调试模式下一样，但呈现的状态有差异（有的在编辑模式下不可用，有的在调试模式下不可用）。 1.Add Files：添加文件2.Add Group：添加组3.Import File List：导入文件列表4.Add Project Connection：添加工程链接5.Edit Configurations：编辑配置6.Remove：移除工作空间工程7.Create New Project：创建新项目8.Add Existing Project：添加已存在工程9.Options：目标选项配置 Alt + F710.Version Control System：版本控制系统11.Make：编译工程 F712.Compile：编译文件/组 Ctrl + F713.Rebuild All：重新编译14.Clean：清除编译等中间文件15.Batch Build：构建批处理 F816.C-STAT Static Analysis：静态分析17.Stop Build：停止编译 Ctrl + Break18.Download and Debug：下载并调试 Ctrl + D19.Debug without Downloading：调试（不下载）20.Attach to Running Target：附加运行目标21.Make &amp; Restart Debugger：编译并重新调试 Ctrl + R22.Restart Debugger：重新调试 Ctrl + Shift + R23.Download：下载24.SFR Setup：SFR设置25.Open Device Description File：打开设备描述文件26.Save List of Registers：保存寄存器列表 七、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程03_主窗口、工具栏的概述]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_%E4%B8%BB%E7%AA%97%E5%8F%A3%E3%80%81%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%9A%84%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面 为了让初学者更容易掌握IAR这个工具的相关知识，我先从整体概述，再到具体的细节内容。 本文先概述一下默认主窗口界面， 对 IAR 集成开发环境有一个大概的了解，再次概述其中一个常用的 Toolbar 工具栏。 本文主要概述如下两部分内容： 1.主窗口（Main Window） 2.工具栏（Toolbar） 主工具栏概述 调试工具栏概述 工具栏选项配置 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、主窗口 为了让大家对 IAR 集成开发环境有一个大概的了解，这里先概述一下（IAR 默认编辑状态） 主界面下各个窗口的含义。 说明：IAR的窗口在编辑模式与调试模式下存在一定差异，本章节主要基于【编辑模式】进行简单的概述，里面详细的内容、以及调试模式下的窗口在该系列教材后续会逐步讲述。 打开IAR工程，一般会出现类似下图的主窗口界面，主要包含6个窗口（如下图）。 Menu Bar：菜单栏相信大家对该窗口都不陌生，但凡一个常规一点的软件，都有诸如File文件、 Edit编辑 、 View视图、Help帮助等这样的一栏窗口，这就是菜单栏窗口。该窗口是 IAR 比较重要的一个窗口，包含IAR 几乎所有操作的内容，在编辑模式和调试模式下存在一些不同，后续会讲述。 Tool Bar：工具栏该窗口是一些常见的快捷按钮，本文下面会讲述。 Workspace Window：工作空间窗口一个工作空间可以包含多个工程，该窗口主要显示工作空间下面工程项目的内容（工程、 组、 源代码文件等）。 如上图窗口中包含多个工程（Project1、 Project2······），可以关注后面讲述新建多个工程的文章。 Edit Window：编辑窗口该窗口不用多解释，就是我们平时编辑代码的窗口。 Message Window：信息窗口该窗口包括编译信息、调试信息、查找信息等一些信息的窗口。 Status Bar：状态栏该窗口包含就绪状态、错误警告数量、光标行列、字符编码、键盘Num锁定等一些状态信息。 三、工具栏 IAR的工具栏Tool Bar共有两种：Main主工具栏和Debug调试工具栏。在编辑（默认）状态下只显示Main主工具栏，在进入调试模式后会增加显示Debug工具栏，如下图： 3.1 主工具栏 在编辑（默认）状态下，只有主工具栏，这个工具栏里面内容也是在编辑状态下常用的快捷按钮。当然，这些按钮的功能基本上都可以通过快捷键来实现。 New Document新建文件 Ctrl + NOpen打开文件 Ctrl + OSave保存文件 Ctrl + SSave All保存所有文件Print打印文件 Ctrl + PCut剪切 Ctrl + XCopy复制 Ctrl + CPaste粘贴 Ctrl + VUndo撤销编辑 Ctrl + ZRedo恢复编辑 Ctrl + YQuick Search Text Box快速搜索文本框Find Previous向前查找 Shift + F3Find Next向后查找 F3Find查找（增强） Ctrl + FReplace替换 Ctrl + HGo to前往行列 Ctrl + GToggle Bookmark标记/取消书签 Ctrl + F2Previous Bookmark跳转到上一个书签 Shift + F2Next Bookmark跳转到下一个书签 F2Navigate Backward跳转到上一步 Alt + 左箭头Navigate Forward跳转到下一步 Alt + 右箭头Compile编译当前（文件、组） Ctrl + F7Make编译工程（构建） F7Stop Build停止编译 Ctrl + BreakToggle Breakpoint编辑/取消断点 Ctrl + F9Download and Debug下载并调试 Ctrl + DDebug without Downloading调试（不下载）Toolbar Options工具栏选项（下面3.3节重点讲述） 上面只是简述了各个快捷按钮的基本意思，下面再详细说一下部分常用按钮的具体意思。 A.书签书签在编译的时候比较实用，可以快速找到标记书签所在行。可以使用快捷按钮，当然，平时推荐使用快捷键（F2、 Ctrl + F2、 Shift + F2）。 书签动画效果： B.跳转到上/下一步跳转是在编译代码通过跟踪代码留下的“脚步”，我们可以通过该方式找到这些“脚步”，同样也可以通过快捷键操作。 跳转到上/下一步动画效果： C.下载和调试很多人问“Download and Debug”和“Debug without Downloading”这两个按钮的区别是什么？答：Download and Debug：是下载代码之后再进行调试。Debug without Downloading：只调试不下载。也就是说你之前下载过了代码，只需要再点击该按钮即可，否则会出现错误。 这两个按钮图标在编辑和调试模式下略有点差异，在调试模式下可以再次下载/调试。 3.2 调试工具栏调试工具栏只有在调试状态下才会出现的一行快捷按钮，在编辑状态下，没有这些按钮。 当点击调试按钮，进入调试状态之后，菜单栏会增加一个Debug菜单（里面内容和调试工具栏类似）。同样，工具栏也会增加一个调试工具栏，如下图： 从左往右依次是：Step Over逐行运行 F10Step Into跳入运行 F11Step Out跳出运行 Shift + F11Next Statement运行到下一条语句Run to Cursor运行到光标行Go全速运行 F5Break停止运行Reset复位 逐行运行也叫逐步运行，跳入运行也叫单步运行，运行到下一语句和逐行运行类似。 3.3 工具栏选项配置这一小节主要教大家如何自定义工具栏（图标）按钮。假如我们不想要工具栏中有些按钮（如：复制、粘贴），或我们又想添加一个工具按钮，怎么实现呢？ A.进入自定义工具栏 B.删除工具栏如删除复制按钮：按住复制按钮 -&gt; 拖出工具栏即可。 删除按钮动画效果： C.添加工具按钮如：添加一个工具配置按钮，在命令中找到【工具配置】按钮，按住 -&gt; 拖到工具栏（你想要到位置）即可。 添加按钮动画效果： D.添加显示文本标签显示文本标签，也就是图标下面显示该图标按钮的意思，这样方便一眼明白含义，同时可以增大显示距离，点击操作也比较方便。当然，也会占用一定显示区域。如下图： 显示文本标签动画效果： F.放大图标这个很好理解，图标太小，将其放大，如下图： 放大图标动画效果： 四、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程02_新建基础软件工程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 我们常说的IAR for STM8，其实指的就是EWSTM8，它的全称是IAR Embedded Workbench for STM8。 本文针对初学者，利用EWSTM8集成开发环境，基于STM8S标准外设库新建基础软件工程。（后面会讲述如何新建多工程、多目标） 本文分如下内容来讲述： 1.准备工作 下载安装EWSTM8 下载STM8标准外设库 整理工程文件夹 2.新建软件工程 创建工程 添加文件 配置工程 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、准备工作 俗话说“磨刀不误砍柴工”，做好了准备工作，后面新建基础软件工程的工作就很容易实现了。 2.1 下载安装EWSTM8 详情请参看该系列教程上一篇文章【EWSTM8系列教程01_IAR介绍、下载、安装和注册】。 2.2 下载STM8标准外设库 本文基于STM8标准外设库（STM8S_StdPeriph_Lib）来新建基础软件工程，所以需要下载标准库。如果你不使用标准外设库（如：使用寄存器）开发，本节内容可以略过。 A.官网下载https://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm8-embedded-software/stsw-stm8069.html 提示：在官网下载需要登录账户，如果嫌麻烦可以在ST中文网，或下面百度网盘下载（和官网一样）。 B.百度网盘http://pan.baidu.com/s/1qYbBKMK 提示：如果以上链接失效， 可以关注微信公众号， 获取更新链接。 2.3 整理工程文件夹 这一小节的内容可根据自己习惯来整理，我整理的文件及文件夹结构是按照常规的整理方式。你如果觉得合理，可以直接引用；如果觉得不习惯这个结构方式，可以自己整理。 本节所讲述的文件夹及里面的内容不是本文新建软件工程的重点，若需要详细了解库文件、文件夹及里面源代码内容，可以参看我的另一教程【STM8S标准外设库教程】。 A.新建工程文件夹首先建立一个存放工程文件的文件夹：STM8S_Demo B.提取ST标准外设库文件解压下载的标准外设库（STM8S_StdPeriph_Lib）可以看见下面四个文件夹和参考资料： _htmresc：图片文件夹（不提取）Libraries：标准驱动库（提取大部分）Project： 示例工程（提取少部分）Utilities：公共代码、评估板代码（不提取）MCD-ST Liberty：软件许可协议（不提取）Release_Notes：发行说明stm8s-a_stdperiph_lib_um：库说明文档 ST官网下载的标准外设库里面有很多例程源代码和其他文件，但我们主要使用Libraries目录下STM8S_StdPeriph_Driver源代码，其他参考文件用于开发学习时参考使用。1.拷贝Libraries文件夹到我们的STM8S_Demo工程文件夹下面。2.拷贝STM8S_StdPeriph_Lib\Project\STM8S_StdPeriph_Template下面stm8s_conf.h、stm8s_it.c和stm8s_it.h三个文件到我们STM8S_Demo \ App下面。 C.新建文件夹和文件除了标准外设库文件之外，我们需要新建存放自己代码的文件和文件夹。我这里主要需要新建4个文件夹：App: 应用程序代码Bsp: 底层驱动代码Doc: 说明文档Project：工程文件 在自己新建的文件夹下面还需要新建自己的文件，文件里面添加必要的源代码文件。我提供的Demo工程，实现的功能比较简单，就是一个LED闪烁。本文重点讲述建立工程的过程，这里不描述源代码，具体可以自己下载查看。 上面几个步骤完成之后，我们就可以看到在工程文件夹“STM8S_Demo”下面整理的文件夹（如下图）： 至此，准备工作算完成了，上面提取的文件、新建的文件里面具体的内容请下载Demo工程查看（文末下载）。 三、新建软件工程 新建一个简单、基础的软件工程大概需要有三个步骤：创建工程、添加文件和配置工程。 上面的准备工作做好之后，就可以在Project文件夹下新建自己的软件工程了，下面将一步一步讲述从零开始新建一个软件工程的详细过程。 3.1 创建工程创建工程：就是新建工作空间及工程，步骤比较简单。 A.打开软件，新建工作空间（File -&gt; New Workspace） B.新建工程（Project -&gt;Create New Project） C.创建一个空工程 D.选择保存路径、名称 E.空基础工程 F.保存工作空间（File -&gt; Save Workspace） 至此，一个空的基础工程就创建好了，需要进一步添加文件到工程和配置工程。 3.2 添加文件 准确的来说，是在上面创建的空工程中添加组（文件夹）和添加源代码文件。简单的说，就是将你自己的源代码文件（前面提取的库、新建的文件等）添加到工程中。 这里的工程项目管理可根据自己的想法来定义（类似于自己分类、命名文件夹和文件），我这里按照常规的方式进行管理项目。 为了方便大家理解，我们单级目录方式分组，先在工程中添加组，再在组中添加源代码文件。 A.工程中添加组 B.填写组的名称 C.组中添加文件 D.按住Ctrl，鼠标选中要添加的文件 E.重复上面4个步骤，直到添加完成 3.3 配置工程 配置工程对于初学者来说，大部分内容只需要默认即可，这里只讲述几个常见的配置，能满足基本的功能。更多配置将在该教程后面的文章中讲述。 A.进入配置选项 B.选择器件 C.库配置Library Configration如果需要使用某些标准的库函数接口（如我们使用的printf 、scanf），就需要选择Full（见下图）。 D.预处理Preprocessor（添加路径）添加的路径最好是相对路径，而不是绝对路径。使用绝对路径工程位置改变之后就找不到文件，就会出错。 1.可以点击按钮选择路径；2.或者通过复制文件路径进行配置。 ···直到完成 E.预处理Preprocessor（预定义）这里的预定义类似于在源代码中的#define xxx 这种宏定义。这里的STM8S103可以在stm8s.h中打开即可。 F.输出Hex文件很多初学的朋友都会问怎么输出 Hex（ 可直接下载的程序文件），只需要按照下面配置即可输出Hex文件。 G.选择下载调试工具根据自己情况选择的下载调试工具。 至此，一个基本工程的配置算完成了。如果源代码正确，就可以编译、下载、调试了。 四、下载1.STM8标准外设库百度网盘下载地址：http://pan.baidu.com/s/1qYbBKMK 2.本文完整代码工程（可运行）下载地址：链接：https://pan.baidu.com/s/1MyAOZcOn04AnRq8zNZrL6w密码：3lkl 提示：如果下载链接失效， 可以关注微信公众号， 获取更新链接。 五、说明1.上面新建基础软件工程主要是针对初学者，写的比较基础的。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程01_EWSTM8介绍、下载、安装和注册]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_IAR%E4%BB%8B%E7%BB%8D%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E5%92%8C%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[一、写在前面 我们常说的IAR for STM8，其实指的就是EWSTM8，它的全称是IAR Embedded Workbench for STM8。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、IAR介绍2.1 关于IAR IAR是一家公司的名称，也是一种集成开发环境（IDE）的名称，我们平时所说的IAR主要是指的集成开发环境，当然，我们也称它为一种工具：IAR开发工具。 IAR这家公司的发展也是经历了一系列历史变化，从开始针对8051做C编译器，逐渐发展至今，已经是一家庞大的、技术力量雄厚的公司。而IAR集成开发环境也是从单一到现在针对不同处理器，拥有多种IAR版本的集成开发环境。 IAR针对不同内核处理器，有不同的集成开发环境，本文讲述的只是其中的一款集成开发环境EWSTM8，而IAR拥有多个版本，支持的芯片有上万种，详情请参看官网：https://www.iar.com/device-search/#!?tab=devices 2.2 关于EWSTM8 EWSTM8全称是IAR Embedded Workbench for STM8，其实也是我们常说的IAR for STM8，即（用于开发STM8的）嵌入式工作平台。 Embedded Workbench for STM8是IAR Systems公司为 STM8 微处理器开发的一个集成开发环境(简称IAR EWSTM8，也简称为IAR for STM8)。比较其他的 STM8 开发环境，IAR EWSTM8 具有入门容易、使用方便和代码紧凑等特点。 2.3 EWSTM8支持芯片现在（2018年07月）EWSTM8最新版本V3.10，支持市面上所有的STM8系列芯片，目前有一百多种（184种），具体可以到IAR官方网站查看。 https://www.iar.com/device-search/#!?tab=devices 三、下载EWSTM8这个软件安装包推荐大家到官网下载最新版本。当然，如果你嫌麻烦，也可以到我百度网盘下载（含老版本，定期更新）。 3.1 官方下载目前（2018年07月）EWSTM8官方最新版本是V3.10。下载地址：https://www.iar.com/iar-embedded-workbench/#!?currentTab=free-trials 3.2 网盘下载为了方便大家下载，我将其安装包上传到百度云盘。当然，我会定期更新，里面也包含之前老版本，建议大家下载最新那一个版本。 百度网盘地址：http://pan.baidu.com/s/1slF5kYx 提示：如果网盘链接失效，可以关注微信公众号，获取更新链接。 四、安装 EWSTM8集成开发环境的安装比较简单（基本上就是一路Next下去）。本章节主要针对初学者，按照常规安装教程（图文）讲述一下吧，以下载最新的“EWSTM8-3104-Autorun.exe”软件安装包为例来讲述。 4.1 准备过程A.双击EWSTM8安装包，准备安装 B.选择EWSTM8安装 4.2 安装向导、配置C.进入安装向导 D.选择接受许可 E.选择安装路径 安装路径一般默认，你也可以修改到你指定路径下。 F.选择需要安装的驱动 一般也默认都勾选。提示：这里勾选了的驱动，会在后面安装。默认有多个，所以后面会安装多个。 G.选择安装文件夹 默认新建一个文件夹。 4.3 安装EWSTM8H.安装准备就绪 如果准备好之后，点击Install进入安装过程。如果前面配置不对，可以点击Back返回修改。 I.等待安装完成 4.4 安装驱动EWSTM8安装完成之后，接下来就是安装驱动，如果上面勾选多个，那么这里就会弹出多个驱动等待安装（与上面配置有关）。 J.安装驱动提示 K.准备安装过程 L.安装ST-Link···这里会安装多个驱动，大致都差不多，根据提示操作就行。··· M.安装完成 安装完成之后，可能会弹出注册许可向导（License Wizard），此时，选择取消 -&gt; 确定就行。 五、注册EWSTM8是一款收费的商业软件，若你用于商业请购买正版。如果是个人学习，可以使用官方30天的免费试用版本。 本文主要针对个人学习的朋友而言，进行非商业用途的使用。以下所有注册信息来自网络，如有侵权，请联系作者删除。 上面百度网盘提供下载的地址里面有一个“IAR注册机.zip”压缩文件，本章将利用该注册机进行注册。 IAR的注册过程有点绕，先讲一下主要步骤：打开IAR软件 -&gt; 注册界面 -&gt; 到输入许可号 -&gt; 转到注册机（获取许可号） -&gt; 回来粘贴许可号 -&gt; 保存激活信息 -&gt; 到等待激活 - &gt; 转到注册机（利用激活信息）生成激活文件 -&gt; 回来打开激活文件注册 -&gt; 成功。 5.1 打开软件 -&gt; 进入注册许可管理界面A.打开安装好的EWSTM8软件：Help -&gt; License Manager进入许可管理 B.弹出许可向导：1取消 -&gt; 2确定即可 C.进入许可管理 此时，看到有个红色的“×”，说明未注册。 5.2 打开离线激活 -&gt; 得到并粘贴许可号D.离线激活方式： License -&gt; Offline Activation 进入离线激活界面 E.打开注册机获取注册号 (1)选择IAR类型（STM8）； (2)获取许可号； (3)复制许可号 F.粘贴许可号 5.3 保存激活信息 -&gt; 到等待激活G.生成并保存激活信息ActivationInfo.txt H.进入等待激活界面 5.4 生成激活文件 -&gt; 激活I.生成激活文件 转到注册机：(1)打开前面（路径下）生成的激活信息文件(2)点击激活 -&gt; 保存激活文件（ActivationResponse.txt）到相同路径下。 J.激活 -&gt; 完成 K.弹出提示 L.查看状态 至此，注册已经完成了。 六、说明1.该文档仅供个人学习使用，版权所有，禁止商用。2.本文主要针对个人学习使用的朋友，若你是商业用途，建议购买正版软件。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F%E8%AF%B4%E6%98%8E%E6%96%87%E7%AB%A0%2F%E5%85%AC%E5%91%8A.html</url>
    <content type="text"><![CDATA[一、博客搬家了 欢迎您来到我个人的新博客网站：http://www.strongerhuang.com 在这里，我会以专栏形式分享。当然，更多精彩内容我会在我的个人公众号「strongerHuang」分享。 1.1 原CSDN博客 由于我原来的【CSDN博客】文章比较杂乱，也没有整理归类，不方便查找，文章中提供的代码工程下载地址都失效了。还有个主要原因，在别人地盘写文章总觉得不爽。所以，决定自己搭建博客，在自己的地盘写出属于自己的博客文章。 我的CSDN博客目前没有更新文章了，最后一次更新文章应该是停留在去年八九月份的样子，所以那个时候都有计划搭建属于自己的博客了。后续可能很少在CSDN上面更新文章了（兴许哪一天高兴了，会整理一下CSDN博客）。 原CSDN博客主页：https://blog.csdn.net/ybhuangfugui 1.2 我的新博客 其实，我去年就打算自己搭建博客，但是由于工作原因，没有足够的时间（自己搭建博客也是挺折腾的），一直耽搁了。直到今年，终于狠下心，搭建成功了属于自己的个人博客网站。 个人新博客主页：http://www.strongerhuang.com 二、后续计划 我的博客文章正在努力更新中。。。关注我微信公众号：strongerhuang，随时获取最新资讯。]]></content>
      <categories>
        <category>说明文章</category>
      </categories>
      <tags>
        <tag>说明</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
