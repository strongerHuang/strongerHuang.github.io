<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EmbeddedDevelop</title>
  
  <subtitle>作者：strongerHuang</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.strongerhuang.com/"/>
  <updated>2018-10-11T01:12:01.772Z</updated>
  <id>http://www.strongerhuang.com/</id>
  
  <author>
    <name>strongerHuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CANOpen系列教程</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程.html</id>
    <published>2018-10-11T01:30:00.000Z</published>
    <updated>2018-10-11T01:12:01.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　本文对【CANOpen系列教程】做了整理并汇总，会随着该系列教程的更新而更新。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><a id="more"></a><h1 id="二、教程列表"><a href="#二、教程列表" class="headerlink" title="二、教程列表"></a>二、教程列表</h1><p><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_%E5%88%9D%E8%AF%86CAN%E4%B8%8ECANOpen%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html">1.CANOpen系列教程01_初识CAN与CANOpen及相关内容</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE.html">2.CANOpen系列教程02_理解CAN总线协议</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8.html">3.CANOpen系列教程03_CAN收发器功能、原理及作用</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html">4.CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A.html">5.CANOpen系列教程05_CAN总线同步与位填充、优先级的决定</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89.html">6.CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）</a><br><a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html">7.CANOpen系列教程07_CANOpen协议概述</a></p><p>正在努力更新中，敬请等待……</p><h1 id="三、说明"><a href="#三、说明" class="headerlink" title="三、说明"></a>三、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　本文对【CANOpen系列教程】做了整理并汇总，会随着该系列教程的更新而更新。&lt;/p&gt;
&lt;p&gt;　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于&lt;a href=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信公众号【EmbeddedDevelop】&lt;/a&gt;，关注微信公众号回复【CANOpen系列教程】即可查看。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程07_CANOpen协议概述</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程07_CANOpen协议概述.html</id>
    <published>2018-10-11T01:00:00.000Z</published>
    <updated>2018-10-11T01:20:05.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　上一章节提供的例程是标准、数据帧格式的传输例程，结合前面理论知识，相信你根据参考例程可以实现远程帧及其他类型的数据传输。</p><p>　　<strong>前面教程讲述内容为CAN总线协议，属于底层硬件相关的一些内容</strong>。从本文开始，将正式讲述CANOpen协议。</p><p>　　CANOpen协议是基于CAN总线的上一层软件协议。该教程前面内容是建立底层通信，只有在底层通信成功基础上，才能实现上一层的通信协议。</p><p>　　<strong>提示</strong>：CANOpen协议内容很多，有许多内容都是一些抽象的概念。所以，有一些内容相对较难理解，随着慢慢深入即可消除那些疑虑。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、CANopen协议总述"><a href="#二、CANopen协议总述" class="headerlink" title="二、CANopen协议总述"></a>二、CANopen协议总述</h1><p>CANopen 是一个基于 CAN 串行总线的网络传输系统的应用层协议，遵循 ISO/OSI 标准模型。</p><p>网络中不同的设备通过对象字典或者对象来相互交换数据，其中，主节点可以通过过程数据对象 (PDO) 或者服务数据对象 (SDO) 来获取或者修改其它节点对象字典列表中的数据。</p><p>CANOpen协议主要内容分为三大块，如下图CANopen 的设备模型。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/1.%20CANopen%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B.png?raw=true"><br></table><p>CANOpen协议从大方向的划分，就如上图所示三大块。但是，这三大块里面的内容就牵涉到许多……</p><p>初学者可以以上图模型为中心，再结合实际例程理解CANOpen协议的各种抽象概念。</p><p>下面章节将进一步讲述模型中三大块内容的一些概念，初学者能理解尽量理解，不能理解可以先做了解即可。</p><h1 id="三、通信对象"><a href="#三、通信对象" class="headerlink" title="三、通信对象"></a>三、通信对象</h1><p>CANopen协议中常用的通信对象包含如下几点：</p><h2 id="1）-网络管理对象-NMT"><a href="#1）-网络管理对象-NMT" class="headerlink" title="1） 网络管理对象(NMT)"></a>1） 网络管理对象(NMT)</h2><p>网络管理对象包括 Boot-up 消息， Heartbeat 协议及 NMT 消息，基于主从通信模式， NMT 用于管理和监控网络中的各个节点，主要实现三种功能：节点状态控制、错误控制和节点启动。</p><h2 id="2）-服务数据对象-SDO"><a href="#2）-服务数据对象-SDO" class="headerlink" title="2） 服务数据对象 (SDO)"></a>2） 服务数据对象 (SDO)</h2><p><strong>·</strong>包括接收 SDO(R-SDO) 和发送 SDO(T-SDO)。<br><strong>·</strong>通过使用索引和子索引， SDO 使客户机能够访问设备对象字典中的项。<br><strong>·</strong>SDO 通过 CAL 中多元域的 CMS 对象来实现，允许传送任何长度的数据，当数据超过 4 个字节时分拆成几个报文。<br><strong>·</strong>协议是确认服务类型，为每个消息生成一个应答。 SDO 请求和应答报文总是包含 8 个字节。</p><h2 id="3）-过程数据对象-PDO"><a href="#3）-过程数据对象-PDO" class="headerlink" title="3） 过程数据对象(PDO)"></a>3） 过程数据对象(PDO)</h2><p><strong>·</strong>包括接收 PDO(RPDO) 和发送 PDO(TPDO)。<br><strong>·</strong>用来传输实时数据，数据从一个创建者传到一个或多个接收者。数据传送限制在 1 到 8 个字节。<br><strong>·</strong>每个 CANopen 设备包含 8 个缺省的 PDO 通道， 4 个发送 PDO 通道和 4 个接收 PDO 通道。<br><strong>·</strong>PDO 包含同步和异步两种传输方式，由该 PDO 对应的通信参数决定。<br><strong>·</strong>PDO 消息的内容是预定义的，由该 PDO 对应的映射参数决定。</p><h2 id="4）-同步对象-SYNC"><a href="#4）-同步对象-SYNC" class="headerlink" title="4） 同步对象 (SYNC)"></a>4） 同步对象 (SYNC)</h2><p>同步对象是由 CANopen 主站周期性地广播到 CAN 总线的报文，用来实现基本的网络时钟信号，每个设备可以根据自己的配置，决定是否使用该事件来跟其它网络设备进行同步通信。</p><h2 id="5）-紧急报文-EMCY"><a href="#5）-紧急报文-EMCY" class="headerlink" title="5） 紧急报文 (EMCY)"></a>5） 紧急报文 (EMCY)</h2><p>设备内部通信故障或者应用故障错误时发送的报文。</p><h1 id="四、对象字典"><a href="#四、对象字典" class="headerlink" title="四、对象字典"></a>四、对象字典</h1><p>对象字典是设备规范中最重要的部分。它是一组参数和变量的有序集合，包含了设备描述及设备网络状态的所有参数。</p><p>通过网络可以采用有序的<strong>预定义的方式</strong>来访问的一组对象。这里就牵涉到定义对象字典的生成问题，后面我会讲述关于对象字典生成工具相关内容。</p><p><strong>CANopen 协议采用了带有 16 位索引和 8 位子索引的对象字典</strong>。你可以理解为一本汉语字典，我们需要查找里面的某个汉子（可以理解定义的某个数据），我们就会从拼音或笔画（索引）进去找到对应位置。</p><p>CANOpen 协议对象字典主索引如下图，这只是一个主要的索引。其实还能细分下去，这里不过多讲述，后续会进一步讲述。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/2.%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8%E4%B8%BB%E7%B4%A2%E5%BC%95.png?raw=true"><br></table><h1 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h1><p>应用这一块的内容包含应用程序、设备子协议实现。可以从CANopen 的设备模型明白，对外就是IO接口，也就是供我们调用的接口。</p><p>应用这一块包含CANOpen协议上层的内容，可以简单理解封装的一些供用户读写操作的函数。</p><p>应用这一块内容在后面结合实例分析会牵涉，初学者可以简单了解有这么一块，且知道这一块在CANOpen协议中大致的作用即可。</p><h1 id="六、说明"><a href="#六、说明" class="headerlink" title="六、说明"></a>六、说明</h1><p>1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　上一章节提供的例程是标准、数据帧格式的传输例程，结合前面理论知识，相信你根据参考例程可以实现远程帧及其他类型的数据传输。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;前面教程讲述内容为CAN总线协议，属于底层硬件相关的一些内容&lt;/strong&gt;。从本文开始，将正式讲述CANOpen协议。&lt;/p&gt;
&lt;p&gt;　　CANOpen协议是基于CAN总线的上一层软件协议。该教程前面内容是建立底层通信，只有在底层通信成功基础上，才能实现上一层的通信协议。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;提示&lt;/strong&gt;：CANOpen协议内容很多，有许多内容都是一些抽象的概念。所以，有一些内容相对较难理解，随着慢慢深入即可消除那些疑虑。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）.html</id>
    <published>2018-10-08T09:00:00.000Z</published>
    <updated>2018-10-11T01:19:34.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　该教程前面讲述了许多关于CAN协议的一些概念，可能许多初学者看的云里雾里，那么本文将结合代码让大家理解之前讲述的内容。</p><p>　　因为关注我的人大部分都在学习STM32，我将结合STM32F103、标准外设库例程来让大家理解之前讲述的一些概念。</p><p>　　本文主要讲述内容：<br>　　<strong>·1.传输数据相关参数</strong><br>　　<strong>·2.位时序及传输波特率</strong></p><p>　　为方便大家理解，我将在最后提供对应例程「CANOpen系列教程06_CAN底层收发例程」。当然，本文只讲述代码中部分内容，某些配置参数放在后面讲述。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、传输数据相关参数"><a href="#二、传输数据相关参数" class="headerlink" title="二、传输数据相关参数"></a>二、传输数据相关参数</h1><p>传输数据相关参数其实主要就是前面<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html">《CANOpen系列教程04》</a>讲述的“帧类型及格式说明”那一章节内容，建议先看下那些概念内容。</p><p>CAN总线传输的内容主要就是发送和接收，下面我将结合代码中发送和接收参数来让大家理解我们编程控制CAN总线上那些参数。</p><h2 id="2-1-CAN总线数据帧"><a href="#2-1-CAN总线数据帧" class="headerlink" title="2.1 CAN总线数据帧"></a>2.1 CAN总线数据帧</h2><p>本文提供例程主要是CAN总线使用最多的数据帧为例，让大家理解数据帧传输由我们编程控制的参数。</p><p>先看下图回顾一下数据帧格式，其中有些字段内容由控制器自动完成，如：帧起始，CRC校验。而有些就是由我们编程控制，如：ID、数据等。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/1.%E6%95%B0%E6%8D%AE%E5%B8%A7.png?raw=true"><br></table><h2 id="2-2-CAN发送代码"><a href="#2-2-CAN发送代码" class="headerlink" title="2.2 CAN发送代码"></a>2.2 CAN发送代码</h2><p><strong>A.CAN发送数据结构</strong><br>下图主要就是CAN发送由我们编程控制的参数。其实你会发现，主要就是上面帧格式中部分内容：ID、IDE、RTR、DLC、Data。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/2.CanTxMsg%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p><strong>B.发送配置参数</strong><br>下图为实际发送配置的参数。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/3.%E5%8F%91%E9%80%81%E5%8F%82%E6%95%B0.png?raw=true"><br></table><h2 id="2-3-CAN接收代码"><a href="#2-3-CAN接收代码" class="headerlink" title="2.3 CAN接收代码"></a>2.3 CAN接收代码</h2><p>CAN接收其实和发送类似，CAN总线上的字段就那些，在接收端接收的那些参数无非就是发送端发送出来的那些参数。<br>针对STM32内部集成的CAN，接收数据结构多了一个FMI参数，大概意思就是接收消息邮箱筛选器索引。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/4.CanRxMsg%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p><strong>接收操作</strong><br>为方便初学者理解，这里这要就是使用中断接收CAN总线数据，在中断函数里面打印也主要是用于测试，一般实际项目打印不会出现在中断函数（打印相对耗时）。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/5.%E4%B8%AD%E6%96%AD%E6%8E%A5%E6%94%B6.png?raw=true"><br></table><h1 id="三、位时序及传输波特率"><a href="#三、位时序及传输波特率" class="headerlink" title="三、位时序及传输波特率"></a>三、位时序及传输波特率</h1><p>同样，在前面<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html">《CANOpen系列教程04》</a>中有讲述“位时序及传输波特率”的概念。其实，位时序间接决定了传输的波特率。换句话说，传输的波特率由位时序几个参数决定。</p><p>看下图，回顾一下波特率计算公式：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/6.%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png?raw=true"><br></table><h2 id="3-1-波特率配置代码"><a href="#3-1-波特率配置代码" class="headerlink" title="3.1 波特率配置代码"></a>3.1 波特率配置代码</h2><p>结合上图计算公式和下图代码，可以看出位时序中几个参数和波特率的关系。波特率为1M时，几个位时序参数可以配置为如下图值：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89/7.%E6%B3%A2%E7%89%B9%E7%8E%87%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81.png?raw=true"><br></table><p><strong>提示：</strong><br>36M代表CAN时钟，具体要看时钟相关配置。</p><p>波特率固定，位时序参数可以不同。比如波特率固定为1M，位时序参数可以为上图配置；也可以修改其中的值，如修改位段1为CAN_BS1_5tq，位段2为CAN_BS2_3tq。只要遵循波特率计算公式即可。</p><h1 id="四、例程下载"><a href="#四、例程下载" class="headerlink" title="四、例程下载"></a>四、例程下载</h1><p>CANOpen系列教程06_CAN底层收发例程：<br><a href="https://pan.baidu.com/s/1LzD0Epc-Z8vlHsb-sD3WVw" target="_blank" rel="noopener">https://pan.baidu.com/s/1LzD0Epc-Z8vlHsb-sD3WVw</a><br>提取码：l2dc</p><p><strong>提示：</strong><br>    链接后期可能会失效，可关注公众号回复【CANOpen系列教程】查看更新链接。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　该教程前面讲述了许多关于CAN协议的一些概念，可能许多初学者看的云里雾里，那么本文将结合代码让大家理解之前讲述的内容。&lt;/p&gt;
&lt;p&gt;　　因为关注我的人大部分都在学习STM32，我将结合STM32F103、标准外设库例程来让大家理解之前讲述的一些概念。&lt;/p&gt;
&lt;p&gt;　　本文主要讲述内容：&lt;br&gt;　　&lt;strong&gt;·1.传输数据相关参数&lt;/strong&gt;&lt;br&gt;　　&lt;strong&gt;·2.位时序及传输波特率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为方便大家理解，我将在最后提供对应例程「CANOpen系列教程06_CAN底层收发例程」。当然，本文只讲述代码中部分内容，某些配置参数放在后面讲述。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程05_CAN总线同步与位填充、优先级的决定</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程05_CAN总线同步与位填充、优先级的决定.html</id>
    <published>2018-09-27T01:00:00.000Z</published>
    <updated>2018-09-27T01:27:19.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　继续为大家更新CAN总线协议相关内容，这些内容其实也比较重要，会直接影响到你后期CAN总线的编程，夸张一点的说会影响到你的软件架构。</p><p>　　本文内容相对来说比较容易理解，初学者有必要了解一下。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、位填充"><a href="#二、位填充" class="headerlink" title="二、位填充"></a>二、位填充</h1><p>位填充是<strong>为防止突发错误而设定的功能</strong>。当同样的电平持续 5 位时则添加一个位的反型数据。</p><p>这个功能很好理解，如下图所示。<strong>位填充的数据不需要编程控制，由控制器自动完成</strong>。其目的也是提高CAN总线的稳定性。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A/1.%E4%BD%8D%E5%A1%AB%E5%85%85.png?raw=true"><br></table><p><strong>(1) 发送单元的工作</strong><br>在发送数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，在下一个位（第 6 个位）则要插入 1 位与前 5 位反型的电平。</p><p><strong>(2) 接收单元的工作</strong><br>在接收数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，需要删除下一个位（第 6 个位）再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送错误帧。</p><h1 id="三、优先级的决定"><a href="#三、优先级的决定" class="headerlink" title="三、优先级的决定"></a>三、优先级的决定</h1><p>前面讲述“CAN 总线差分信号”时描述了显性和隐性，其实这是CAN总线的特点，也是决定CAN总线优先级比较重要的功能。</p><p>在CAN总线空闲态，最先开始发送消息的单元获得发送权。</p><p><strong>多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁</strong>。连续输出显性电平最多的单元可继续发送。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A/2.%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81.png?raw=true"><br></table><p>上图描述了CAN控制仲裁的过程，单元2最终获得了抢占CAN总线的权利，也就是说单元2具有更高的优先级。</p><p>当单元1 仲裁失利时，自动转换为接收（本来该发送，优先级比别人低，就开始接收数据了。 同时，控制器将会在下一轮继续发送这次未完成的数据）。</p><h2 id="3-1-数据帧和遥控帧的优先级"><a href="#3-1-数据帧和遥控帧的优先级" class="headerlink" title="3.1 数据帧和遥控帧的优先级"></a>3.1 数据帧和遥控帧的优先级</h2><p>具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</p><p>数据帧和遥控帧的仲裁过程如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A/3.%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%92%8C%E9%81%A5%E6%8E%A7%E5%B8%A7%E7%9A%84%E4%BB%B2%E8%A3%81%E8%BF%87%E7%A8%8B.png?raw=true"><br></table><h2 id="3-2-标准格式和扩展格式的优先级"><a href="#3-2-标准格式和扩展格式的优先级" class="headerlink" title="3.2 标准格式和扩展格式的优先级"></a>3.2 标准格式和扩展格式的优先级</h2><p>标准格式 ID 与具有相同 ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR 位为显性位的具有优先权，可继续发送。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A/4.%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E4%B8%8E%E6%89%A9%E5%B1%95%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BB%B2%E8%A3%81%E8%BF%87%E7%A8%8B.png?raw=true"><br></table><p><strong>提示：</strong><br>不明白数据帧和遥控帧，标准格式和扩展格式之间差异的朋友，建议参看我上一篇文章<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html">《CANOpen系列教程04》</a>。</p><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><p>CAN总线协议的重要内容在这前面基本是讲述的差不多了，还有一些不是很重要的内容，比如硬件设计需要在CAN_H和CAN_L之间添加一个120欧电阻，总线的传输距离等。</p><p>接下来的文章会结合STM32芯片集成CAN控制器、例程讲述如何编程控制CAN总线数据的收发等。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　继续为大家更新CAN总线协议相关内容，这些内容其实也比较重要，会直接影响到你后期CAN总线的编程，夸张一点的说会影响到你的软件架构。&lt;/p&gt;
&lt;p&gt;　　本文内容相对来说比较容易理解，初学者有必要了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明.html</id>
    <published>2018-09-22T08:00:00.000Z</published>
    <updated>2018-09-22T08:31:43.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　上一篇文章讲述了<strong>CAN收发器</strong>的重要作用，也提及了一下CAN总线的优势主要在于<strong>CAN控制器</strong>。CAN控制器在CAN网络中所处的位置如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/1.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p>　　本文讲述的CAN控制器实现的几个重要功能：<strong>CAN总线波特率、位时序、帧类型</strong>。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、CAN总线波特率"><a href="#二、CAN总线波特率" class="headerlink" title="二、CAN总线波特率"></a>二、CAN总线波特率</h1><p>CAN总线属于异步通信，因此就有通信波特率，而这个波特率发生器就位于CAN控制器内部。我们不需要了解它是如何产生的，但需要了解它的含义。这章节针对初学者讲述以下两点内容。</p><h2 id="2-1-异步通信"><a href="#2-1-异步通信" class="headerlink" title="2.1 异步通信"></a>2.1 异步通信</h2><p>在串行通信中，主要分<strong>异步通信和同步通信</strong>。</p><p><strong>同步通信</strong>：通信设备之间通过同步信号（CLK时钟）来实现数据传输的通信叫同步通信。如I2C、SPI这类通信中都具有一个时钟信号，其实在STM32中USART也具有同步功能，只是我们大多数人都只用了它的异步功能。</p><p><strong>异步通信</strong>：简单来说，就是通信设备之间通过约定一样的时间来收发数据。而这个时间就会决定本节说的波特率。</p><h2 id="2-2-波特率"><a href="#2-2-波特率" class="headerlink" title="2.2 波特率"></a>2.2 波特率</h2><p>很多工程师一直都没彻底搞明白什么是波特率，我这里还是结合UART波特率来简述一下其含义。</p><p>在电子通信领域，波特（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，<strong>1波特即指每秒传输1个符号</strong>。</p><p>UART每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的<strong>波特率为240Bd，比特率为10位*240个/秒=2400bps</strong>。</p><p>从上面的描述可以总结：<br><strong>比特率</strong>：即单位时间内传送的二进制位数；</p><p><strong>波特率</strong>：即单位时间内传输的符号个数；</p><p>只有在每个符号只代表一个比特信息的情况下，波特率与比特率才在数值上相等，但是它们的意义并不相同。</p><h1 id="三、位时序"><a href="#三、位时序" class="headerlink" title="三、位时序"></a>三、位时序</h1><p>上一章节讲述了波特率，而<strong>决定波特率大小的就是本节说的位时序</strong>。在CAN标准中一个位可分为4段：<br><strong>·同步段（SS）</strong><br><strong>·传播时间段（PTS）</strong><br><strong>·相位缓冲段1（PBS1）</strong><br><strong>·相位缓冲段2（PBS2）</strong></p><p>这些段又由可称为 Time Quantum（简称Tq）的最小时间单位构成。</p><p>1位分为4个段，每个段又由若干个Tq构成，这称为位时序。</p><p>而在STM32参考手册中，将位时序分为三段，但它将它传播段和位段1合并在一起了，如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/2.STM32%E4%BD%8D%E6%97%B6%E5%BA%8F.png?raw=true"><br></table><p>1位由多少个Tq构成、每个段又由多少个Tq构成等，可任意设定位时序。通过设定位时序，<strong>决定传输的波特率</strong>：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/3.%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png?raw=true"><br></table><p>这几个参数会在以后编程中进行配置，从而决定通信的波特率。</p><p>关于同步，还有硬件同步、再同步等操作。但初学者可以不必过多理解，掌握上面基础内容就行了。更多关于位时序的内容可以参看 ISO 11898 标准。</p><h1 id="四、帧类型及格式说明"><a href="#四、帧类型及格式说明" class="headerlink" title="四、帧类型及格式说明"></a>四、帧类型及格式说明</h1><p>CAN总线是通过以下5种类型的帧进行通信：<br><strong>数据帧</strong>：用于发送单元向接收单元传送数据的帧。<br><strong>遥控帧</strong>：用于接收单元向具有相同 ID 的发送单元请求数据的帧。<br><strong>错误帧</strong>：用于当检测出错误时向其它单元通知错误的帧。<br><strong>过载帧</strong>：用于接收单元通知其尚未做好接收准备的帧。<br><strong>帧间隔</strong>：用于将数据帧及遥控帧与前面的帧分离开来的帧。</p><p><strong>数据帧和遥控帧</strong>有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。</p><h2 id="4-1-数据帧"><a href="#4-1-数据帧" class="headerlink" title="4.1 数据帧"></a>4.1 数据帧</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/4.%E6%95%B0%E6%8D%AE%E5%B8%A7.png?raw=true"><br></table><p>如上图，数据帧由7个段构成：<br><strong>(1) 帧起始</strong><br>表示数据帧开始的段。<br><strong>(2) 仲裁段</strong><br>表示该帧优先级的段。<br><strong>(3) 控制段</strong><br>表示数据的字节数及保留位的段。<br><strong>(4) 数据段</strong><br>数据的内容，可发送 0～8 个字节的数据。<br><strong>(5) CRC 段</strong><br>检查帧的传输错误的段。<br><strong>(6) ACK 段</strong><br>表示确认正常接收的段。<br><strong>(7) 帧结束</strong><br>表示数据帧结束的段。</p><p>理解数据帧的含义，请从认真理解它的定义：用于发送单元向接收单元传送数据的帧。</p><p>一般的CAN总线通信，总线上通信绝大部分时候都是数据帧。像在CANOpen协议中，用的最多的PDO过程数据对象就是通过数据帧进行的通信。</p><p>初学者可以先理解数据帧，然后其他就容易理解了。下面再来讲述一下<strong>数据帧7段的详情</strong>。</p><h3 id="4-1-1-帧起始"><a href="#4-1-1-帧起始" class="headerlink" title="4.1.1 帧起始"></a>4.1.1 帧起始</h3><p>标准和扩展格式相同。表示帧开始的段，1个位的显性位（如下图）：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/5.%E8%B5%B7%E5%A7%8B%E6%AE%B5.png?raw=true"><br></table><p>关于显性和隐性电平，请参看我上一篇文章差分信号章节。</p><p><strong>总线上的电平有显性电平和隐性电平两种</strong>。<br>总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。</p><p>“显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平。并且，“隐性”具有“包容”的意味，<strong>只有所有的单元都输出隐性电平，总线上才为隐性电平</strong>。（显性电平比隐性电平更强）</p><h3 id="4-1-2-仲裁段"><a href="#4-1-2-仲裁段" class="headerlink" title="4.1.2 仲裁段"></a>4.1.2 仲裁段</h3><p>标准格式和扩展格式在此的构成有所不同。仲裁段表示该帧优先级的段，扩展格式多了18位ID（如下图）：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/6.%E4%BB%B2%E8%A3%81%E6%AE%B5.png?raw=true"><br></table><p>RTR = 0代表数据帧，RTR = 1代表远程帧。</p><p>为什么叫仲裁段，就是通过ID来判断总线上哪一个节点具有优先发送的权利。ID越小（0代表显性），优先级越高。</p><h3 id="4-1-3-控制段"><a href="#4-1-3-控制段" class="headerlink" title="4.1.3 控制段"></a>4.1.3 控制段</h3><p>标准和扩展格式的构成有所不同。控制段由 6 个位构成（如下图）：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/7.%E6%8E%A7%E5%88%B6%E6%AE%B5.png?raw=true"><br></table><p>它们除了都有4位表示数据段长度代码（DLC）外，标准帧有IDE（数值为0）位和r0保留位，扩展帧有r0和r1保留位。</p><p>保留位必须全部以显性电平发送。但接收方可以接收显性、隐性及其任意组合的电平。</p><h3 id="4-1-4-数据段"><a href="#4-1-4-数据段" class="headerlink" title="4.1.4 数据段"></a>4.1.4 数据段</h3><p>标准和扩展格式相同。数据段表示传输数据的内容，从 MSB（最高位）开始输出，可发送 0～8 个字节的数据，长度由前面控制段决定。</p><h3 id="4-1-5-CRC段"><a href="#4-1-5-CRC段" class="headerlink" title="4.1.5 CRC段"></a>4.1.5 CRC段</h3><p>标准和扩展格式相同。CRC段是检查帧传输错误的帧，由 15 个位的 CRC 顺序和 1 个位的 CRC 界定符（用于分隔的位）构成。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/8.CRC%E6%AE%B5.png?raw=true"><br></table><p>相比485这类通信，CAN控制器就已经把CRC校验做了，不需要你的程序再次去计算，从而节约了处理器资源。</p><h3 id="4-1-6-ACK段"><a href="#4-1-6-ACK段" class="headerlink" title="4.1.6 ACK段"></a>4.1.6 ACK段</h3><p>标准和扩展格式相同。ACK段用来确认是否正常接收。由 ACK 槽(ACK Slot)和 ACK 界定符 2 个位构成。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/9.ACK%E6%AE%B5.png?raw=true"><br></table><p>A.发送单元在 ACK 段发送 2 个位的隐性位。<br>B.接收到正确消息的单元在 ACK 槽(ACK Slot)发送显性位， 通知发送单元正常接收结束。这称作“发送 ACK”或者“返回 ACK”。</p><h3 id="4-1-7-帧结束"><a href="#4-1-7-帧结束" class="headerlink" title="4.1.7 帧结束"></a>4.1.7 帧结束</h3><p>标准和扩展格式相同。帧结束是表示该该帧的结束的段。由 7 个位的隐性位构成。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/10.%E5%B8%A7%E7%BB%93%E6%9D%9F.png?raw=true"><br></table><h2 id="4-2-遥控帧"><a href="#4-2-遥控帧" class="headerlink" title="4.2 遥控帧"></a>4.2 遥控帧</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/11.%E9%81%A5%E6%8E%A7%E5%B8%A7.png?raw=true"><br></table><p>和数据帧相比，遥控帧是接收单元向发送单元请求发送数据所用的帧。所以，遥控帧没有数据段。因此，遥控帧由如下 6 个段组成：<br><strong>(1) 帧起始（SOF）</strong><br>表示帧开始的段。<br><strong>(2) 仲裁段</strong><br>表示该帧优先级的段。可请求具有相同 ID 的数据帧。<br><strong>(3) 控制段</strong><br>表示数据的字节数及保留位的段。<br><strong>(4) CRC 段</strong><br>检查帧的传输错误的段。<br><strong>(5) ACK 段</strong><br>表示确认正常接收的段。<br><strong>(6) 帧结束</strong><br>表示遥控帧结束的段。</p><p>这6个段和上面数据帧的内容基本一样，这里就不一一讲述了。讲一下遥控帧和数据帧的区别：<br><strong>遥控帧的 RTR 位为隐性位，没有数据段。</strong><br><strong>没有数据段的数据帧和遥控帧可通过 RTR 位区别开来。</strong></p><p><strong>问题一：遥控帧没有数据段，数据长度码该如何表示？</strong><br>遥控帧的数据长度码以所请求数据帧的数据长度码表示。</p><p><strong>问题二：没有数据段的数据帧有何用途？</strong><br>例如，可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。</p><h2 id="4-3-错误帧"><a href="#4-3-错误帧" class="headerlink" title="4.3 错误帧"></a>4.3 错误帧</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/12.%E9%94%99%E8%AF%AF%E5%B8%A7.png?raw=true"><br></table><p>用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。</p><p><strong>(1) 错误标志</strong><br>错误标志包括主动错误标志和被动错误标志两种。<br>主动错误标志： 6 个位的显性位。<br>被动错误标志： 6 个位的隐性位。</p><p><strong>(2) 错误界定符</strong><br>错误界定符由 8 个位的隐性位构成。</p><h2 id="4-4-过载帧"><a href="#4-4-过载帧" class="headerlink" title="4.4 过载帧"></a>4.4 过载帧</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/13.%E8%BF%87%E8%BD%BD%E5%B8%A7.png?raw=true"><br></table><p>过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。<br><strong>(1) 过载标志</strong><br>6 个位的显性位。<br>过载标志的构成与主动错误标志的构成相同。</p><p><strong>(2) 过载界定符</strong><br>8 个位的隐性位。<br>过载界定符的构成与错误界定符的构成相同。</p><h2 id="4-5-帧间隔"><a href="#4-5-帧间隔" class="headerlink" title="4.5 帧间隔"></a>4.5 帧间隔</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/14.%E5%B8%A7%E9%97%B4%E9%9A%94.png?raw=true"><br></table><p>帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</p><p>过载帧和错误帧前不能插入帧间隔。</p><p><strong>(1) 间隔</strong><br>3 个位的隐性位。</p><p><strong>(2) 总线空闲</strong><br>隐性电平，无长度限制（0 亦可）。<br>本状态下，可视为总线空闲，要发送的单元可开始访问总线。</p><p><strong>(3) 延迟传送（发送暂时停止）</strong><br>8 个位的隐性位。<br>只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　上一篇文章讲述了&lt;strong&gt;CAN收发器&lt;/strong&gt;的重要作用，也提及了一下CAN总线的优势主要在于&lt;strong&gt;CAN控制器&lt;/strong&gt;。CAN控制器在CAN网络中所处的位置如下图：&lt;/p&gt;
&lt;table&gt;&lt;br&gt;&lt;img align=&quot;left&quot; width=&quot;600&quot; src=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E/1.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true&quot;&gt;&lt;br&gt;&lt;/table&gt;

&lt;p&gt;　　本文讲述的CAN控制器实现的几个重要功能：&lt;strong&gt;CAN总线波特率、位时序、帧类型&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程03_CAN收发器功能、原理及作用</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程03_CAN收发器功能、原理及作用.html</id>
    <published>2018-09-20T09:00:00.000Z</published>
    <updated>2018-09-20T09:05:04.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　前面文章是从大方向介绍了CAN网络，让大家对CAN网络有一定的认识。本文将范围缩小，讲述整个CAN网络<strong>其中的一个CAN收发器</strong>。如下图标记出来的部分：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8/1.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p>　　本文结合众多初学者容易产生的疑问来讲述CAN收发器相关的知识点，大概有如下几点：<br>　　<strong>·什么是CAN收发器？</strong><br>　　<strong>·CAN总线差分信号</strong><br>　　<strong>·CAN收发器芯片和485芯片差异</strong></p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、什么是CAN收发器？"><a href="#二、什么是CAN收发器？" class="headerlink" title="二、什么是CAN收发器？"></a>二、什么是CAN收发器？</h1><p>CAN收发器在整个CAN网络中所处的位置如上图所示。CAN收发器就是一块类似232或485的<strong>转换芯片</strong>，它的主要功能是<strong>将CAN控制器的TTL信号转换成CAN总线的差分信号</strong>。</p><h2 id="2-1-什么CAN控制器TTL信号？"><a href="#2-1-什么CAN控制器TTL信号？" class="headerlink" title="2.1 什么CAN控制器TTL信号？"></a>2.1 什么CAN控制器TTL信号？</h2><p>现在的CAN控制器一般都与MCU集成在一起，其发送和接收TTL信号就是MCU引脚（高或低）信号。</p><p>以前还有独立的CAN控制器，一个CAN网络节点会包含三块芯片：<strong>MCU芯片、CAN控制器、CAN收发器</strong>。现在是将前两者集成在一起了（看文章开篇图片）。</p><h1 id="三、CAN总线差分信号"><a href="#三、CAN总线差分信号" class="headerlink" title="三、CAN总线差分信号"></a>三、CAN总线差分信号</h1><p>CAN总线信号从CAN收发器出来，为<strong>「两线」「差分」信号</strong>，用隐形代表逻辑1，显性代表逻辑0。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8/2.%E4%B8%A4%E7%BA%BF%E7%94%B5%E5%8E%8B%E4%BF%A1%E5%8F%B7.png?raw=true"><br></table><h2 id="1-CAN收发器两线"><a href="#1-CAN收发器两线" class="headerlink" title="1.CAN收发器两线"></a>1.CAN收发器两线</h2><p>芯片引脚CAN_H、CAN_L</p><h2 id="2-CAN-H和CAN-L电压"><a href="#2-CAN-H和CAN-L电压" class="headerlink" title="2.CAN_H和CAN_L电压"></a>2.CAN_H和CAN_L电压</h2><p>电压的大小根据芯片型号而定，一般常见的CAN收发芯片有3.3V和5V两种芯片。</p><p>如上图，为5V CAN收发芯片，在逻辑0和逻辑1时电压情况：<br><strong>逻辑0时</strong>：显性，CAN_H=3.5V，CAN_L=1.5V；<br><strong>逻辑1时</strong>：隐性，CAN_H=2.5V，CAN_L=2.5V；</p><p>当然，3.3V电压芯片的总线电压原理类似。而实际应用中，总线电压并非绝对的像上面说的3.5V、2.5V、1.5V这种电压，会受到导线电阻、外界干扰等影响。</p><h2 id="3-隐性和显性"><a href="#3-隐性和显性" class="headerlink" title="3.隐性和显性"></a>3.隐性和显性</h2><p>学过生物都知道，基因有隐性和显性，隐性的基因实际存在，但不会表现出来。有显性的基因就会变现出来。<br>这里CAN总线隐性信号和显性信号道理一样，<strong>当总线两者信号都有时，总线表现出来的就是显性信号</strong>。</p><p><strong>提示</strong>：我们这里说的显性和隐性信号，指的是总线传输的bit位信号。</p><p>所以，CAN总线平时空闲表现为隐性状态。如果想要发送的信号为隐性位，那么总线才会呈现出来隐性。否则，只要其它有一个节点发送显性信号，你这个节点发送出来的隐性信号就无效。</p><h2 id="4-CAN收发器R引脚"><a href="#4-CAN收发器R引脚" class="headerlink" title="4.CAN收发器R引脚"></a>4.CAN收发器R引脚</h2><p>CAN收发器R引脚就是与CAN控制器接收相连的引脚。如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8/3.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p>R引脚的信号是表示总线当前的信号，用于控制器实时监测总线信号。主要两个目的：<br><strong>A.监测其它节点发送出来的信号</strong>：别人给它发送数据；<br><strong>B.监测自身节点发送出去的信号</strong>：自己发送是否失败。就像上面说的，自己发送一个隐形信号，结果监测出来是显性信号，那就说明是别人在发送数据。</p><h1 id="四、CAN收发器芯片和485芯片差异"><a href="#四、CAN收发器芯片和485芯片差异" class="headerlink" title="四、CAN收发器芯片和485芯片差异"></a>四、CAN收发器芯片和485芯片差异</h1><p>CAN通信和485通信一样，属于半双工。但是，为什么CAN总线相比485通信不管在<strong>速度和稳定性</strong>上都具有明显优势呢？</p><h2 id="4-1-总线利用率"><a href="#4-1-总线利用率" class="headerlink" title="4.1 总线利用率"></a>4.1 总线利用率</h2><p>CAN收发器工作原理与485具有较大差异。从上面的差分信号可以看得出来，两种芯片同时存在，只有显性信号有效，而不会影响总线传输。简单来说就是CAN总线具有自动仲裁功能，这样就提高了总线的利用率。</p><p>RS485总线是一种常规的通信总线，它不能够做总线的自动仲裁，也就是不能够同时发送数据以避免总线竞争，所以整个系统的通信效率必然较低，数据冗余量较大，对于速度要求高的应用场所不适应用RS485总线。</p><p><strong>提示：</strong><br>CAN总线没有被发送出去的隐性信号，会由CAN控制器后续发送出去。这里牵涉到CAN总线优先级的问题，后续进一步讲述。<br>当然，CAN相比485具有明显优势，<strong>主要原因还是在于CAN控制器</strong>。</p><h2 id="4-2-可以不使用CAN收发器吗？"><a href="#4-2-可以不使用CAN收发器吗？" class="headerlink" title="4.2 可以不使用CAN收发器吗？"></a>4.2 可以不使用CAN收发器吗？</h2><p>UART可以直接通过TX连接对方的RX引脚，利用TTL信号进行通信，那么CAN也可以吗？</p><p><strong>答案：单向传输可以，双向传输就不行。</strong><br>原因很简单，上面说了，CAN控制器会实时监测发送出去的信号是否正确。也就是说TX要与RX信号一致才行，否则CAN控制器认为你发送失败。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　前面文章是从大方向介绍了CAN网络，让大家对CAN网络有一定的认识。本文将范围缩小，讲述整个CAN网络&lt;strong&gt;其中的一个CAN收发器&lt;/strong&gt;。如下图标记出来的部分：&lt;/p&gt;
&lt;table&gt;&lt;br&gt;&lt;img align=&quot;left&quot; width=&quot;600&quot; src=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8/1.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true&quot;&gt;&lt;br&gt;&lt;/table&gt;

&lt;p&gt;　　本文结合众多初学者容易产生的疑问来讲述CAN收发器相关的知识点，大概有如下几点：&lt;br&gt;　　&lt;strong&gt;·什么是CAN收发器？&lt;/strong&gt;&lt;br&gt;　　&lt;strong&gt;·CAN总线差分信号&lt;/strong&gt;&lt;br&gt;　　&lt;strong&gt;·CAN收发器芯片和485芯片差异&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程02_理解CAN总线协议</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程02_理解CAN总线协议.html</id>
    <published>2018-09-20T08:30:00.000Z</published>
    <updated>2018-09-20T09:04:58.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　上一篇文章讲述了CAN和CANOpen，相信大家CAN和CANOpen有一定理解了。本文说的<strong>CAN即是一种总线</strong>，也是一种协议。因此，我们常听见CAN总线，也常听见CAN协议。</p><p>　　CAN协议和CANOpen协议是两套不同的协议。<strong>从软硬件层次来划分，CAN协议属于硬件协议，而CANOpen属于软件协议</strong>。</p><p>　　本篇文章先概述一下CAN网络，让大家对CAN总线协议有一个全局的概念，再到底层的CAN总线协议知识。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、CAN网络"><a href="#二、CAN网络" class="headerlink" title="二、CAN网络"></a>二、CAN网络</h1><p>CAN网络可以理解为多台CAN设备连接在同一条CAN总线上组合成的网络，<strong>其中的CAN设备我们称之为节点</strong>。CAN网络拓扑结构如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/1.CAN%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true"><br></table><p>如上图，一个CAN节点主要包含三类：<strong>MCU应用程序、CAN控制器、CAN收发器</strong>。</p><h2 id="2-1-MCU应用程序"><a href="#2-1-MCU应用程序" class="headerlink" title="2.1 MCU应用程序"></a>2.1 MCU应用程序</h2><p>MCU应用程序我将其分为三块：<strong>业务逻辑代码、协议层代码、底层驱动代码</strong>。</p><p><strong>A.业务逻辑代码</strong>：是根据项目需求而定，也很好理解。比如我读取一个传感器数据，并对其做出相应逻辑处理。</p><p><strong>B.协议层代码</strong>：比如后续要讲述的CANOpen。</p><p><strong>C.底层驱动代码</strong>：配置CAN总线相应参数、控制收发的代码。</p><h2 id="2-2-CAN控制器"><a href="#2-2-CAN控制器" class="headerlink" title="2.2 CAN控制器"></a>2.2 CAN控制器</h2><p>CAN控制器内部结构还是挺复杂的，<strong>一般现在CAN控制器都是与处理器集成在一起</strong>。</p><p>其实对于编程的人来说，无非也就是包含一些控制、状态、配置等寄存器。</p><p>比如我们看到有些STM32芯片带有CAN，也就是说CAN控制器已经集成在STM32芯片中了，我们只需要编程操作其中的寄存器即可。</p><h2 id="2-3-CAN收发器"><a href="#2-3-CAN收发器" class="headerlink" title="2.3 CAN收发器"></a>2.3 CAN收发器</h2><p>CAN收发器：将CAN收发引脚（CAN_TX和CAN_RX）的<strong>TTL信号转换成CAN总线的电平信号</strong>。</p><p><strong>PS：你可以把CAN总线通信认为是UART通过485进行通信</strong>：CAN控制器就如UART的控制器，而CAN收发器就如485转换芯片。</p><h1 id="三、ISO标准化的CAN协议"><a href="#三、ISO标准化的CAN协议" class="headerlink" title="三、ISO标准化的CAN协议"></a>三、ISO标准化的CAN协议</h1><p>写这一章节的主要目的就是想让大家<strong>了解CAN总线位于OSI所在层次</strong>。</p><h2 id="3-1-ISO-OSI基本参照模型"><a href="#3-1-ISO-OSI基本参照模型" class="headerlink" title="3.1 ISO/OSI基本参照模型"></a>3.1 ISO/OSI基本参照模型</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/2.ISO%E3%80%81OSI%E5%9F%BA%E6%9C%AC%E5%8F%82%E7%85%A7%E6%A8%A1%E5%9E%8B.png?raw=true"><br></table><p>【注】<br><strong>ISO</strong>：International Standardization Organization国际标准化组织；<br><strong>OSI</strong>：Open Systems Interconnection开放式系统间互联；</p><h2 id="3-2-CAN在OSI模型中的定义"><a href="#3-2-CAN在OSI模型中的定义" class="headerlink" title="3.2 CAN在OSI模型中的定义"></a>3.2 CAN在OSI模型中的定义</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/3.CAN%E5%9C%A8OSI%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89.png?raw=true"><br></table><p>【注】<br><strong>LLC</strong>：Logical Link Control逻辑链路控制；<br><strong>MAC</strong>：Medium Access Control媒介访问控制；</p><p>从上图可以知道CAN总线底层硬件的内容（CAN控制器、收发器）主要位于OSI的第1层和第2层。</p><h1 id="四、概述CAN总线协议"><a href="#四、概述CAN总线协议" class="headerlink" title="四、概述CAN总线协议"></a>四、概述CAN总线协议</h1><p>CAN总线协议：就是为了保证通信（收发）数据在CAN总线上能稳定传输而制订的一套协议。</p><p>CAN总线协议的内容很多，为方便初学者理解，本文先大概描述一下CAN总线协议，后续文章详细讲述CAN总线协议的内容。</p><h2 id="4-1-总线信号"><a href="#4-1-总线信号" class="headerlink" title="4.1 总线信号"></a>4.1 总线信号</h2><p>CAN总线为<strong>「两线」「差分」</strong>信号，用隐形代表逻辑1，显性代表逻辑0。如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/3.CAN%E6%80%BB%E7%BA%BF%E4%BF%A1%E5%8F%B7.png?raw=true"><br></table><h2 id="4-2-优先级"><a href="#4-2-优先级" class="headerlink" title="4.2 优先级"></a>4.2 优先级</h2><p>假如某一时刻，一个设备（节点）往总线发0，一个设备往总线发1。那么总线会呈现什么现象？</p><p>答案：最后总线呈现为<strong>显性</strong>，也就是0。</p><h2 id="4-3-位时序"><a href="#4-3-位时序" class="headerlink" title="4.3 位时序"></a>4.3 位时序</h2><p>位时序逻辑将监视串行总线，执行采样并调整采样点，在调整采样点时，需要在起始位边沿进行同步并后续的边沿进行再同步。</p><p>简单的说就是对一个bit位分几段进行采样，目的就是提高数据传输稳定性。在STM32中底层驱动代码就需要进行位时序编程，在STM32参考手册中也会发现如下位时序图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/4.%E4%BD%8D%E6%97%B6%E5%BA%8F.png?raw=true"><br></table><h2 id="4-4-帧的种类和格式"><a href="#4-4-帧的种类和格式" class="headerlink" title="4.4 帧的种类和格式"></a>4.4 帧的种类和格式</h2><p>帧的种类有多种：<br><strong>数据帧</strong>：用于发送单元向接收单元传送数据的帧。<br><strong>遥控帧</strong>：用于接收单元向具有相同 ID 的发送单元请求数据的帧。<br><strong>错误帧</strong>：用于当检测出错误时向其它单元通知错误的帧。<br><strong>过载帧</strong>：用于接收单元通知其尚未做好接收准备的帧。<br><strong>帧间隔</strong>：用于将数据帧及遥控帧与前面的帧分离开来的帧。</p><p><strong>数据帧和遥控帧</strong>有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。</p><h2 id="4-5-位填充"><a href="#4-5-位填充" class="headerlink" title="4.5 位填充"></a>4.5 位填充</h2><p>位填充是为防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据。如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/5.%E4%BD%8D%E5%A1%AB%E5%85%85.png?raw=true"><br></table><h2 id="4-6-错误的种类"><a href="#4-6-错误的种类" class="headerlink" title="4.6 错误的种类"></a>4.6 错误的种类</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/6.%E9%94%99%E8%AF%AF%E7%9A%84%E7%A7%8D%E7%B1%BB.png?raw=true"><br></table><p>CAN总线协议内容很多，初学者先了解这些，后面文章具体到每一个点上，相信大家就会更明白其中的含义。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　上一篇文章讲述了CAN和CANOpen，相信大家CAN和CANOpen有一定理解了。本文说的&lt;strong&gt;CAN即是一种总线&lt;/strong&gt;，也是一种协议。因此，我们常听见CAN总线，也常听见CAN协议。&lt;/p&gt;
&lt;p&gt;　　CAN协议和CANOpen协议是两套不同的协议。&lt;strong&gt;从软硬件层次来划分，CAN协议属于硬件协议，而CANOpen属于软件协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　本篇文章先概述一下CAN网络，让大家对CAN总线协议有一个全局的概念，再到底层的CAN总线协议知识。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>CANOpen系列教程01_初识CAN与CANOpen及相关内容</title>
    <link href="http://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_%E5%88%9D%E8%AF%86CAN%E4%B8%8ECANOpen%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html"/>
    <id>http://www.strongerhuang.com/CANOpen/CANOpen系列教程01_初识CAN与CANOpen及相关内容.html</id>
    <published>2018-09-20T08:00:00.000Z</published>
    <updated>2018-09-20T09:04:51.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　我之前学习CANOpen的时候，网上有用的资料极少，走了不少弯路。到目前为止，网上关于CANOpen的资料依然很少。所以，特地写下该系列教程，帮助初学者跨过这道坎。</p><p>　　从我个人学习CANOpen的经历来看，学会使用CANOpen难度其实不大。<strong>难点在于需要掌握的基础知识很多，而且许多都有关联性，容易把人绕晕</strong>。</p><p>　　那么，我希望通过结合之前我的学习经历，以及工作经验，<strong>站在小白的角度写下该系列教程</strong>。当然，该教程由我个人编辑并整理，难免有些废话，或者错误，还请谅解。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/CANOpen/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【CANOpen系列教程】</a>，在我的博客分类“CANOpen系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【CANOpen系列教程】即可查看。</p><h1 id="二、初识CAN与CANOpen"><a href="#二、初识CAN与CANOpen" class="headerlink" title="二、初识CAN与CANOpen"></a>二、初识CAN与CANOpen</h1><h2 id="2-1-什么是CAN"><a href="#2-1-什么是CAN" class="headerlink" title="2.1 什么是CAN?"></a>2.1 什么是CAN?</h2><p>CAN：是Controller Area Network的缩写，即控制器局域网络，属于工业现场总线，是ISO国际标准化的串行通信协议。</p><p>从OSI（Open System Interconnection开放系统互联）7层网络模型的角度来看，CAN现场总线仅仅定义了第 1 层（物理层）和第 2 层（数据链路层）。</p><p>而在实际设计中，这两层完全由硬件实现，设计人员无需再为此开发相关软件或固件（Firmware），只要了解如何调用相关的接口和寄存器，即可完成对CAN的控制。</p><p>上面介绍的内容可能太官方，初学者可能看了之后还是不明白。<strong>简单的说：CAN总线就是一层硬件协议</strong>。比如：差分信号电平的定义、数据帧的定义等等。</p><p><strong>PS</strong>：初学者可以结合UART来理解，比如UART串口发送一个字符’A’，它就是一种串行通信的方式。</p><h2 id="2-2-什么是CANOpen"><a href="#2-2-什么是CANOpen" class="headerlink" title="2.2 什么是CANOpen?"></a>2.2 什么是CANOpen?</h2><p>CANopen是一种架构在CAN控制局域网上的高层软件通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线协议。</p><p>CANopen协议是在20世纪90年代末，由总部位于德国纽伦堡的 CiA 组织——CAN-in-Automation，在 CAL（CAN Application Layer）的基础上发展而来。</p><p>所以，关于CANOpen协议内容请参看：<a href="http://www.can-cia.org" target="_blank" rel="noopener">http://www.can-cia.org</a></p><p>由于CAN总线只定义了OSI中的物理层和数据链路层，因此对于不同的应用出现了不同的【应用层协议】，为了使不同厂商的产品能够相互兼容，世界范围内需要通用的CAN应用层通信协议。</p><p>在过去的二三十年中涌现出许多的协议，不过到现在为止能够广泛被承认的协议却不多，现在应用较广的CAN应用层协议主要有以下三种：<br><strong>CANopen协议</strong>：主要应用在汽车、工业控制、自动化仪表等领域，目前由 CIA 负责管理和维护；</p><p><strong>J1939协议</strong>：CAN总线在商用车领域占有绝大部分市场份额的应用层协议，由美国机动车工程师学会发起，现已在全球范围内得到广泛的应用；</p><p><strong>DeviceNet协议</strong>：在美国等地占有相当大的市场份额，主要用于工业通信及控制和仪器仪表等领域。</p><p>而本文说的CANOpen也是目前应用较广的一种协议。简单的说，CANOpen就是CAN总线应用层协议。</p><p><strong>PS</strong>：学习CANOpen应用层协议之前请务必先了解CAN总线协议。</p><h1 id="三、CAN总线特点"><a href="#三、CAN总线特点" class="headerlink" title="三、CAN总线特点"></a>三、CAN总线特点</h1><p>CAN总线采用差分信号传输，通常情况下<strong>只需要两根信号线（CAN-H和CAN-L）就可以进行正常的通信</strong>。在干扰比较强的场合，还需要用到屏蔽地即CAN-G（主要功能是屏蔽干扰信号）， CAN协议推荐用户使用屏蔽双绞线作为CAN总线的传输线。</p><p>CAN总线通信的优势和特点：<br><strong>A.</strong>CAN总线上任意节点，均可在任意时刻主动的向其它节点发起通信，但在同一时刻优先级高的节点能获得总线的使用权。</p><p><strong>B.</strong>标准CAN总线传输波特率可达到1Mbps。在5Kbps的通信波特率下最远传输距离可以达到 10Km，即使在1Mbps的波特率下也能传输40m的距离。</p><p><strong>C.</strong>CAN总线定义使用了硬件报文滤波，可实现点对点及点对多点的通信方式，不需要软件来控制。</p><p><strong>D.</strong>CAN总线所挂接的节点数量主要取决于CAN总线收发器或驱动器，目前的驱动器一般都可以使同一网络容量达到110个节点。</p><p><strong>E.</strong>CAN总线通信介质可采用双绞线、同轴电缆或光纤，选择极为灵活。可大大节约组网成本。</p><p>当然，CAN总线的优势还有许多，当你掌握之后就会明白为什么CAN总线应用得如此广泛了。</p><h1 id="四、教程规划"><a href="#四、教程规划" class="headerlink" title="四、教程规划"></a>四、教程规划</h1><p>CAN总线及CANOpen协议相关的内容相对比较多，如果每一个细节知识点都写出来，可能花掉我业余时间写一年也写不完。</p><p>我写该教程目的在于引导初学者入门，我会结合实例代码让大家边学边理解，至于实际项目编程应用不一定讲述的很多（这个看后面情况）。</p><p><strong>首先从CAN底层讲起，再到CANOpen协议相关基础知识，最后实际应用</strong>。当然，中间每一个环节内容相对可能较多，也有可能会遗漏部分内容。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档部分文字来自周立功的相关教程，仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>　　我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　我之前学习CANOpen的时候，网上有用的资料极少，走了不少弯路。到目前为止，网上关于CANOpen的资料依然很少。所以，特地写下该系列教程，帮助初学者跨过这道坎。&lt;/p&gt;
&lt;p&gt;　　从我个人学习CANOpen的经历来看，学会使用CANOpen难度其实不大。&lt;strong&gt;难点在于需要掌握的基础知识很多，而且许多都有关联性，容易把人绕晕&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　那么，我希望通过结合之前我的学习经历，以及工作经验，&lt;strong&gt;站在小白的角度写下该系列教程&lt;/strong&gt;。当然，该教程由我个人编辑并整理，难免有些废话，或者错误，还请谅解。&lt;/p&gt;
    
    </summary>
    
      <category term="CANOpen系列教程" scheme="http://www.strongerhuang.com/categories/CANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="CAN" scheme="http://www.strongerhuang.com/tags/CAN/"/>
    
      <category term="CAN总线" scheme="http://www.strongerhuang.com/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
      <category term="CANOpen" scheme="http://www.strongerhuang.com/tags/CANOpen/"/>
    
      <category term="CanFestival" scheme="http://www.strongerhuang.com/tags/CanFestival/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路.html</id>
    <published>2018-09-03T04:30:00.000Z</published>
    <updated>2018-09-03T05:55:13.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　本文对【MAVLink学习之路】做了整理并汇总，会随着该系列教程的更新而更新。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><a id="more"></a><h1 id="二、教程列表"><a href="#二、教程列表" class="headerlink" title="二、教程列表"></a>二、教程列表</h1><p><a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html">1.MAVLink学习之路01_认识MAVLink</a></p><p><a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">2.MAVLink学习之路02_工具下载、环境搭建</a></p><p><a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81.html">3.MAVLink学习之路03_XML中定义MSG并生成C代码</a></p><p><a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.html">4.MAVLink学习之路04_MAVLink移植到STM32具体步骤</a></p><p><a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90.html">5.MAVLink学习之路05_MAVLink应用编程接口分析</a></p><p>正在努力更新中，敬请等待……</p><h1 id="三、说明"><a href="#三、说明" class="headerlink" title="三、说明"></a>三、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　本文对【MAVLink学习之路】做了整理并汇总，会随着该系列教程的更新而更新。&lt;/p&gt;
&lt;p&gt;　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于&lt;a href=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信公众号【EmbeddedDevelop】&lt;/a&gt;，关注微信公众号回复【MAVLink学习之路】即可查看。&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路05_MAVLink应用编程接口分析</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路05_MAVLink应用编程接口分析.html</id>
    <published>2018-09-03T04:00:00.000Z</published>
    <updated>2018-09-03T06:00:28.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　前面写的几篇文章你掌握了，说明你离成功很近了。那么本文就带你真正进入编程的世界，让你进一步掌握MAVLink应用编程的重要知识点。</p><p>　　本文主要内容：<br>　　　<strong>·</strong>MAVLink应用编程主要内容<br>　　　<strong>·</strong>MAVLink函数接口详细说明</p><p>　　<strong>提示</strong>：本文结合上一篇文章提供给大家下载的<strong>“MAVLink发送接收例程”</strong>进行讲解，请结合例程理解本文。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html">【MAVLink学习之路】</a>，在我的博客分类“MAVLink学习之路”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><h1 id="二、MAVLink应用编程主要内容"><a href="#二、MAVLink应用编程主要内容" class="headerlink" title="二、MAVLink应用编程主要内容"></a>二、MAVLink应用编程主要内容</h1><h2 id="2-1-发送和接收说明"><a href="#2-1-发送和接收说明" class="headerlink" title="2.1 发送和接收说明"></a>2.1 发送和接收说明</h2><p>利用MAVLink通信协议进行编程，主要实现的功能就是：</p><p><strong>1.发送端</strong><br>将需要发送的数据（如：SysState, BatVol），添加MAVLink通信协议，通过硬件（如：UART、CAN）发送出去。</p><p><strong>2.接收端</strong><br>硬件（如：UART、CAN）接收到的数据，通过MAVLink协议解析，得到一帧完整的MAVLink数据包，提取发送端发送的数据（如：SysState, BatVol），将得到的数据应用到我们程序中。</p><p><strong>主要流程</strong>：数据 -&gt; MAVLink封装 -&gt; 发送 -&gt; 接收 -&gt; MAVLink解析 -&gt;数据</p><h2 id="2-2-发送和接收流程图"><a href="#2-2-发送和接收流程图" class="headerlink" title="2.2 发送和接收流程图"></a>2.2 发送和接收流程图</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/1.%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true"><br></table><p>该流程图是结合我上一篇文章提供的源代码例程画出来，包含的只是主要内容，更多细节没有在流程图中呈现。</p><p><strong>提示：</strong><br>我提供例程是针对初学者提供比较单一发送和接收例程（MDK-ARM和EWARM包含各自的发送和接收工程）。</p><p><strong>而实际项目可能会：</strong><br>1.发送和接收在一个工程；<br>2.包含操作系统；<br>3.发送、接收数据FIFO（队列）处理；</p><p>所以，实际项目，请按需修改我提供的源码。</p><h1 id="三、MAVLink函数接口详细说明"><a href="#三、MAVLink函数接口详细说明" class="headerlink" title="三、MAVLink函数接口详细说明"></a>三、MAVLink函数接口详细说明</h1><p>这一章节讲述发送和接收主要用到的函数接口，请参考我提供的源代码例程理解。<br>为方便初学者理解，我将其分为发送和接收两个部分来讲述。</p><h2 id="3-1-发送主要函数接口"><a href="#3-1-发送主要函数接口" class="headerlink" title="3.1 发送主要函数接口"></a>3.1 发送主要函数接口</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/2.%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3.png?raw=true"><br></table><p>上面是我提供例程的代码，主要讲4个接口。</p><p><strong>1.MAVLink_SendTest</strong><br>这个接口是根据自己情况进行封装函数，用于应用程序调用，这里不多说。</p><p><strong>2.mavlink_msg_sys_info_pack</strong><br>这个函数接口主要目的：将变量信息（SysID、CompID、SysState、BatVol）打包，最终得到MAVLink_Msg这个消息包。</p><p><strong>3.mavlink_msg_to_send_buffer</strong><br>将上一步得到的MAVLink_Msg转换成我们要发送的数据BUF缓存。</p><p><strong>4.MAV_USART_SendNByte</strong><br>这个函数接口也是我自己根据硬件（UART）封装的，如果你是其它硬件通信，只需要封装一个类似的接口（参数具有BUF，LEN）即可。</p><p><strong>发送数据的流程</strong>：从应用代码 -&gt; 底层硬件（发送出去）。</p><p>如果要深入了解，可以先熟悉软件流程，再结合源代码工程，同时参看接口函数具体实现。相信你很快就明白了。</p><h2 id="3-2-接收主要函数接口"><a href="#3-2-接收主要函数接口" class="headerlink" title="3.2 接收主要函数接口"></a>3.2 接收主要函数接口</h2><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/3.%E6%8E%A5%E6%94%B6%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3.png?raw=true"><br></table><p>上面是我提供例程的代码（方便截图，去掉了部分），主要讲以上4点内容。</p><p><strong>1.MAV_USART_GetByte</strong><br>该函数接口也是硬件底层通信接口，请根据自己情况修改，只需要传递数据（流）进来即可。</p><p><strong>2.mavlink_parse_char</strong><br>MAVLink解析是按照一个一个字符进行解析，我们接收到一个字符，就对其进行解析，直到解析完（根据返回标志判断）一帧数据为止。</p><p><strong>3.if(MAVLINK_MSG_ID_SYS_INFO == MAVLinkMsg.msgid)</strong><br>这里就是对解析好的一包完整消息进行分类判断吧。其实，我是想说，这个地方还有两个ID需要进行判断，SysID系统ID和CompID部件ID。</p><p>我提供例程为方便初学者快速理解，未提供SysID和CompID判断，在后续应用编程中会用到。</p><p><strong>4.mavlink_msg_sys_info_get_voltage_battery</strong><br>通过该接口获取消息变量，看图中说明文字，前面是消息，后面是消息变量。</p><p><strong>接收数据的流程</strong>：从应用代码 -&gt; 底层硬件（发送出去）。</p><p>以上就是发送和接收的主要函数接口，<strong>如果你只是简单的进行通信，这几个接口就够你使用了</strong>。当然，更高级的编程应用还需要你进一步掌握其中的内容。</p><h1 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　前面写的几篇文章你掌握了，说明你离成功很近了。那么本文就带你真正进入编程的世界，让你进一步掌握MAVLink应用编程的重要知识点。&lt;/p&gt;
&lt;p&gt;　　本文主要内容：&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;MAVLink应用编程主要内容&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;MAVLink函数接口详细说明&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;提示&lt;/strong&gt;：本文结合上一篇文章提供给大家下载的&lt;strong&gt;“MAVLink发送接收例程”&lt;/strong&gt;进行讲解，请结合例程理解本文。&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路04_MAVLink移植到STM32具体步骤</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路04_MAVLink移植到STM32具体步骤.html</id>
    <published>2018-09-03T01:00:00.000Z</published>
    <updated>2018-09-03T00:52:34.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　《MAVLink学习之路》前面三篇文章，可以说是一些基础知识，也是为本文做的准备工作（建议初学者先了解前面三篇文章）。</p><p>　　本文主要内容：<br>　　　<strong>·</strong>MAVLink移植主要步骤<br>　　　<strong>·</strong>MAVLink移植过程要点</p><p>　　<strong>提示</strong>：为方便广大初学者朋友尽快掌握MAVLink，我在<strong>文末提供MAVLink发送接收例程</strong>（基于STM32硬件、MDK-ARM和EWARM开发环境）。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html">【MAVLink学习之路】</a>，在我的博客分类“MAVLink学习之路”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><h1 id="二、MAVLink移植主要步骤"><a href="#二、MAVLink移植主要步骤" class="headerlink" title="二、MAVLink移植主要步骤"></a>二、MAVLink移植主要步骤</h1><h2 id="2-1-移植说明"><a href="#2-1-移植说明" class="headerlink" title="2.1 移植说明"></a>2.1 移植说明</h2><p>　　本文主要针对MAVLink C源代码移植进行讲述。其中，MAVLink的C源代码可以<strong>下载网上预生成的C源代码库</strong>，也可以通过<strong>生成器工具生成</strong>。</p><p><strong>A.下载预生成C代码库</strong><br>　　如果是使用标准MAVLink的MSG消息，则可以现在官方指定地址预先生成的C代码库。预先生成C代码库总共两个版本：<br>MAVLink V1版：<a href="https://github.com/mavlink/c_library_v1" target="_blank" rel="noopener">https://github.com/mavlink/c_library_v1</a><br>MAVLink V2版：<a href="https://github.com/mavlink/c_library_v1" target="_blank" rel="noopener">https://github.com/mavlink/c_library_v1</a></p><p><strong>B.生成器生成C代码</strong><br>　　如果你需要自定义MSG消息，则需要自己通过工具生成C代码，具体生成方法请参看文章：<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81.html">《MAVLink学习之路03_XML中定义MSG并生成C代码.》</a></p><p><strong>提示：</strong><br>　　官方预生成C代码库就是通过生成器而生成的，官方提供的生成器工具、预生成C代码库不定期更新。也就是说可能你<strong>不同时期看到的预生成库不同，不同时期的生成器及其生成的代码也有所不同</strong>。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/1.%E9%A2%84%E7%94%9F%E6%88%90C%E5%BA%93.png?raw=true"><br></table><p>　　如上图，官方预生成的C代码（V1版），与通过生成器生成的代码完全一样。如common.xml通过生成器生成的C代码就和上面紫红色框出来的代码一样。当然，生成器版本也是这最新的才对。</p><h2 id="2-2-移植主要步骤"><a href="#2-2-移植主要步骤" class="headerlink" title="2.2 移植主要步骤"></a>2.2 移植主要步骤</h2><p>1.下载相关工具<br>2.环境搭建<br>3.生成C代码（如果下载官方预生成代码，前面两步可以不用）<br>4.将C代码添加到工程<br>5.配置（如添加MAVLink路径、修改代码适配工程）<br>6.添加MAVLink发送接收（及应用）代码</p><p>步骤1， 2， 3已经在前面文章详细讲述了，本文主要讲述步骤4， 5。步骤6下一篇文章详细讲述。</p><h1 id="三、MAVLink移植过程要点"><a href="#三、MAVLink移植过程要点" class="headerlink" title="三、MAVLink移植过程要点"></a>三、MAVLink移植过程要点</h1><p>本节主要内容讲述将C代码添加到工程，然后配置，到编译没有错误这一过程中的一些重要知识点。</p><h2 id="3-1-代码添加到工程"><a href="#3-1-代码添加到工程" class="headerlink" title="3.1 代码添加到工程"></a>3.1 代码添加到工程</h2><p>代码添加到工程其实很简单，将代码拷贝工程文件下，类似如下图，添加组，添加源文件。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/2.%E6%B7%BB%E5%8A%A0%E7%BB%84%E3%80%81%E6%B7%BB%E5%8A%A0%E6%BA%90%E6%96%87%E4%BB%B6.png?raw=true"><br></table><p>但是，MAVLink源代码都是.h头文件，可以不用像上面那样添加到工程。当然，添加头文件到工程的好处就是可以快速打开头文件，查找相关代码。</p><p>说这一小节是想提示大家：<strong>MAVLink的C源代码都是.h头文件。头文件只需要添加对应路径，包含头文件即可（#include “mavlink.h”）</strong>。</p><h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><p><strong>1.添加路径</strong><br>Keil MDK-ARM和IAR EWARM添加路径这项内容我就不在这里详细讲述了，不会的朋友可以参看看我的文章：<br><strong>Keil MDK-ARM系列教程（一）_新建软件工程详细过程</strong><br><strong>IAR EWARM系列教程（一）_新建软件工程详细过程</strong></p><h2 id="3-3-修改代码"><a href="#3-3-修改代码" class="headerlink" title="3.3 修改代码"></a>3.3 修改代码</h2><p>这小节内容可以参看网上一篇博文：<br><a href="https://www.cnblogs.com/lovechen/p/5809709.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovechen/p/5809709.html</a><br>那篇文章讲述的很多，我讲一下重点：它修改的代码是针对老版本主要需要修改两个地方。<br>而且新版本MAVLink生成器已经优化了一个项，也就是只有一个地方需要修改：修改mavlink_types.h.</p><table><br><strong>1.针对Keil MDK-ARM</strong><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/3.%E9%92%88%E5%AF%B9MDK-ARM%E4%BF%AE%E6%94%B9.png?raw=true"><br></table><table><br><strong>2.针对IAR EWARM</strong><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/4.%E9%92%88%E5%AF%B9EWARM%E4%BF%AE%E6%94%B9.png?raw=true"><br></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加预定义：#pragma anon_unions</span><br><span class="line">替换代码：#define MAVPACKED( __Declaration__ ) __Declaration__</span><br></pre></td></tr></table></figure><p>那篇文章针对的是老版MAVLink还需要修改一个const的地方，我这里就不说了（新来的建议用新版的）。</p><p><strong>为什么这里要修改呢？</strong><br>原因在于编译器的差异导致的。</p><h2 id="3-4-补充知识点"><a href="#3-4-补充知识点" class="headerlink" title="3.4 补充知识点"></a>3.4 补充知识点</h2><p><strong>1.#pragma anon_unions</strong><br>keil中默认是不支持匿名结构体的，需要编译指令#pragma anon_unions指名。</p><p><strong>2.MAVPACKED</strong><br>如果不修改代码，直接编译，发现有许多错误，原因都来自MAVPACKED。结合修改的内容，再看下图，有什么启发没有。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/5.MAVPACKED.png?raw=true"><br></table><h1 id="四、源代码下载"><a href="#四、源代码下载" class="headerlink" title="四、源代码下载"></a>四、源代码下载</h1><p>地址：<a href="https://pan.baidu.com/s/1xraErAnmL-BN9CMwE6aQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1xraErAnmL-BN9CMwE6aQ</a><br>密码：cusq</p><p><strong>提示</strong>：包含四个工程：Keil、IAR各自的发送和接收工程。如果链接失效，请到公众号回复【MAVLink学习之路】查看更新链接。</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　《MAVLink学习之路》前面三篇文章，可以说是一些基础知识，也是为本文做的准备工作（建议初学者先了解前面三篇文章）。&lt;/p&gt;
&lt;p&gt;　　本文主要内容：&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;MAVLink移植主要步骤&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;MAVLink移植过程要点&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;提示&lt;/strong&gt;：为方便广大初学者朋友尽快掌握MAVLink，我在&lt;strong&gt;文末提供MAVLink发送接收例程&lt;/strong&gt;（基于STM32硬件、MDK-ARM和EWARM开发环境）。&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路03_XML中定义MSG并生成C代码</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路03_XML中定义MSG并生成C代码.html</id>
    <published>2018-08-30T04:00:00.000Z</published>
    <updated>2018-08-30T06:21:58.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　如果你前面两篇文章掌握了，说明你已经入门了。本文带你掌握如何在XML文件中定义Message（MSG消息）并生成C代码。</p><p>　　本文主要内容：<br>　　　<strong>·</strong>如何在XML文件中定义Message（消息）<br>　　　<strong>·</strong>如何通过生成器工具生成MAVLink C代码</p><p>　　<strong>提示</strong>：本文将结合上一篇文章提供下载的“MAVlink代码生成工具包”来讲述。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html">【MAVLink学习之路】</a>，在我的博客分类“MAVLink学习之路”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><h1 id="二、XML文件中定义MSG"><a href="#二、XML文件中定义MSG" class="headerlink" title="二、XML文件中定义MSG"></a>二、XML文件中定义MSG</h1><h2 id="2-1-关于MSG"><a href="#2-1-关于MSG" class="headerlink" title="2.1 关于MSG"></a>2.1 关于MSG</h2><p>MAVLink的MSG消息定义在XML文件中，通过生成器工具（Mavenerate或Mavgen）生成MAVLink C代码；</p><p>在MAVLink协议中，每一条MSG消息都具有一个ID，且ID具有唯一性。MSG消息ID其实就是对应协议格式中msgid，如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/1.MAVLink%20V1%E6%A0%BC%E5%BC%8F.png?raw=true"><br></table><p>简单来说：在xml中定义一条Message消息，通过生成器工具就能生成该Message对应的C代码（一条Message也可以理解成一条通信命令）。</p><p><strong>提示</strong>：<br>在MAVLink V1版本中，消息ID有效数字的范围为0到255。</p><p>其中0到149为公共消息ID（飞控系统共有消息，一般不建议用于自定义）。而150到240为用于自定义消息的ID范围。</p><p>比如，打开前面下载的工具包消息定义的文件夹（如下图），可以看到：common.xml文件主要是一些<strong>公共消息ID范围为：0到149</strong>。而其它xml文件是针对不同系统定义的消息，主要集中在<strong>150到240</strong>之间。</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/2.%E6%B6%88%E6%81%AF%E5%AE%9A%E4%B9%89%E7%9A%84xml%E6%96%87%E4%BB%B6.png?raw=true"><br></table><h2 id="2-2-MSG的定义方法"><a href="#2-2-MSG的定义方法" class="headerlink" title="2.2 MSG的定义方法"></a>2.2 MSG的定义方法</h2><p>　　MAVLink的MSG消息定义在XML文件中，所以遵循XML语法规则。语法很简单（只需要记住部分常用的就行），我们可以参考MAVLink定义好的xml文件。</p><p>　　解压上一篇文章下载<strong>“MAVlink代码生成工具包”</strong>，打开（路径MAVLink \ message_definitions \ v1.0下）common.xml文件，我们以“心跳”为例：</p><table><br><img align="left" width="700" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/3.%E5%BF%83%E8%B7%B3MSG.png?raw=true"><br></table><p>从上图可以看出：<strong>“心跳”消息</strong>包含：消息ID、描述（注释）以及各项参数（可以理解为一个函数，及函数的参数）。</p><p><strong>1.《message》《/message》标签</strong><br>每条消息都被定义在这样一个消息标签内。</p><p><strong>2.id=“0”</strong><br>表示此消息的id或index编号为0。</p><p><strong>3.name=“HEARTBEAT”</strong><br>该ID编号对应的名称。</p><p><strong>4.《description》《/description》</strong><br>对该消息的描述，是一个非常重要，但可选的领域（意思是可以不用定义），可以理解为代码的注释。</p><p><strong>5.《field》《/field》</strong><br>对消息的一个字段进行定义，它类似于C语言中的一个变量，可以是8,16,32和64位长度（有符号或无符号），以及浮点类型等。</p><p><strong>6.type=“uint8_t”</strong><br>将此字段定义为8位无符号整数。数组的定义如下：type=“uint8_t[5]”。可以理解为一个函数参数的数据类型。</p><p><strong>7.name = “type” </strong><br>该字段的名称，可以理解为一个函数参数的名称。</p><p><strong>8.Type of the MAV</strong><br>字段说明，可以理解为函数参数的注释。</p><p>上面文字描述可能理解起来比较困难，看下图<strong>心跳消息对应生成的C代码</strong>：</p><table><br><img align="left" width="700" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/4.%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E.png?raw=true"><br></table><p>以上举例，只是提供其中一个函数接口，其实还会生成更多与该消息相关的接口、结构体等。</p><h1 id="2-3-enum的定义方法"><a href="#2-3-enum的定义方法" class="headerlink" title="2.3 enum的定义方法"></a>2.3 enum的定义方法</h1><p>上面2.2节在xml中定义消息明白了，这节enum（枚举）的定义就很容易理解了，原理一样。</p><p>枚举和消息只是内容有所差异，定义原理都类似。枚举包含：枚举名称，成员（元素）名称，成员值等。</p><p>枚举的定义就不详细描述出来，提供<strong>枚举xml定义和生成C代码</strong>，相信你一看就能明白。</p><table><br><strong>xml中定义的MAV_AUTOPILOT：</strong><br><img align="left" width="700" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/5.%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89.png?raw=true"><br></table><table><br><strong>生成的C代码：</strong><br><img align="left" width="700" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/6.%E6%9E%9A%E4%B8%BEC%E4%BB%A3%E7%A0%81.png?raw=true"><br></table><p><strong>提示：</strong><br>关于消息定义，更多的内容可以参看：<br><a href="http://qgroundcontrol.org/mavlink/create_new_mavlink_message" target="_blank" rel="noopener">http://qgroundcontrol.org/mavlink/create_new_mavlink_message</a></p><h1 id="三、通过生成器工具生成MAVLink-C代码"><a href="#三、通过生成器工具生成MAVLink-C代码" class="headerlink" title="三、通过生成器工具生成MAVLink C代码"></a>三、通过生成器工具生成MAVLink C代码</h1><p>上面第二章节在xml文件中定义好了<strong>MSG消息和enum枚举</strong>，那么，就需要通过生成器工具生成我们最终需要的代码（我主要讲述生成C代码）。</p><p>MAVLink项目提供有生成器有两种：Mavgenerate（GUI）和Mavgen（命令行）；</p><p>使用生成器工具前提需要搭建好环境，请参考：<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html">MAVLink学习之路02_工具下载、环境搭建</a></p><h2 id="3-1-Mavgenerate生成C代码"><a href="#3-1-Mavgenerate生成C代码" class="headerlink" title="3.1 Mavgenerate生成C代码"></a>3.1 Mavgenerate生成C代码</h2><p>这个工具使用方法很简单，环境搭建好之后，解压下载工具包，在当前路径下输入命令“python mavgenerate.py”，或者双击mavgenerate.py即可打开：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/7.Mavgenerate%E7%94%9F%E6%88%90%E5%99%A8.jpg?raw=true"><br></table><h2 id="3-2-Mavgen生成C代码"><a href="#3-2-Mavgen生成C代码" class="headerlink" title="3.2 Mavgen生成C代码"></a>3.2 Mavgen生成C代码</h2><p>　　Mavgen生成器是一个通过命令实现的工具，命令很简单，比如：python -m pymavlink.tools.mavgen –lang=C –wire-protocol=1.0 –output=generated/include/mavlink/v1.0 message_definitions/v1.0/common.xml 命令的具体描述请看下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/8.Mavgen%E7%94%9F%E6%88%90%E5%99%A8.png?raw=true"><br></table><h2 id="3-3-关于生成器几点提示"><a href="#3-3-关于生成器几点提示" class="headerlink" title="3.3 关于生成器几点提示"></a>3.3 关于生成器几点提示</h2><p><strong>1.Mavgen支持的语言及版本</strong></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/9.%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E8%A8%80.png?raw=true"><br></table><p><strong>2.路径</strong><br>因为命令行生成器支持相对路径，建议将xml文件拷贝到如下路径：MAVLink\message_definitions\v1.0</p><p><strong>3.命令语法和选项说明</strong></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81/10.%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%92%8C%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E.png?raw=true"><br></table><p>初学者不用深入理解，只需要知道如何生成C代码即可（参考我上面提供的哪一条命令）。</p><p>关于生成器工具更多的内容可以参考：<br><a href="https://mavlink.io/en/getting_started/generate_libraries.html" target="_blank" rel="noopener">https://mavlink.io/en/getting_started/generate_libraries.html</a></p><h1 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　如果你前面两篇文章掌握了，说明你已经入门了。本文带你掌握如何在XML文件中定义Message（MSG消息）并生成C代码。&lt;/p&gt;
&lt;p&gt;　　本文主要内容：&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;如何在XML文件中定义Message（消息）&lt;br&gt;　　　&lt;strong&gt;·&lt;/strong&gt;如何通过生成器工具生成MAVLink C代码&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;提示&lt;/strong&gt;：本文将结合上一篇文章提供下载的“MAVlink代码生成工具包”来讲述。&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路02_工具下载、环境搭建</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路02_工具下载、环境搭建.html</id>
    <published>2018-08-27T08:00:00.000Z</published>
    <updated>2018-08-30T03:17:31.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>初学者学习本文之前，建议参看我的上一篇文章：<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html">《MAVLink学习之路01_认识MAVLink》</a></p><p>本文主要两个内容：<br>　<strong>·下载相应安装包及工具</strong><br>　<strong>·环境搭建</strong></p><p>　　其中环境搭建是很多初学朋友从入门到放弃的一个重要阶段。环境搭建难度不大，解决问题重要的一点：针对问题找解决办法。不要看到问题就撤退，否则，只有一个结果：就是放弃。</p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html">【MAVLink学习之路】</a>，在我的博客分类“MAVLink学习之路”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><h1 id="二、下载"><a href="#二、下载" class="headerlink" title="二、下载"></a>二、下载</h1><h2 id="2-1-下载说明"><a href="#2-1-下载说明" class="headerlink" title="2.1 下载说明"></a>2.1 下载说明</h2><p><strong>1.git工具</strong><br>建议提前git工具，方便<strong>下载、环境搭建、启动GUI</strong>等。<br>（当然，不使用git也行，下载压缩包，使用Windows自带命令行）</p><p><strong>2.系统</strong><br>MAVLink开发环境可以搭建在<strong>Windoes和Linux系统</strong>，本教程只讲述基于Windows搭建环境以及后期的开发。（基于Linux系统的环境搭建可以自己研究一下）</p><p><strong>3.下载内容</strong><br>第一类：MAVlink环境搭建工具包<br>　<strong>·Python</strong><br>　<strong>·Future</strong></p><p>第二类：MAVlink代码生成工具包<br>　<strong>·MAVLink（含pymavlink）</strong></p><p>我把它分为以上两类（当然，这是我自己的分类方式，可能不完全正确），<strong>主要就是下载Python、Future、MAVLink、pymavlink四项内容</strong>。</p><p>下载的方式：<br>　·官网（推荐）<br>　·百度网盘（可能会失效）</p><h2 id="2-2-环境搭建安装包下载"><a href="#2-2-环境搭建安装包下载" class="headerlink" title="2.2 环境搭建安装包下载"></a>2.2 环境搭建安装包下载</h2><h3 id="2-2-1-Python"><a href="#2-2-1-Python" class="headerlink" title="2.2.1 Python"></a>2.2.1 Python</h3><p>Python版本分Python2和Python3。官方推荐安装：<strong>Python 2.7+ or 3.3+</strong>.</p><p>因为许多使用Python支持的工具对Python 2具有更好的兼容性（比如我接下来要讲述的CANOpen文章，生成对象字典同样需要Python 2的支持），我一般推荐使用Python 2.7。</p><p>官网下载地址：<br><a href="https://www.python.org/downloads" target="_blank" rel="noopener">https://www.python.org/downloads</a></p><p>百度网盘：<br><a href="https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA</a><br>密码: q8ic</p><p>（目前2018年8月最新Python 2.7.15，网盘后期地址可能会失效，建议到官网下载最新版本）</p><h3 id="2-2-2-Future"><a href="#2-2-2-Future" class="headerlink" title="2.2.2 Future"></a>2.2.2 Future</h3><p>future可以下载安装文件进行离线安装，也可以输入命令在线安装。（下章节讲述安装）</p><p>官网下载地址：<br><a href="https://pypi.org/project/future/#files" target="_blank" rel="noopener">https://pypi.org/project/future/#files</a></p><p>百度网盘：<br><a href="https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA</a><br>密码: q8ic</p><h2 id="2-3-MAVlink代码生成工具包"><a href="#2-3-MAVlink代码生成工具包" class="headerlink" title="2.3 MAVlink代码生成工具包"></a>2.3 MAVlink代码生成工具包</h2><p>MAVlink代码生成工具包，环境搭建完成之后，用于代码生成的一项工具包（后面文章讲述代码生成会用到这工具包）。</p><p>官网下载地址：<br><a href="https://github.com/mavlink/mavlink" target="_blank" rel="noopener">https://github.com/mavlink/mavlink</a></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.MAVlink%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%8C%85.png?raw=true"><br></table><p>建议使用Git工具下载（当然，也可以直接下载压缩包）。</p><p>百度网盘：<br><a href="https://pan.baidu.com/s/1dIzR3YzYsyecBGZgReSpYg" target="_blank" rel="noopener">https://pan.baidu.com/s/1dIzR3YzYsyecBGZgReSpYg</a><br>密码: t9pi</p><h1 id="三、环境搭建"><a href="#三、环境搭建" class="headerlink" title="三、环境搭建"></a>三、环境搭建</h1><h2 id="3-1-环境搭建说明"><a href="#3-1-环境搭建说明" class="headerlink" title="3.1 环境搭建说明"></a>3.1 环境搭建说明</h2><p>环境搭建也就是安装相关软件，主要是安装Python和Future这两个软件。</p><p>安装这两个软件很容易，难点在于有些细节问题，下面我会针对常见问题提出来（当然，因系统或配置等各种原因，所体现出来的问题也有所不同）。</p><h2 id="3-2-安装Python"><a href="#3-2-安装Python" class="headerlink" title="3.2 安装Python"></a>3.2 安装Python</h2><p><strong>1.直接双击Python安装，会出现类似如下图错误</strong></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2.%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85Python%E9%94%99%E8%AF%AF.png?raw=true"><br></table><p>所以，不建议直接双击Python安装包进行安装，按照下面方式：以管理员方式运行安装。</p><p><strong>2.以管理员是身份运行cmd</strong></p><table><br><img align="left" width="250" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%98%AF%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8Ccmd.png?raw=true"><br></table><p>Win -&gt; 输入cmd -&gt; 选中“命令提示符”右键 -&gt; 以管理员身份运行</p><p><strong>3.安装</strong></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.%E5%AE%89%E8%A3%85.png?raw=true"><br></table><p>路径 + 安装文件（含后缀）：D:\Desktop\python-2.7.15.msi（根据自己路径修改）</p><p>安装的很多步骤按照提示操作即可（一般点击next即可），重要的内容下面我提示一下。</p><p><strong>4.添加路径</strong></p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84.png?raw=true"><br></table><p>这一步添加路径的作用就是添加系统环境变量（也是很多朋友失败的原因）。不选择的话，就需要安装好之后自己在环境变量中添加路径。</p><p>安装Python主要注意以上两点即可。</p><p><strong>5.检验是否安装成功</strong><br>A.查看系统环境变量，是否具有python路径。<br>B.CMD输入python，验证是否安装成功，如下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png?raw=true"><br></table><h2 id="3-3-安装Future"><a href="#3-3-安装Future" class="headerlink" title="3.3 安装Future"></a>3.3 安装Future</h2><p>安装future有两种方法：1.输入命令在线安装； 2.下载安装文件，离线安装。<br>（这里可以使用windows自带命令行，也可以使用git命令行）</p><p><strong>1.在线安装</strong><br>输入命令：pip install future （推荐使用该方法）</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85future.png?raw=true"><br></table><p><strong>2.离线安装</strong><br>前提是下载好安装包，进入安装包路径，输入安装命令：python setup.py install</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/8.%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85future.png?raw=true"><br></table><h1 id="四、验证环境变量"><a href="#四、验证环境变量" class="headerlink" title="四、验证环境变量"></a>四、验证环境变量</h1><p>验证环境变量是否安装成功：<strong>下载“MAVlink代码生成工具包” -&gt; 解压 -&gt; 进入MAVlink路径 -&gt; 输入命令python mavgenerate.py</strong>，出现如下对话框则成功。</p><table><br><img align="left" width="400" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/9.%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png?raw=true"><br></table><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;初学者学习本文之前，建议参看我的上一篇文章：&lt;a href=&quot;https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html&quot;&gt;《MAVLink学习之路01_认识MAVLink》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要两个内容：&lt;br&gt;　&lt;strong&gt;·下载相应安装包及工具&lt;/strong&gt;&lt;br&gt;　&lt;strong&gt;·环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其中环境搭建是很多初学朋友从入门到放弃的一个重要阶段。环境搭建难度不大，解决问题重要的一点：针对问题找解决办法。不要看到问题就撤退，否则，只有一个结果：就是放弃。&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAVLink学习之路01_认识MAVLink</title>
    <link href="http://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html"/>
    <id>http://www.strongerhuang.com/MAVLink/MAVLink学习之路01_认识MAVLink.html</id>
    <published>2018-08-24T13:00:00.000Z</published>
    <updated>2018-08-30T03:20:43.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>1.MAVLink是一种非常轻量级的通信协议，在简单的8位单片机上也可以运行。</p><p>2.MAVLink的初衷主要是用于无人机上，但它的通用性和可移植性非常好，它也可以应用于其它很多场合。</p><p>3.MAVLink的设计方式值得学习通信的朋友研究一下。</p><p><strong>因此，学习无人机开发、学习通信原理、需要实现设备间通信的朋友都值得参看本文。</strong></p><a id="more"></a><p>　　本文章收录于<a href="https://www.strongerhuang.com/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html">【MAVLink学习之路】</a>，在我的博客分类“MAVLink学习之路”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【MAVLink学习之路】即可查看。</p><h1 id="二、关于MAVLink"><a href="#二、关于MAVLink" class="headerlink" title="二、关于MAVLink"></a>二、关于MAVLink</h1><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><p>MAVLink：Micro Air Vehicle Link，即微型飞行器连接通信协议，于2009年初由Lorenz Meier首次发布。</p><p>Mavlink协议是在串口通讯基础上的一种更高层的开源通讯协议。</p><p>MAVLink是一种非常轻量级的通信协议，主要用于与无人机（以及板载无人机组件之间）进行通信。</p><h2 id="2-2-主要特征"><a href="#2-2-主要特征" class="headerlink" title="2.2 主要特征"></a>2.2 主要特征</h2><p><strong>1.效率很高</strong><br>MAVLink V1每帧最少只有8个字节的数据，包括帧头和数据包丢弃检测；<br>MAVLink V2每帧最少只有14个字节的数据(是一个更加安全和可扩展的协议);</p><p><strong>2.非常可靠</strong><br>自2009年以来，MAVLink一直被用于在各种不同且具有挑战性的通信信道上的许多不同车辆，地面站（和其他节点）之间进行通信。它提供了检测数据包丢失，损坏和数据包身份验证的方法。</p><p><strong>3.支持多种编程语言</strong><br>可在多种MCU（如：STM32、Atmega、ARM7）和操作系统（如：Windows，Linux，MacOS，Android和iOS）上运行。</p><p><strong>4.支持网络上最多255个并发系统</strong></p><h2 id="2-3-参考网址"><a href="#2-3-参考网址" class="headerlink" title="2.3 参考网址"></a>2.3 参考网址</h2><p>官网：<a href="https://mavlink.io/en" target="_blank" rel="noopener">https://mavlink.io/en</a></p><p>地面站：<a href="http://qgroundcontrol.org/mavlink/start" target="_blank" rel="noopener">http://qgroundcontrol.org/mavlink/start</a></p><p>维基百科：<a href="https://en.wikipedia.org/wiki/MAVLink" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MAVLink</a></p><h1 id="三、MAVLink协议格式"><a href="#三、MAVLink协议格式" class="headerlink" title="三、MAVLink协议格式"></a>三、MAVLink协议格式</h1><p>目前MAVLink有两个版本：V1和V2版本，差异及详情请看下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink/1.MAVLink%20V1%E5%92%8CV2%E6%A0%BC%E5%BC%8F%E5%B7%AE%E5%BC%82.png?raw=true"><br></table><p>MAVLink V2是V1的拓展版本，是一个<strong>更加安全和可扩展</strong>的协议。</p><p>由于市面上应用较广的还是V1版本，且支持的编程语言也是V1多余V2。因此，接下来（MAVLink学习之路）我都会结合MAVLink V1来讲述（学会V1，V2和容易就掌握了）。</p><h2 id="3-1-MAVLink-V1格式"><a href="#3-1-MAVLink-V1格式" class="headerlink" title="3.1 MAVLink V1格式"></a>3.1 MAVLink V1格式</h2><p>MAVLink通信内容包含常见通信协议帧头、帧尾、长度、校验等。协议格式及详情见下图：</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/MAVLink/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink/%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png?raw=true"><br></table><h1 id="四、MAVLink使用方法和步骤"><a href="#四、MAVLink使用方法和步骤" class="headerlink" title="四、MAVLink使用方法和步骤"></a>四、MAVLink使用方法和步骤</h1><p>MAVLink之所以受广大无人机开发朋友的喜爱，原因就在于MAVLink移植方便、操作简单，以及它的兼容性很好（当然，这些都是它的优点，缺点肯定也是有的）。</p><p>要想使用MAVLink，一些基本的操作肯定还是得有。方便初学者对MAVLinK有进一步的认识，我先罗列主要步骤。</p><h2 id="4-1-主要步骤"><a href="#4-1-主要步骤" class="headerlink" title="4.1 主要步骤"></a>4.1 主要步骤</h2><p>1.下载相应安装包及工具</p><p>2.环境搭建</p><p>3.通过xml配置MSG</p><p>4.移植到STM32</p><p>5.结合实例应用编程</p><p>当然，以上几点只是概要内容，后续的文章会详细讲述其中的内容，敬请等待…</p><h1 id="五、说明"><a href="#五、说明" class="headerlink" title="五、说明"></a>五、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。</p><p>2.本文由我一个人编辑并整理，难免存在一些错误。</p><p>3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。  </p><h1 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;1.MAVLink是一种非常轻量级的通信协议，在简单的8位单片机上也可以运行。&lt;/p&gt;
&lt;p&gt;2.MAVLink的初衷主要是用于无人机上，但它的通用性和可移植性非常好，它也可以应用于其它很多场合。&lt;/p&gt;
&lt;p&gt;3.MAVLink的设计方式值得学习通信的朋友研究一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，学习无人机开发、学习通信原理、需要实现设备间通信的朋友都值得参看本文。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MAVLink学习之路" scheme="http://www.strongerhuang.com/categories/MAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="MAVLink" scheme="http://www.strongerhuang.com/tags/MAVLink/"/>
    
      <category term="无人机" scheme="http://www.strongerhuang.com/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="通信协议" scheme="http://www.strongerhuang.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程.html</id>
    <published>2018-08-23T10:30:00.000Z</published>
    <updated>2018-08-23T09:41:02.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　本文对【EWSTM8系列教程】做了整理并汇总，会随着系列教程的更新而更新。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><a id="more"></a><h1 id="二、教程列表"><a href="#二、教程列表" class="headerlink" title="二、教程列表"></a>二、教程列表</h1><p><a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_IAR%E4%BB%8B%E7%BB%8D%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E5%92%8C%E6%B3%A8%E5%86%8C.html">1.EWSTM8系列教程01_IAR介绍、下载、安装和注册</a></p><p><a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html">2.EWSTM8系列教程02_新建基础软件工程</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_%E4%B8%BB%E7%AA%97%E5%8F%A3%E3%80%81%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%9A%84%E6%A6%82%E8%BF%B0.html">3.EWSTM8系列教程03_主窗口、工具栏的概述</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.html">4.EWSTM8系列教程04_菜单概述（一）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html">5.EWSTM8系列教程05_菜单概述（二）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">6.EWSTM8系列教程06_工程节点选项配置（一）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html">7.EWSTM8系列教程07_工程节点选项配置（二）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">8.EWSTM8系列教程08_IDE选项配置（一）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html">9.EWSTM8系列教程09_IDE选项配置（二）</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html">10.EWSTM8系列教程10_一个工程添加多个节点</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B.html">11.EWSTM8系列教程11_一个工作空间添加多个工程</a></p><p><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.html">12.EWSTM8系列教程12_IAR文件类型描述</a></p><p>正在努力更新中，敬请等待……</p><h1 id="三、说明"><a href="#三、说明" class="headerlink" title="三、说明"></a>三、说明</h1><p>1.该文档仅供个人学习使用，版权所有，禁止商用。<br>2.本文主要针对个人学习使用的朋友，若你是商业用途，建议购买正版软件。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。</p><h1 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　本文对【EWSTM8系列教程】做了整理并汇总，会随着系列教程的更新而更新。&lt;/p&gt;
&lt;p&gt;　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于&lt;a href=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信公众号【EmbeddedDevelop】&lt;/a&gt;，关注微信公众号回复【EWSTM8系列教程】即可查看。&lt;/p&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程12_IAR文件类型描述</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程12_IAR文件类型描述.html</id>
    <published>2018-08-23T10:00:00.000Z</published>
    <updated>2018-08-23T09:51:55.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>1.你保存、或者打包拷贝一个项目时，你会<strong>删掉不必要的文件</strong>吗？<br>2.你知道这些<strong>eww、ewp、ewd……</strong>是什么文件吗？</p><table><br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0/1.%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.png?raw=true"><br></table><a id="more"></a><table><br>主要文件：<br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0/2.%E6%B5%8F%E8%A7%88%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.gif?raw=true"><br></table><p><strong>现象or疑问</strong>：<br>1.购买一块开发板，厂家提供的源代码例程没有几个，但文件大小却有几百兆。<br>2.百度网盘下载一个别人提供的代码压缩包，大小几十兆。<br>3.打开别人下载的源代码工程，各种类型文件混杂在一起。<br>4.我看有些人提供的源代码没有dep文件，这个文件可以删除吗？ 删除了会有什么影响？</p><p>　　当你看完本文，理解这些文件类型的含义，你就不会有上面这些烦恼了。</p><p>　　本文章收录于<a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【EWSTM8系列教程】</a>，在我的博客分类“EWSTM8系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><h1 id="二、IAR文件类型概述"><a href="#二、IAR文件类型概述" class="headerlink" title="二、IAR文件类型概述"></a>二、IAR文件类型概述</h1><p>　　IAR中用到的文件类型很多，大概有四五十种，一般就是<strong>源代码和工程</strong>文件（含配置，编译生成文件）。下面会<strong>重点讲述常用的文件类型</strong>，一些不重要的，或者不常见的只简单概述。</p><p><strong>分类</strong>：<br>1.源代码类：.c、 .h、 .cpp、 .asm、 .a等；<br>2.工程文件类：.eww、 .ewp、 .ewd、 .ewt、 .dep等；<br>3.Exe文件类：hex、 .bin、 .out等；<br>4.List类：.map、 .lst等；<br>5.Obj类：.o、 .pbi、 .xcl等；<br>6.settings类：.dbgdt、 .bat、 .ps1等；</p><p>下面我就按照上面分类，进行分章节讲述，重要的会标记出来，请注意查看标注内容。</p><h1 id="三、源代码类文件"><a href="#三、源代码类文件" class="headerlink" title="三、源代码类文件"></a>三、源代码类文件</h1><p>这类文件类型编程时我们最先了解的，不多说，只概述。<br><strong>1.c</strong><br>C语言源代码文件</p><p><strong>2.h</strong><br>头文件</p><p><strong>3.cpp</strong><br>C plus plus的意思，也就是C++源代码文件</p><p><strong>4.asm</strong><br>汇编源代码文件</p><p><strong>5.s</strong><br>汇编程序源代码文件</p><p><strong>6.a</strong><br>IAR的库文件</p><p><strong>7.inc</strong><br>汇编头文件</p><h1 id="四、工程类文件"><a href="#四、工程类文件" class="headerlink" title="四、工程类文件"></a>四、工程类文件</h1><p>这类文件比较重要，下面<strong>前两个eww、 ewp是一个项目中最重要的文件，是不可删除的文件</strong>。</p><p><strong>1.eww</strong><br>全拼：Embedded Workbench Workspace，即IAR工作空间文件（不可删除）。</p><p>我们新建一个工作空间就会产生该文件，一个项目必须包含一个eww文件。所以，改文件不可删除。</p><p>参看文章：<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B.html">EWSTM8系列教程11_一个工作空间添加多个工程</a></p><p><strong>2.ewp</strong><br>全拼：Embedded Workbench Project，即IAR工程文件（不可删除）。</p><p>新建一个工程，工程包含的信息就在这个文件里面。</p><p>参看文章：<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html">EWSTM8系列教程10_一个工程添加多个节点</a></p><p><strong>3.ewd</strong><br>工程配置文件，主要是Debug相关的配置。删除之后Debug相关的配置恢复默认设置（一般不建议删除）。</p><p><strong>4.ewt</strong><br>工程配置文件，主要是工程静态分析（C-STAT and C-RUN）配置文件。C-STAT and C-RUN文件</p><p>Project -&gt; Options -&gt; Static Analysis可以看见C-STAT，也就是静态分析相关的文件，如果不配置静态分析，可以删除这个ewt文件。</p><p><strong>5.dep</strong><br>Dep：Dependency information，即依赖信息。</p><p><strong>6.icf</strong><br>链接器配置文件： Project -&gt; Options -&gt; Linker -&gt; Config -&gt; configuration file。</p><h1 id="五、Exe类文件"><a href="#五、Exe类文件" class="headerlink" title="五、Exe类文件"></a>五、Exe类文件</h1><p>默认位于Exe文件夹下面的文件，如Project\Debug\Exe，这类文件可删除。</p><p><strong>1.hex</strong><br>Intel格式固件文件（用于下载的可执行文件）。Project -&gt; Options -&gt; Output Coverter。</p><p><strong>2.Bin</strong><br>二进制格式固件文件（用于下载的可执行文件），与hex主要区别在于：bin文件不包含地址信息。</p><p><strong>3.out</strong><br>编译输出的调试信息文件，若不输出调试信息，则没有。</p><h1 id="六、List类文件"><a href="#六、List类文件" class="headerlink" title="六、List类文件"></a>六、List类文件</h1><p>默认位于List文件夹下面的列表文件，如Project\Debug\List，这类文件可删除。</p><p><strong>1.map</strong><br>映射文件。<br>该文件是分析代码内存占用情况的重要的文件，但可以删除。很多遇到问题之后会进入硬件故障（HardFault_Handler）等中断，就需要进一步分析map文件。</p><h1 id="七、Obj类文件"><a href="#七、Obj类文件" class="headerlink" title="七、Obj类文件"></a>七、Obj类文件</h1><p>默认位于Obj文件夹下面的目标文件，如Project\Debug\Obj。在编译之后会输出许多这类目标文件，属于中间文件。因此，这类文件之后保存工程时可以删除。<br><strong>1.o</strong><br>目标模块文件，该文件就是对应每一个.c文件编译后的文件“Object module”。</p><p><strong>2.browse</strong><br>浏览文件，主要用于“Go to Definition of”功能。使能开关：Tools -&gt; Options -&gt; Project -&gt; Generatie browse information。</p><p><strong>3.pbi、.pbd</strong><br>主要也是用于浏览信息的文件。</p><p><strong>4.inf</strong><br>链接器配置文件。</p><p><strong>5.xcl</strong><br>扩展命令行文件</p><h1 id="八、settings类"><a href="#八、settings类" class="headerlink" title="八、settings类"></a>八、settings类</h1><p>默认位于settings文件夹下面的文件，如Project\settings。这类文件属于中间文件，可以删除。</p><p><strong>1.wsdt</strong><br>工作区桌面设置文件，打开工作空间就会存在该文件。</p><p><strong>2.bat</strong><br>批处理文件</p><p>好啦，就讲述到这里，更多文件类型及说明请看下图：</p><table><br>汇总文件类型：<br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0/3.IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.png?raw=true"><br></table><h1 id="九、说明"><a href="#九、说明" class="headerlink" title="九、说明"></a>九、说明</h1><p>1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。<br>2.该文档仅供个人学习使用，版权所有，禁止商用。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 </p><h1 id="十、最后"><a href="#十、最后" class="headerlink" title="十、最后"></a>十、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;1.你保存、或者打包拷贝一个项目时，你会&lt;strong&gt;删掉不必要的文件&lt;/strong&gt;吗？&lt;br&gt;2.你知道这些&lt;strong&gt;eww、ewp、ewd……&lt;/strong&gt;是什么文件吗？&lt;/p&gt;
&lt;table&gt;&lt;br&gt;&lt;img align=&quot;left&quot; width=&quot;600&quot; src=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0/1.%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.png?raw=true&quot;&gt;&lt;br&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程11_一个工作空间添加多个工程</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程11_一个工作空间添加多个工程.html</id>
    <published>2018-08-22T10:00:00.000Z</published>
    <updated>2018-08-22T08:38:16.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　如果你是初学者，还没有理解IAR中（工作空间 &gt; 工程 &gt; 节点）相关基础知识，建议先参看我的另外两篇文章：<br>　　<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">EWSTM8系列教程06_工程节点选项配置（一）</a><br>　　<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html">EWSTM8系列教程10_一个工程添加多个节点</a></p><p>　　当你明白工作空间和工程之间的关系，这篇文章的知识你很快就能明白了。</p><a id="more"></a><p>　　本文章收录于<a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【EWSTM8系列教程】</a>，在我的博客分类“EWSTM8系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><h1 id="二、工作空间与工程的关系"><a href="#二、工作空间与工程的关系" class="headerlink" title="二、工作空间与工程的关系"></a>二、工作空间与工程的关系</h1><p>　　本章节算是回顾知识点：工作空间与工程其实是包含的关系，一个工作空间可以包含多个工程。<br>下图是工作空间、 工程、 节点三者的关系：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/2.%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg?raw=true"><br></table><p><strong>提示：</strong><br>在IAR中叫<strong>Node（节点）</strong>，而在Keil中叫<strong>Target（目标）</strong>。其实这两者意思一样，都是隶属于工程的下一级。</p><h1 id="三、为什么一个工作空间要添加多个工程"><a href="#三、为什么一个工作空间要添加多个工程" class="headerlink" title="三、为什么一个工作空间要添加多个工程"></a>三、为什么一个工作空间要添加多个工程</h1><p>简单回答：<strong>为了统一管理项目</strong>。</p><p>例如：<br>1.某个项目有一个主机，多个从机，而且每个从机代码不一样。当公司有多个类似项目的情况下，公司为了统一管理项目，就会将一个项目规定为一个工作空间。</p><p>2.因公司很多工程都会使用到同样的代码（如算法库、标准外设库等），公司就会将这些工程整理到一个工作空间下。</p><p>当然，以上举例说的可能有点笼统，对于初学者，首先要掌握工程。</p><p>比如我之前文章提供的工程：STM8S-A01_GPIO基础知识、STM8S-A02_TIM精确延时、STM8S-A03_TIM定时中断……等。我可以将这些工程添加到一个工作空间下。</p><p>提示：<br>关于工作空间添加多工程的<strong>作用和意义</strong>，初学者不必深入理解，当你学到一定程度自然就明白了。</p><h1 id="四、工作空间如何添加多个工程"><a href="#四、工作空间如何添加多个工程" class="headerlink" title="四、工作空间如何添加多个工程"></a>四、工作空间如何添加多个工程</h1><p>工作空间添加工程可以说没有一点难度，添加一个工程10秒钟之内就能完成。而难点在于新建工程以及工程节点相关的配置。</p><p>本文工作空间添加工程，<strong>很多相关知识点</strong>是基于该系列教程前面分享的一些内容。主要两点内容：新建工程、节点选项配置。请参考下面文章：<br><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html">EWSTM8系列教程02_新建基础软件工程</a><br><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">EWSTM8系列教程06_工程节点选项配置（一）</a><br><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html">EWSTM8系列教程07_工程节点选项配置（二）</a></p><p>按照上面文章新建好工程及相应节点配置好之后，就可在工作空间中添加这些工程了。</p><p>这里默认新建并配置好了三个工程：Project1、Project2、Project3。将这三个工程添加到工作空间Workspace中。</p><p><strong>提示</strong>：<br>最后我将提供这个例子代码下载。但这里只是提供例子，Project1、2、3这三个工程的源代码和功能都类似（一般实际项目源码和功能不会相同）。同时，Project1、Workspace这种命名也是方便理解（请根据项目实际情况命名）。</p><h2 id="4-1-整理文件夹及文件"><a href="#4-1-整理文件夹及文件" class="headerlink" title="4.1 整理文件夹及文件"></a>4.1 整理文件夹及文件</h2><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/1.%E6%95%B4%E7%90%86%E6%96%87%E4%BB%B6%E5%A4%B9.png?raw=true"><br></table><h2 id="4-2-新建工作空间"><a href="#4-2-新建工作空间" class="headerlink" title="4.2 新建工作空间"></a>4.2 新建工作空间</h2><p>打开IAR软件 -&gt; File -&gt; New Workspace -&gt; Save Workspace As…保存在上面新建的Workspace文件夹下面。</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/2.%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4.png?raw=true"><br></table><p>具体请看下面动画效果：</p><table><br>新建工作空间动画效果：<br><img align="left" width="800" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/3.%E6%96%B0%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.gif?raw=true"><br></table><h2 id="4-3-添加已存在工程"><a href="#4-3-添加已存在工程" class="headerlink" title="4.3 添加已存在工程"></a>4.3 添加已存在工程</h2><p>本文默认工程已经建立（具体过程请参考文章“新建基础软件工程”），所以只需要添加已存在工程即可。</p><p>菜单Project -&gt; Add Existing Project -&gt; 选择需要添加的工程（重复一样动作，添加三个已存在工程）：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/4.%E6%B7%BB%E5%8A%A0%E5%B7%B2%E5%AD%98%E5%9C%A8%E5%B7%A5%E7%A8%8B.png?raw=true"><br></table><table><br>添加已存在工程动画效果：<br><img align="left" width="800" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/5.%E6%B7%BB%E5%8A%A0%E5%B7%B2%E5%AD%98%E5%9C%A8%E5%B7%A5%E7%A8%8B%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.gif?raw=true"><br></table><h2 id="4-4-工作空间与工程预览"><a href="#4-4-工作空间与工程预览" class="headerlink" title="4.4 工作空间与工程预览"></a>4.4 工作空间与工程预览</h2><p>按照上面步骤最后得出工作空间和工程的结构，如下图：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B/6.%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E9%A2%84%E8%A7%88.png?raw=true"><br></table><p><strong>再次提示</strong>：<br>此方法仅仅提供一种方法和思路，方便大家学习和掌握。具体内容根据实际项目情况而定。</p><h1 id="五、多工程工作空间源代码下载"><a href="#五、多工程工作空间源代码下载" class="headerlink" title="五、多工程工作空间源代码下载"></a>五、多工程工作空间源代码下载</h1><p>为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。<br>百度网盘下载地址：<a href="https://pan.baidu.com/s/1qIfaF0c-I_I4xGveFqwLDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qIfaF0c-I_I4xGveFqwLDA</a><br>密码: mpm2</p><p>GitHub下载地址：<a href="https://github.com/EmbeddedDevelop/STM8S_Multi-Project.git" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop/STM8S_Multi-Project.git</a></p><p>（<strong>提示</strong>：下载链接后期可能会失效， 若失效请关注微信公众号获取）</p><h1 id="六、说明"><a href="#六、说明" class="headerlink" title="六、说明"></a>六、说明</h1><p>1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。<br>2.该文档仅供个人学习使用，版权所有，禁止商用。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 </p><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　如果你是初学者，还没有理解IAR中（工作空间 &amp;gt; 工程 &amp;gt; 节点）相关基础知识，建议先参看我的另外两篇文章：&lt;br&gt;　　&lt;a href=&quot;https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html&quot;&gt;EWSTM8系列教程06_工程节点选项配置（一）&lt;/a&gt;&lt;br&gt;　　&lt;a href=&quot;https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html&quot;&gt;EWSTM8系列教程10_一个工程添加多个节点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　当你明白工作空间和工程之间的关系，这篇文章的知识你很快就能明白了。&lt;/p&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程10_一个工程添加多个节点</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程10_一个工程添加多个节点.html</id>
    <published>2018-08-16T10:00:00.000Z</published>
    <updated>2018-08-22T08:38:06.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　使用IAR新建一个工程，默认会创建<strong>Debug（调试）</strong>和<strong>Release（释放）</strong>两个Node（节点）。</p><p>　　什么是节点？ 为什么要创建这两个节点？ 创建多个节点目的和意义？ 如何创建多个节点？ 带着这些疑问来学习本文才会有更多收获。<br><a id="more"></a></p><p>　　本文章收录于<a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【EWSTM8系列教程】</a>，在我的博客分类“EWSTM8系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><h1 id="二、什么是节点"><a href="#二、什么是节点" class="headerlink" title="二、什么是节点"></a>二、什么是节点</h1><p>　　本文讲述添加多个节点，就需要了解什么是节点。之前文章<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">《EWSTM8系列教程06_工程节点选项配置（一）》</a>初略讲述了一下<strong>工作空间、 工程、 节点</strong>三者的关系：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/2.%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg?raw=true"><br></table><p><strong>提示：</strong><br>在IAR中叫<strong>Node（节点）</strong>，而在Keil中叫<strong>Target（目标）</strong>。其实这两者意思一样，都是隶属于工程的下一级。</p><h1 id="三、Debug与Release节点区别"><a href="#三、Debug与Release节点区别" class="headerlink" title="三、Debug与Release节点区别"></a>三、Debug与Release节点区别</h1><p>新建一个工程，默认创建两个节点，如下图：</p><table><br><img align="left" width="450" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/1.%E9%80%89%E6%8B%A9%E8%8A%82%E7%82%B9.png?raw=true"><br></table><p>在上一节了解了<strong>工程与节点</strong>之间的关系，那么为什么要一个工程下创建两个节点呢？</p><p>两个节点的区别：<br><strong>Debug节点</strong>：主要用于调试使用，包含调试信息。<br><strong>Release节点</strong>：主要用于生成代码（正式产品），不包含调试信息。</p><p>细心的朋友会发现，这两个<strong>节点选项配置</strong>中有几个地方不同，如：C/C++ Compiler下的Output和Preprocessor选项、Assembler下的Output选项等。</p><p>关于节点选项配置内容可以参看文章<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">《EWSTM8系列教程06_工程节点选项配置（一）》</a>。</p><p>看了Debug和Release这两个节点的区别，相信你应该大概理解了为什么一个工程下要创建多个节点了。</p><p>其实，实际项目中还有很多用途，比如：同款产品，不同配置（不同芯片型号，不同编译等级…等节点选项配置不同）。</p><h1 id="四、如何创建多个节点"><a href="#四、如何创建多个节点" class="headerlink" title="四、如何创建多个节点"></a>四、如何创建多个节点</h1><h2 id="4-1-主要步骤"><a href="#4-1-主要步骤" class="headerlink" title="4.1 主要步骤"></a>4.1 主要步骤</h2><p>1.创建一个工程<br>2.添加组，添加文件<br>3.工程节点选项配置<br>4.基于某一个节点添加新的节点</p><p>其实这四个步骤中前三个都已经在文章<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html">《EWSTM8系列教程02_新建基础软件工程》</a>中实现了，这里列出来主要是给初学者一个（从前到后的）提示。</p><p>下面就基于<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html">《EWSTM8系列教程02_新建基础软件工程》</a>建好的工程，在Debug节点基础上添加一个Test节点。</p><h2 id="4-2-添加Test节点"><a href="#4-2-添加Test节点" class="headerlink" title="4.2 添加Test节点"></a>4.2 添加Test节点</h2><p><strong>1.Project -&gt; Edit Configurations进入编辑配置</strong></p><table><br><img align="left" width="450" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/2.%E7%BC%96%E8%BE%91%E9%85%8D%E7%BD%AE.png?raw=true"><br></table><p><strong>2.点击“New”进入添加新节点配置</strong></p><table><br><img align="left" width="450" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/3.%E6%96%B0%E9%85%8D%E7%BD%AE.png?raw=true"><br></table><p>A.填写节点名称；<br>B.基于某节点，这里相当于拷贝选择节点选项配置；<br>C.默认设置为Debug或Release;</p><p>配置好之后，点击OK，再点击OK就行了。</p><p><strong>3.修改节点选项配置</strong><br>比如：修改Test节点输出格式从hex格式修改为bin格式；</p><p>选择Test节点 -&gt; 选中节点右键 -&gt; Options -&gt; Output Converter -&gt;修改成bin格式。具体操作可以参看下面动画效果：</p><table><br>修改节点选项配置动画效果：<br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/4.%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE.gif?raw=true"><br></table><p><strong>最后提示：</strong><br>　　多个节点之间的区别总结来说就是：各自节点的选项配置不同。当然，可能就一个选项配置不同，也可能多个。节点选项的配置内容很多，请参看<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">《EWSTM8系列教程06_工程节点选项配置（一）》</a>。</p><h1 id="五、多节点工程源代码下载"><a href="#五、多节点工程源代码下载" class="headerlink" title="五、多节点工程源代码下载"></a>五、多节点工程源代码下载</h1><p>为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。<br>百度网盘下载地址：<a href="https://pan.baidu.com/s/16elpok-5IdPYoeNGXXFszw" target="_blank" rel="noopener">https://pan.baidu.com/s/16elpok-5IdPYoeNGXXFszw</a><br>密码：m9pa</p><p>GitHub下载地址：<a href="https://github.com/EmbeddedDevelop/STM8S_Multi-Node.git" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop/STM8S_Multi-Node.git</a></p><p>（提示：下载链接后期可能会失效， 请关注微信公众号公告消息）</p><h1 id="六、说明"><a href="#六、说明" class="headerlink" title="六、说明"></a>六、说明</h1><p>1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。<br>2.该文档仅供个人学习使用，版权所有，禁止商用。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 </p><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　使用IAR新建一个工程，默认会创建&lt;strong&gt;Debug（调试）&lt;/strong&gt;和&lt;strong&gt;Release（释放）&lt;/strong&gt;两个Node（节点）。&lt;/p&gt;
&lt;p&gt;　　什么是节点？ 为什么要创建这两个节点？ 创建多个节点目的和意义？ 如何创建多个节点？ 带着这些疑问来学习本文才会有更多收获。&lt;br&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程09_IDE选项配置（二）</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程09_IDE选项配置（二）.html</id>
    <published>2018-08-15T10:00:00.000Z</published>
    <updated>2018-08-15T09:03:05.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　上一篇文章<a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html">《EWSTM8系列教程08_IDE选项配置（一）》</a>讲述了IDE选项中前五项（<strong>Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息</strong>）的内容。</p><p>　　本文讲述剩余的几项内容：<strong>Project工程、Source Code Control源代码控制、Debugger调试器、Stack堆栈、Terminal I/O终端</strong>（Terminal I/O项只有在调试模式下才有）。<br><img width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/1.IDE%E5%90%8E%E4%BA%94%E9%A1%B9%E9%85%8D%E7%BD%AE.png?raw=true"></p><a id="more"></a><p>　　本文章收录于<a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【EWSTM8系列教程】</a>，在我的博客分类“EWSTM8系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><h1 id="二、Project工程"><a href="#二、Project工程" class="headerlink" title="二、Project工程"></a>二、Project工程</h1><p>该IDE选项配置与工程相关，比如下面讲述的在编译工程的时遇到错误是否停止编译、在编译之前保存Workspace工作空间、Project工程等。</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/2.Project%E5%B7%A5%E7%A8%8B.png?raw=true"><br></table><p>此页面用于<strong>Make和Build命令</strong>设置选项。</p><p><strong>1.Stop build operation on：在如下情况停止编译操作</strong><br>A.Never：从不停止编译<br>B.Warnings：遇到警告停止编译<br>C.Errors：遇到错误停止编译</p><p><strong>2.Save editor windows before building：在编译之前保存编辑（修改）过的文件</strong><br>A.Never：从不保存<br>B.Ask：询问是否保存<br>C.Always：总是保存</p><p><strong>3.Save workspace and projects before building：在编译之前保存工作空间和工程</strong><br>A.Never：从不保存<br>B.Ask：询问是否保存<br>C.Always：总是保存</p><p><strong>4.Make before debugging：在调试之前编译（Make）一下</strong><br>A.Never：从不编译<br>B.Ask：询问是否编译<br>C.Always：总是编译</p><p><strong>5.Reload last workspace at startup：启动IAR时重新加载（打开）最近的工作空间</strong></p><p><strong>6.Play a sound after build operations：在编译操作之后播放声音</strong></p><p><strong>7.Generate browse information：生成浏览信息</strong><br>比如：Go to Definition跟踪代码的信息</p><p><strong>8.No source browser and build status updates when the IDE is not the foreground process：当IDE不是前台进程时，不浏览源码和编译状态等更新操作</strong></p><p><strong>9.Enable project connections：使能工程链接</strong><br>使能该选项，需结合Project -&gt; Add Project Connection一起操作；</p><p><strong>10.Enable parallel build：使能并行编译</strong><br>编译器在几个并行进程中运行，以便更好地使用CPU中的可用内核。后面参数为并行处理数。</p><h1 id="三、Source-Code-Control源代码控制"><a href="#三、Source-Code-Control源代码控制" class="headerlink" title="三、Source Code Control源代码控制"></a>三、Source Code Control源代码控制</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/3.Source%20Code%20Control%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6.png?raw=true"><br></table><p><strong>1.Keep items checked out when checking in：当检查时保持项目输出</strong></p><p><strong>2.Save editor windows before performing source code control commands：在执行源代码控制命令之前保存编辑器窗口</strong><br>A.Never：从不保存<br>B.Ask：询问是否保存<br>C.Always：总是保存</p><p><strong>提示</strong>：<br>该IDE配置选项属于老版本配置选项，不适合新版本。</p><h1 id="四、Debugger调试器"><a href="#四、Debugger调试器" class="headerlink" title="四、Debugger调试器"></a>四、Debugger调试器</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/4.Debugger%E8%B0%83%E8%AF%95%E5%99%A8.png?raw=true"><br></table><p>此页面特定用于<strong>调试器环境</strong>的配置。</p><p><strong>1.When source resolves to multiple function instances：当源解析为多个函数实例时</strong><br>Automatically choose all instances：自动选择所有实例</p><p><strong>2.Source code color in disassembly window：汇编窗口源代码颜色</strong></p><p><strong>3.Step into functions：跳入运行函数</strong><br>单步（Step into）调试时执行的操作：<br>All functions：（一步一步）跳入所有函数<br>Functions with source only：只跳入（当前）源代码函数</p><p><strong>4.STL container expansion：STL容器扩展</strong><br>Depth：深入数</p><p><strong>5.Update intervals：更新时间间隔</strong><br>指定Live Watch窗口和Memory窗口的内容更新的频率（单位：毫秒）。</p><p><strong>6.Default integer format：默认整型格式</strong><br>Binary：二进制<br>Octal：八进制<br>Decimal：十进制<br>Hexadecimal：十六进制</p><p><strong>7.Window classification by background color：窗口分类的背景颜色</strong><br>比如：汇编窗口是一种背景色，内存窗口又是另外一种背景色。</p><h1 id="五、Stack堆栈"><a href="#五、Stack堆栈" class="headerlink" title="五、Stack堆栈"></a>五、Stack堆栈</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/5.Stack%E5%A0%86%E6%A0%88.png?raw=true"><br></table><p>此页面用于<strong>堆栈窗口</strong>的选项配置。</p><p><strong>1.Enable graphical stack display and stack usage tracking：使能图形堆栈显示和堆栈使用跟踪</strong><br>stack usage threshold：堆栈使用阈值<br>Warn when exceeding stack threshold：超过堆栈阈值时发出警告</p><p><strong>2.Warn when stack pointer is out of bounds：当堆栈指针超出范围时发出警告</strong></p><p><strong>3.Stack pointer(s) not valid until program reaches：堆栈指针直到程序到达如下位置（main）时才有效</strong><br>在应用程序代码中指定您希望堆栈显示和验证发生的位置，如图，在程序运行到main函数才有效（进行校验）。</p><p><strong>4.Warnings：警告</strong><br>选择应该发出警告的位置：<br>Log：日志<br>Log and alert：日志和警告</p><p><strong>5.Limit stack display to：限制堆栈显示大小</strong><br>比如：如果你有一个大的堆栈，或者你只需要查看堆栈的最上面的部分，该选项就有用。</p><p>提示:<br>堆栈窗口不会影响应用程序的执行性能，但它可能会读取大量数据，以便在执行停止时更新显示的信息。</p><p>六、Terminal I/O终端</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/6.Terminal%20IO%E7%BB%88%E7%AB%AF.png?raw=true"><br></table><p>此页面只有在调试模式才由，用于<strong>I/O终端</strong>的选项配置。</p><p><strong>1.Input mode：输入模式</strong><br>终端I/O输入选择：<br><strong>Keyboard</strong>：键盘输入<br>　Buffered：Buf模式<br>　Direct：直接输入模式<br><strong>File</strong>：文件（内容）作为输入<br>　Text：文本<br>　Binary：二进制</p><p><strong>2.Input echoing：输入呼应</strong><br>Log file：日志文件<br>Terminal I/O window：终端窗口</p><p><strong>3.Encoding：编码选择</strong><br>System<br>UTF-8</p><p><strong>4.Show target reset in Terminal I/O window：在终端I/O窗口显示复位目标</strong></p><h1 id="七、说明"><a href="#七、说明" class="headerlink" title="七、说明"></a>七、说明</h1><p>1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。<br>2.该文档仅供个人学习使用，版权所有，禁止商用。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 </p><h1 id="八、最后"><a href="#八、最后" class="headerlink" title="八、最后"></a>八、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　上一篇文章&lt;a href=&quot;https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html&quot;&gt;《EWSTM8系列教程08_IDE选项配置（一）》&lt;/a&gt;讲述了IDE选项中前五项（&lt;strong&gt;Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息&lt;/strong&gt;）的内容。&lt;/p&gt;
&lt;p&gt;　　本文讲述剩余的几项内容：&lt;strong&gt;Project工程、Source Code Control源代码控制、Debugger调试器、Stack堆栈、Terminal I/O终端&lt;/strong&gt;（Terminal I/O项只有在调试模式下才有）。&lt;br&gt;&lt;img width=&quot;500&quot; src=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/1.IDE%E5%90%8E%E4%BA%94%E9%A1%B9%E9%85%8D%E7%BD%AE.png?raw=true&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
  <entry>
    <title>EWSTM8系列教程08_IDE选项配置（一）</title>
    <link href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8系列教程08_IDE选项配置（一）.html</id>
    <published>2018-08-11T10:00:00.000Z</published>
    <updated>2018-08-15T09:17:05.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h1><p>　　前面两篇文章针对的是<strong>工程节点各选项</strong>的配置，而本文讲述的是关于<strong>集成开发环境（IDE）各选项</strong>的配置。</p><p>　　本文讲述的内容包含字体、快捷键、语言、编辑、消息等许多与<strong>IDE相关的配置</strong>。因为属于Tools菜单，我也把它称为“工具配置选项”。也就是菜单Tools -&gt; Options下IDE选项，如下图：<br><img width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/1.IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE.png?raw=true"></p><a id="more"></a><p>　　由于IDE选项的配置较多，我将其分为<strong>IDE选项配置（一）和IDE选项配置（二）</strong>两篇文章来讲述，本文主要讲述前五项内容：<strong>Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息</strong>。</p><p>　　本文章收录于<a href="http://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html">【EWSTM8系列教程】</a>，在我的博客分类“EWSTM8系列教程”也能查找到。</p><p>　　为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于<a href="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/images/EmbeddedDevelop.jpg?raw=true" target="_blank" rel="noopener">微信公众号【EmbeddedDevelop】</a>，关注微信公众号回复【EWSTM8系列教程】即可查看。</p><h1 id="二、Common-Fonts普通字体"><a href="#二、Common-Fonts普通字体" class="headerlink" title="二、Common Fonts普通字体"></a>二、Common Fonts普通字体</h1><h2 id="2-1-Custom-Tool-Configuration自定义工具配置"><a href="#2-1-Custom-Tool-Configuration自定义工具配置" class="headerlink" title="2.1 Custom Tool Configuration自定义工具配置"></a>2.1 Custom Tool Configuration自定义工具配置</h2><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/2.Common%20Fonts%E6%99%AE%E9%80%9A%E5%AD%97%E4%BD%93.png?raw=true"><br></table><p>本节内容主要是配置<strong>除编辑窗口（如代码）之外</strong>的其它窗口的字体设置（如工程窗口、编译窗口等）。</p><p><strong>1.Fixed Width Font：固定宽度字体</strong><br>比如：Sysbolic Memory窗口中数据<strong>“0xCDCDCDCD”</strong>的字体。</p><p><strong>2.Proportional Width Font：比例宽度字体</strong><br>比如：Sysbolic Memory窗口中数据<strong>“Data”</strong>这个标识的字体。</p><p>从字面意思翻译有点别扭，请结合下面动画效果理解。</p><table><br>普通字体配置动画效果：<br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/3.%E5%B8%B8%E8%A7%81%E5%AD%97%E4%BD%93%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.gif?raw=true"><br></table><p><strong>提示：</strong><br>这里的字体不包含编辑器的字体，编辑器相关的字体见下面【5.3Colors and Fonts颜色和字体】说明。</p><h1 id="三、Key-Bindings快捷键配置"><a href="#三、Key-Bindings快捷键配置" class="headerlink" title="三、Key Bindings快捷键配置"></a>三、Key Bindings快捷键配置</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/4.Key%20Bindings%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%85%8D%E7%BD%AE.png?raw=true"><br></table><p><strong>Key Bindings</strong>：直译为：键绑定，也就是配置快捷键。</p><p>Menu主菜单，下面对应的就是其中的子菜单。关于主菜单和子菜单里面具体内容，建议参看该系列教程：<br><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.html">EWSTM8系列教程04_菜单概述（一）</a><br><a href="https://www.strongerhuang.com/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html">EWSTM8系列教程05_菜单概述（二）</a></p><p>具体操作：选择主菜单，再选中子菜单，按住需要配置的快捷键，点击<strong>Set或Add</strong>添加，点击<strong>Clear</strong>删除，点击<strong>Reset All</strong>复位所有快捷键（出厂默认）。具体可参看下面动画效果。</p><p><strong>提示：</strong><br><strong>primary：首要</strong>快捷键<br><strong>Alias：次要</strong>（别名）快捷键<br>所以：点击Set是设置首要快捷键，点击Add是添加次要快捷键。</p><table><br>快捷键配置动画效果：<br><img align="left" width="600" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/5.%E5%BF%AB%E6%8D%B7%E9%94%AE%E9%85%8D%E7%BD%AE%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.gif?raw=true"><br></table><h1 id="四、Language语言"><a href="#四、Language语言" class="headerlink" title="四、Language语言"></a>四、Language语言</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/6.Language%E8%AF%AD%E8%A8%80.png?raw=true"><br></table><p>这个配置选项比较简单，选择语言，目前EWSTM8只支持英语，像EWARM支持英语和日语。</p><h1 id="五、Editor编辑器"><a href="#五、Editor编辑器" class="headerlink" title="五、Editor编辑器"></a>五、Editor编辑器</h1><p>编辑器选项下面还包含<strong>External Editor外部编辑器、Setup Files设置文件、Colors and Fonts颜色和字体</strong>三个子选项。</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/7.Editor%E7%BC%96%E8%BE%91%E5%99%A8.png?raw=true"><br></table><h2 id="第1区域：Tab"><a href="#第1区域：Tab" class="headerlink" title="第1区域：Tab"></a>第1区域：Tab</h2><p><strong>1.Tab size：Tab键尺寸</strong><br>假如为2，则一个Tab键尺寸相当于2个空格大小。</p><p><strong>2.Indent size：缩进尺寸</strong></p><p><strong>3.Tab Key Function：Tab键功能</strong><br>Insert tab：插入Tab符<br>Indent with spaces：缩进为空格符</p><h2 id="第2区域：边缘线"><a href="#第2区域：边缘线" class="headerlink" title="第2区域：边缘线"></a>第2区域：边缘线</h2><p><strong>1.Show right margin：显示右边缘线</strong><br>Printing edge：打印边缘（打印范围）<br>Columns：根据列数显示</p><p>一条浅灰色的竖线，默认勾选上并显示（第80列）</p><h2 id="第3区域：File-Encoding：文件编码"><a href="#第3区域：File-Encoding：文件编码" class="headerlink" title="第3区域：File Encoding：文件编码"></a>第3区域：File Encoding：文件编码</h2><p><strong>1.Default character encoding：默认字符编码</strong><br>有多种类型可选择，默认System（系统）；</p><p><strong>2.Auto-detect character encoding：自动检测字符编码</strong><br>勾选上则自动检测文件。</p><p><strong>3.EOL characters：结束符</strong><br>可选择：PC、 UNIX、 Preserve。</p><h2 id="第4区域：show：显示"><a href="#第4区域：show：显示" class="headerlink" title="第4区域：show：显示"></a>第4区域：show：显示</h2><p><strong>1.Syntax highlighting：语法高亮显示</strong><br>默认勾选，按照语法规则高亮显示文字。如关键字（if、 while），注释语句，预定于#include等。</p><p><strong>2.Auto indent：配置自动缩进</strong></p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/8.%E8%87%AA%E5%8A%A8%E7%BC%A9%E8%BF%9B%E9%85%8D%E7%BD%AE.png?raw=true"><br></table><p>勾选上，则自动缩进。<br>如上图，如果我在“case 0:”按下回车（换行），则在下一行自动缩进到return的<strong>r</strong>这个位置。（不勾选，则到每行的开始位置）</p><p><strong>3.Show line numbers：显示行数（见下图）</strong><br>这个很好理解，就是显示代码、文本前面的行数；</p><p><strong>4.Scan for changed files：扫描修改的文件</strong><br>比如：main.c在EWSTM8中打开（<strong>未修改</strong>），这时又通过其他软件把main.c打开，添加了一行i++代码，并保存。则这时将自动显示添加了一行i++的文件。</p><p>如果打开<strong>修改过</strong>，则会提示（是否更新，并显示那边添加了i++的文件）。</p><p><strong>5.Show bookmarks：显示书签（见下图）</strong><br>包含错误、警告、断点、书签等一些标记符号。</p><p><strong>6.Show fold margin：显示折叠边缘（见下图）</strong></p><p><strong>书签、行数、折叠说明图：</strong></p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/9.%E4%B9%A6%E7%AD%BE%E3%80%81%E8%A1%8C%E6%95%B0%E3%80%81%E6%8A%98%E5%8F%A0.png?raw=true"><br></table><p><strong>7.Enable virtual space：使能虚拟空间</strong><br>勾选上则光标可以放在编辑窗口任何一个位置编辑（则前面多处许多空格）。</p><p><strong>8.Remove trailing blanks：去除末尾的空白</strong><br>当保存文件时（如Ctrl+S），删除每行后面的空格符号。</p><p><strong>9.Auto code completion and parameter hints：自动代码完形和参数提示</strong></p><p><strong>10.Show source browser tooltips：显示源代码浏览器工具提示</strong></p><p><strong>11.Show line break characters：显示换行字符</strong><br>勾选则显示换行符。如下图：默认的换行符CR+LF（一般不建议勾选）</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/10.%E6%8D%A2%E8%A1%8C%E7%AC%A6.png?raw=true"><br></table><h2 id="5-1-External-Editor外部编辑器"><a href="#5-1-External-Editor外部编辑器" class="headerlink" title="5.1 External Editor外部编辑器"></a>5.1 External Editor外部编辑器</h2><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/11.Use%20External%20Editor%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E7%BC%96%E8%BE%91%E5%99%A8.png?raw=true"><br></table><p>勾选“Use External Editor”，则使用外部编辑器。</p><p><strong>1.Type：类型</strong><br>有两种可选类型：<br><strong>Command Line</strong>：命令行<br><strong>DDE(Dynamic Data Exchange)</strong>：Windows动态数据交换</p><p><strong>2.Editor：编辑器</strong><br>指定外部编辑器的文件名和路径。可以通过“浏览按钮”方便操作。</p><p><strong>3.Arguments：参数</strong><br>指定要传递给编辑器的任何参数。这只适用于选择命令行类型。</p><p>类型为DDE时，对应的配置不同，如下图：</p><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/12.DDE.png?raw=true"><br></table><p><strong>4.Service：服务</strong><br>指定由编辑器使用DDE服务名称，指定由编辑器使用DDE服务名称。</p><p><strong>5.Command：命令</strong><br>指定要传递给编辑器的命令字符串序列。</p><h2 id="5-2-Setup-Files设置文件"><a href="#5-2-Setup-Files设置文件" class="headerlink" title="5.2 Setup Files设置文件"></a>5.2 Setup Files设置文件</h2><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/13.Setup%20Files%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6.png?raw=true"><br></table><p><strong>1.Use Custom Keyword File：使用自定义关键字文件</strong><br>自定义关键字文件，如添加uint32_t这种自定义的数据类型，在文本中就会高亮显示。</p><p><strong>提示：</strong><br>文件类型：txt本文文件<br>一行一个关键字</p><p><strong>2.Use Code Templates：使用代码模板</strong><br>使用方法请参考文章《EWSTM8系列教程04_菜单概述（一）》4.1 插入/编辑模板。</p><h2 id="5-3-Colors-and-Fonts颜色和字体"><a href="#5-3-Colors-and-Fonts颜色和字体" class="headerlink" title="5.3 Colors and Fonts颜色和字体"></a>5.3 Colors and Fonts颜色和字体</h2><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/14.Colors%20and%20Fonts%E9%A2%9C%E8%89%B2%E5%92%8C%E5%AD%97%E4%BD%93.png?raw=true"><br></table><p><strong>1.Editor Font编辑字体</strong><br>字体和大小</p><p><strong>2.语法颜色</strong><br>这里包含关键字、字符串、数字…等的<strong>字体颜色和背景颜色</strong>配置。</p><h1 id="六、Messages消息"><a href="#六、Messages消息" class="headerlink" title="六、Messages消息"></a>六、Messages消息</h1><table><br><img align="left" width="500" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/15.Enable%20All%20Dialogs%E4%BD%BF%E8%83%BD%E6%89%80%E6%9C%89%E5%AF%B9%E8%AF%9D%E6%A1%86.png?raw=true"><br></table><p><strong>1.Enable All Dialogs使能所有对话框</strong><br>类似如下图对话框，如果勾选“Don’t show again”，就禁用该对话框。使用此选项可以重新启用所有被禁止的对话框。</p><table><br><img align="left" width="250" src="https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/16.Dialogs%E5%AF%B9%E8%AF%9D%E6%A1%86.png?raw=true"><br></table><h1 id="七、说明"><a href="#七、说明" class="headerlink" title="七、说明"></a>七、说明</h1><p>1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。<br>2.该文档仅供个人学习使用，版权所有，禁止商用。<br>3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 </p><h1 id="八、最后"><a href="#八、最后" class="headerlink" title="八、最后"></a>八、最后</h1><p>我的博客：<a href="http://www.strongerhuang.com">http://www.strongerhuang.com</a><br>我的GitHub：<a href="https://github.com/EmbeddedDevelop" target="_blank" rel="noopener">https://github.com/EmbeddedDevelop</a></p><p>更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h1&gt;&lt;p&gt;　　前面两篇文章针对的是&lt;strong&gt;工程节点各选项&lt;/strong&gt;的配置，而本文讲述的是关于&lt;strong&gt;集成开发环境（IDE）各选项&lt;/strong&gt;的配置。&lt;/p&gt;
&lt;p&gt;　　本文讲述的内容包含字体、快捷键、语言、编辑、消息等许多与&lt;strong&gt;IDE相关的配置&lt;/strong&gt;。因为属于Tools菜单，我也把它称为“工具配置选项”。也就是菜单Tools -&amp;gt; Options下IDE选项，如下图：&lt;br&gt;&lt;img width=&quot;500&quot; src=&quot;https://github.com/strongerHuang/strongerHuang.github.io/blob/master/IAR/EWSTM8/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/1.IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE.png?raw=true&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="EWSTM8系列教程" scheme="http://www.strongerhuang.com/categories/EWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="IAR" scheme="http://www.strongerhuang.com/tags/IAR/"/>
    
      <category term="STM8" scheme="http://www.strongerhuang.com/tags/STM8/"/>
    
      <category term="EWSTM8" scheme="http://www.strongerhuang.com/tags/EWSTM8/"/>
    
      <category term="IAR for STM8" scheme="http://www.strongerhuang.com/tags/IAR-for-STM8/"/>
    
  </entry>
  
</feed>
