<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Keil系列教程]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【Keil系列教程】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看。 二、教程列表1.Keil系列教程01_Keil介绍、下载、安装与注册 正在努力更新中，可关注我微信公众号查看最新消息…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil系列教程01_Keil介绍、下载、安装与注册]]></title>
    <url>%2FKeil%2FKeil%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_Keil%E4%BB%8B%E7%BB%8D%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[一、写在前面 对于学习单片机和嵌入式开发的朋友来说，掌握Keil这款软件可以说是必备的技能。鉴于目前网上没有完整的Keil教程，因此我打算整理一套完整的Keil系列教程。 目前Keil有四种产品（软件）：MDK-ARM、C51、C251、C166。四种软件都是基于µVision，在用法上极为相似。 所以，该系列教程结合目前使用最多的MDK-ARM来讲述，大部分内容也适用于其它三种软件。 二、Keil介绍2.1 概述对于我们程序员来说，大家常说的Keil，其实指的是一款开发工具。同时，Keil也是一家公司名称。 Keil公司是一家业界领先的微控制器（MCU）软件开发工具的独立供应商。Keil公司由两家私人公司联合运营，分别是德国慕尼黑的Keil Elektronik GmbH和美国德克萨斯的Keil Software Inc。 Keil公司2005年由ARM公司收购。其两家公司分别更名为ARM Germany GmbH和ARM Inc。 2.2 MDK-ARMMDK-ARM软件为基于Cortex-M、Cortex-R4、ARM7、ARM9处理器设备提供了一个完整的开发环境。 MDK-ARM专为微控制器应用而设计，而且功能强大，能够满足大多数苛刻的嵌入式应用。 与Keil MDK4及之前版本不同，Keil MDK5分成MDK Core和Software Packs两部分。MDK Core主要包含uVision5 IDE集成开发环境和ARM Compiler5。Software Packs则可以在不更换MDK Core的情况下，单独管理（下载、更新、移除）设备支持包和中间件更新包。 MDK-ARM有四个可用版本，分别是MDK-Lite（免费评估版）、MDK-Essential（基础版）、MDK-Plus（标准版）、MDK-Professional（专业版）。所有版本均提供一个完善的C / C++开发环境，其中MDK-Professional还包含大量的中间库。 MDK产品组件： 关于MDK-ARM的更多详细介绍，及四个版本的差异，请参看我之前在公众号分享的一篇文章《你们都认真了解过MDK-ARM吗？》 2.3 支持芯片Keil MDK-ARM 支持的器件包含 Cortex-M、 Cortex-R、 ARM7、 ARM9、 Cortex-A8系列等多达几千种。 官方支持芯片地址： http://www.keil.com/dd2 三、下载Keil MDK-ARM这个软件建议到官网下载最新版本，我这里也提供百度网盘下载地址（和官网一样）。 上面说了：Keil MDK5分成MDK Core和Software Packs两部分，也就是安装包和支持包。 3.1 MDK-ARM安装包下载目前（2018年10月）Keil MDK-ARM官方最新版本是V5.26，更多老版本及MDK-ARM V4版本，可以在我百度网盘下载【定期更新】。 官方网站：http://www.keil.com/download/product百度网盘：http://pan.baidu.com/s/1eRLbgIY 3.2 MDK-ARM支持包下载MDK-ARM V4 和 V5版本在安装的时候最大的区别在于：V4版本安装包里面集成器件的支持包，而V5版本是独立出来，自己下载安装的。 因此需要下载自己芯片型号对应的器件支持包（我百度网盘提供STM32的器件支持包供大家下载）。 官方网站：http://www.keil.com/dd2/Pack百度网盘：http://pan.baidu.com/s/1o8fd6jS 提示：如果下载链接失效，可关注公众号回复【Keil系列教程】查看更新链接。 四、安装软件4.1 支持的操作系统目前（2018年10月）最新版本MDK-ARM V5.26只支持Windows 7、 Windows 8 和 Windows 10这三个版本操作系统。已经不再支持Windows Vista和 Windows XP系统了。 我记得MDK-ARM V5前面几个版本（好像是V5.19之前版本）还能安装在Windows Vista和 Windows XP这种老系统上，只是部分功能兼容性不好，但也能用。 目前最新版本Keil软件支持的操作系统，可以参看官网说明：http://www2.keil.com/system-requirements 4.2 安装详细步骤Keil四款软件（MDK-ARM、C51、C251、C166）安装方法基本一样，很简单，一路Next下去就行了。 本章节主要针对初学者，下面以图文方式讲述一下安装全过程。 1.以管理员身份运行软件， 进入安装向导界面， 点击“Next” 2.勾选“I agree to…”，许可同意，点击“Next” 3.选择软件和支持包安装路径（可以默认），点击“Next” 4.填写客户信息（可以随便填写），点击“Next” 5.安装过程需要等待几分钟 6.安装完成，点击“Finish” 7.自动更新“支持包”列表，可以直接退出，自己下载安装。 安装软件之后，如果我们不关闭上面自动更新，自动更新完成之后，就会出现“支持包”列表，如下图： 五、安装支持包我把MDK-ARM中用于支持MCU芯片的软件包叫“器件支持包”，所以，我简称“支持包”。 支持包可以通过在线安装，或者下载离线包自己离线安装，这两种安装方式。 5.1 在线安装1.打开MDK-ARM软件，点击“软件支持包”按钮 2.更新列表，选择芯片，安装 在线安装过程就上面几个步骤，点击“Install”之后，需要等待一会儿，下面状态栏有提示，提示安装完成即可直接使用。 5.2 离线安装离线安装支持包就如安装软件一样：下载支持包（上面提供下载），双击下载好的离线包，此时会识别安装路径（前提是已经安装MDK），点击“Next”，一会儿就安装完成。 六、注册Keil MDK是一个收费的软件，官方严厉打击盗版，若你是商业用途，建议购买正版软件。 针对个人学习的朋友，可以使用MDK-Lite免费评估版，只是代码大小有32KB的限制。如果还不能满足你自己需求，建议自行在网上查找注册机或购买正版软件。 同时，ST意法半导体与ARM公司合作，使用MDK-ARM开发STM32F0和L0系列芯片，可以免费获取License。具体请参看：http://www2.keil.com/stmicroelectronics-stm32/mdk 在国内由米尔科技、亿道电子、英倍特提供Keil 的销售和技术支持服务。具体如何购买Keil正版软件，以及它的价格，可以向这些经销商咨询。 七、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【Keil系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>Keil系列教程</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>MDK-ARM</tag>
        <tag>µVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【CANOpen系列教程】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、教程列表1.CANOpen系列教程01_初识CAN与CANOpen及相关内容2.CANOpen系列教程02_理解CAN总线协议3.CANOpen系列教程03_CAN收发器功能、原理及作用4.CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明5.CANOpen系列教程05_CAN总线同步与位填充、优先级的决定6.CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）7.CANOpen系列教程07_CANOpen协议概述8.CANOpen系列教程08_CANOpen通信接口引导学习9.CANOpen系列教程09_CANOpen对象字典10.CANOpen系列教程10_关于Canfestival及对象字典生成工具环境搭建 正在努力更新中，可关注我微信公众号查看最新消息…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程10_关于Canfestival及对象字典生成工具环境搭建]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E5%85%B3%E4%BA%8ECanfestival%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、写在前面 这一篇文章讲述如标题所描述的两大知识点，这两点内容对于初学者来说非常重要，希望想学习CANOpen协议的朋友认真把文章看完。 1.讲述Canfestival框架、官网简述，及衍生出的CANOpen源码基础知识； 2.基于Canfestival框架中对象字典生成工具的环境搭建。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、关于CanfestivalCanfestival是一套免费开源的CANOpen协议栈框架，遵循ANSI-C，支持多平台，我们完全可以借助这一套开源框架来学会CANOpen。 官方主页：https://canfestival.org/index.html.en 从上面主页可以看得出来，网址主要包含三部分内容：Code源码、Documentation文档、Applications应用。 这个网站目前访问有点慢，但还是能访问。可能是因为服务器在法国（IP地址），及这套协议免费开源，没有得到更多资金支持。 下面我将针对初学者，重点讲述一下这三部分内容，以及我们需要重点关注的内容。 2.1 Code源码网址：https://canfestival.org/code.html.en Code代码提供4个资源库（如上图），4个资源库中CANOpen协议源码都沿用一套，简单说协议源码大致相同。 推荐下载第2个的原因：1.有人负责更新维护，目前（2018年）版本最新；2.提供STM32F0、F1、F4系列驱动代码；（下面提供下载） 2.2 Documentation文档网址：https://canfestival.org/doc.html.en 这一项里面主要讲述Canfestival这套框架里面的一些内容，如遵循许可、CanFestival提供了一些GUI和命令行工具，帮助创建一个新的CANOpen节点并编辑对象字典，供主从使用。 我们需要获取的重要内容，都在那个PDF手册里面，建议下载仔细阅读。（这个手册在源码压缩包里面也有：manual_en.pdf） 2.3 Applications应用网址：https://canfestival.org/apps.html.en 这里的“应用”，不是说教你如何编写应用程序，主要是Canfestival应用在哪些地方。如Product产品、Research研究方面。 Beremiz是法国一家公司开发的一款开源的PLC编程工具。在Beremiz里面就集成了CanFestival这套框架（相信折腾过CANOpen的都知道Beremiz）。（这里的“应用”大家可以不用过多深究） 三、CANOpen源码说明及下载3.1 CANOpen源码说明许多初学者都有这么一个疑问：CANOpen协议的源码我们必须要用CanFestival的吗？ 因为CANOpen协议是遵循CiA301、302、CiA401…这些协议，我们的源代码只要符合这些协议规范即可。 CANOpen协议源码也可以自己写，但是耗时耗力完全没必要。所以，我们就使用了免费开源的CanFestival。当然，也可以购买商业化的CANOpen协议源码来开发产品。 不管我们使用免费的CanFestival，还是购买的源码，只要支持CANOpen协议，我们就能与支持CANOpen协议的设备通信。 3.2 下载我们从官网的“Code”进去，会出现4个选项，我推荐下载第2个（上面有说明为什么下载第2个）。进去之后，会看到如下图一些描述： 对于关注我的朋友，大部分都在使用STM32，提供相关的源码参看，想必会有更浓学习的兴趣。 这个源码有多人在更新和维护，所以你会看到有许多分支，我们下载最新版本即可。 下载地址：https://bitbucket.org/Mongo/canfestival-3-asc/downloads 百度网盘下载：https://pan.baidu.com/s/1b9K0vIzu_EVWK1BLURJEPQ 提取码：j2w2 四、对象字典生成工具的环境搭建这里的环境搭建可以参考Canfestival手册（manual_en.pdf）里面的指导，具体位置在3.1.1节：Object Dictionary Editor GUI. 我们需要下载安装第1，2个，第3个就不用单独下载了。 因为我们是在STM32上进行开发，手册中3.1.2节Linux、3.1.3节Windows这些内容我们就不用管了。 4.1 下载Python和wxPython因为和其它工具兼容性的原因，我目前在Win10系统上安装可使用的是python-2.7.15 + wxPython2.8。 其它高版本的Python 3我之前试过好像不行，还有32位和64的也有差异。这里提供给大家（我安装的版本）下载，大家有时间可以在官网下载其它版本试试。 1.百度网盘链接：https://pan.baidu.com/s/1bRS403m4B31m4ovSJ-_HwA提取码：38sn 2.官方下载Python：https://www.python.org/downloadswxPython：https://wxpython.org/pages/downloadswxPython镜像：https://sourceforge.net/projects/wxpython/files/wxPython 4.2 安装1.Python安装Python的安装需要注意两点：1.以管理员身份运行； 2.添加（环境变量）路径。 具体可以参看我公众号之前推送文章《工具下载、环境搭建》中3.2 安装Python. 2.wxPython安装可以通过下载离线包直接安装，也可以通过命令行直接安装。（请看上面给的地址） 4.3 如何成功运行1.解压（上面3.2 下载的）Canfestival-3；2.在解压objdictgen目录下的Gnosis_Utils-current.tar.gz3.将第2步解压目录下的gnosis拷贝到objdictgen目录下（注意路径），如下图： 4.双击，或者以命令方式运行objdictgen下的objdictedit.py，如果环境没问题，此时就会出现如下界面： 如果不能出现上面界面，请检查环境是否搭建成功。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程09_CANOpen对象字典]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_CANOpen%E5%AF%B9%E8%B1%A1%E5%AD%97%E5%85%B8.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章主要是引导大家学习CANOpen协议通信接口的相关内容。通信接口的内容有点多，对于初学者来说，如果看不懂，请多看几遍（最好有个印象）。 CANopen设备最重要的一个部分就是对象字典。对象字典本质上是一种被预先安排的对象序列，可通过网络访问。字典里面的每一对象均可使用一个16-bit主索引和8-bit子索引寻址到。 初学者学习如果难理解通信接口（上一篇）有些内容，如：PDO、SDO及网络管理对象，可以结合对象字典索引来学习和记忆。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、对象字典重要内容对象字典OD：Object dictionary。 一组带有 16 位索引和 8 位子索引的数据或对象。对象字典下面主要包含：数据类型、通信对象、应用对象。 对象字典主索引： 2.1 通信子协议区通信子协议区，如上图1000h 到 1FFFh这个区域。也就是通信接口（或通信对象）协议区。 对于初学者来说，通信对象子协议区是比较重要的一个区域，牵涉到上一篇文章《通信接口》讲述的大部分内容。同时，这之间的关系也非常紧密。 通讯对象子协议区： 如上图，通讯对象子协议区又划分为几个区域，而其中的1000h 到 1029h为通用通讯对象。 通用通讯对象里面的内容已经被约定好，如果我们需要用到，可直接配置使用即可。 通用通讯对象内容： 通信子协议区的内容非常重要，也比较多，需要拆分并一个一个掌握。可结合周立功提供相关教程，以及前面提到的CiA 301手册理解。 我这里就不一一列出来了，简单再列一个通信子协议区中PDO通信参数（对象）与映射参数： 写到这里，想必很多朋友都能理解，也能明白这些内容。更多的内容，可以结合这种拆分的思路去理解。 三、对象字典生成工具上面介绍了对象字典的一些内容，可能还是有很多初学者不明白。同时，也就可能会产生疑问：这个对象字典我们需要字典和我们代码有什么关系呢？ 可以简单来说，就是一些16位索引和8位子索引对应的变量数据，来下看下代码（下面两图），加深理解： 3.1 对象字典的代码需要自己写吗？很多初学者，包括我（之前初学时）也会产生疑问：对象字典的代码需要我们自己写吗？ 答案：不用自己写。 当然，对象字典的代码可以自己写，但完全没必要。1.自己写不一定正确；2.有现成工具可以节约大量时间。 3.2 Canfestival对象字典生成工具我微信公众号分享《CANOpen系列教程》的封面中有一行英文：Canfestival.相信学过CANOpen的朋友都应该知道我接下来会结合这套Canfestival免费开源的CANOpen架构来讲述。 其中，Canfestival里面包含我们需要的CANOpen协议源码和对象字典生成工具。 有了对象字典生成工具，对象字典的代码就可以通过它来自动生成。搭建Canfestival对象字典生成工具的环境是一个重点。 对于很多初学者来说搭建环境也是一个难点，不少初学者就卡在这一关，然后，学习CANOpen就没有继续下去了。 简单的说，搭建对象字典生成工具的环境步骤不多，可能会因为诸多因素导致搭建失败。搭建成功，运行之后会出现如下图界面： 在学习对象字典生成工具时，会看见一个词：EDS，即Electronic Data Sheet电子数据单。 像周立功的CANOpen从站模块就配有工具生成EDS文件。当然，Canfestival提供的工具也能导出EDS文件。 Canfestival对象字典生成工具搭建过程，及相关内容我将在下一篇文章详细讲述。 四、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程08_CANOpen通信接口引导学习]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_CANOpen%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E5%BC%95%E5%AF%BC%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[一、写在前面 上一章上一篇文章让大家了解了一下CANOpen协议的模型，也就是说CANOpen协议的内容都包含在这个模型里面，而模型里面的内容可以细分出来许许多多的知识。 但是对于初学者来说，并不是必须要掌握的所有的细节知识才行。只需要掌握其中必备的一些基础知识，就可以编写CANOpen的应用程序代码了。 那么本文将带你掌握其中部分基础知识，让你大脑中有CANOpen协议的这些概念知识（先有初步认识，以便于后面综合理解）。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、通信接口主要内容我这里按照CANOpen CiA 301协议文档，提取了通信接口的主要内容，我把它用思维导图方式列出来了，如下图： 初学者需要掌握通信接口后面的四项内容：网络管理(NMT)、服务数据对象 (SDO)、过程数据对象(PDO)、特殊协议； 这四项内容细分出来的知识点不多（相对来说），但对初学者来说，理解起来的难度较大。难点就在于：有许多抽象概念，且知识点关联性较强。 比如：什么是报文？ CAN-ID、COB-ID、Node-ID是什么思，各有什么区别？ COB-ID和对象字典索引有关联吗？ 三、CANopen轻松入门相信学习CANOpen的朋友都在网上看到过周立功的这么一本电子书：《CANopen 轻松入门》。 本来我是打算再造一次轮子，重新结合CANOpen CiA 301标准写一遍。但我之前有做计划，发现太费时了，而且做出来的效果也没有《CANopen轻松入门》这么好。我思前想后，还是觉得没有必要。 所以，本文主要目的在于引导初学者，网上下载《CANopen轻松入门》这本电子书来好好研究一下。关于通信接口主要内容，目录如下图： 《CANopen轻松入门》这本电子书是我站在初学者的角度考虑，觉得比较适合初学者，并不是为周立功打广告。当你把这本电子书里面内容都掌握了，我觉得你就已经入门了。 《CANopen轻松入门》网盘下载地址（百度、谷歌随处可见）：https://pan.baidu.com/s/15Or8ox3LgXKR6Z7ul7Zt1g 提取码：9ja0 四、CiA 301入门之后若要深入理解，我建议参看官网的《CANOpen CiA 301》标准这本文档。为什么是CiA 301标准呢？ 因为这些入门知识大部分都是CiA 301标准里面的内容。 CiA 301标准有多个版本，建议下载已经公开的V4.2.0版本： CiA技术文档下载地址（需要登录）：https://www.can-cia.org/standardization/specifications CiA 301网盘下载地址（含中、英文版本）：https://pan.baidu.com/s/1efnJAmB7tkSsMwIf39p8sg 提取码：x1m0 提示：CiA（CAN in Automation） 301也是大家所说的DS301，为CANopen 基础协议。 我们还常看到类似CiA 401 402这些协议，其实它们是在CiA 301 之上，对各个行业不断推出设备子协议。 所谓的子协议，就是针对不同行业的应用对象，对 CANopen 内部的数据含义进行重新定义，或者添加新的控制逻辑。 五、提取通信接口要点这里针对通信接口简单罗列一些基础知识，方便初学者理解。 5.1 网络管理(NMT)1.CANOpen网络一般是一个主站，多个从站的局域网络； 2.NMT节点具有6种状态：初始化、应用层复位、通讯复位、预操作状态、操作状态、停止状态。可以自己切换状态，也可主站切换状态； 3.任何一个 CANopen 从站上线后发出节点上线报文（boot-up）; 5.2 过程数据对象 PDO1.PDO用来传输实时数据，属于“生产消费”模型； 2.COB-ID 定义只是预定义，TPDO5、6、7这些也是可以存在。PDO 的COB-ID 与 Node-ID 无必然规则上的联系， 3.PDO 的两种传输方式：同步传输和异步传输； 4.PDO 的通信参数可通过对象字典工具配置； 5.PDO 的映射参数是一个相对难理解的参数，请结合《CANopen 轻松入门》图文（请关注颜色）理解； 5.3 服务数据对象 SDO1.SDO为请求应答方式； 2.发送方（客户端）、接收方（服务器） ； 3.通常从节点为 SDO 服务器，主节点为客户端； 4.两种协议：快速、普通 SDO 协议； 5.CS命令符含义需熟记（查表）； 5.4 特殊协议1.常见的就是罗列出来的3种：同步协议、时间戳协议、紧急报文协议； 2.特殊协议CAN-ID定义（查表）； 3.紧急报文错误代码分类及含义； 以上许多内容都有一张对应的表格，可以搜索一下“CANopen备忘录”，就有详细列出各自对应的内容。 六、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程07_CANOpen协议概述]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_CANOpen%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面 上一章节提供的例程是标准、数据帧格式的传输例程，结合前面理论知识，相信你根据参考例程可以实现远程帧及其他类型的数据传输。 前面教程讲述内容为CAN总线协议，属于底层硬件相关的一些内容。从本文开始，将正式讲述CANOpen协议。 CANOpen协议是基于CAN总线的上一层软件协议。该教程前面内容是建立底层通信，只有在底层通信成功基础上，才能实现上一层的通信协议。 提示：CANOpen协议内容很多，有许多内容都是一些抽象的概念。所以，有一些内容相对较难理解，随着慢慢深入即可消除那些疑虑。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CANopen协议总述CANopen 是一个基于 CAN 串行总线的网络传输系统的应用层协议，遵循 ISO/OSI 标准模型。 网络中不同的设备通过对象字典或者对象来相互交换数据，其中，主节点可以通过过程数据对象 (PDO) 或者服务数据对象 (SDO) 来获取或者修改其它节点对象字典列表中的数据。 CANOpen协议主要内容分为三大块，如下图CANopen 的设备模型。 CANOpen协议从大方向的划分，就如上图所示三大块。但是，这三大块里面的内容就牵涉到许多…… 初学者可以以上图模型为中心，再结合实际例程理解CANOpen协议的各种抽象概念。 下面章节将进一步讲述模型中三大块内容的一些概念，初学者能理解尽量理解，不能理解可以先做了解即可。 三、通信对象CANopen协议中常用的通信对象包含如下几点： 1） 网络管理对象(NMT)网络管理对象包括 Boot-up 消息， Heartbeat 协议及 NMT 消息，基于主从通信模式， NMT 用于管理和监控网络中的各个节点，主要实现三种功能：节点状态控制、错误控制和节点启动。 2） 服务数据对象 (SDO)·包括接收 SDO(R-SDO) 和发送 SDO(T-SDO)。·通过使用索引和子索引， SDO 使客户机能够访问设备对象字典中的项。·SDO 通过 CAL 中多元域的 CMS 对象来实现，允许传送任何长度的数据，当数据超过 4 个字节时分拆成几个报文。·协议是确认服务类型，为每个消息生成一个应答。 SDO 请求和应答报文总是包含 8 个字节。 3） 过程数据对象(PDO)·包括接收 PDO(RPDO) 和发送 PDO(TPDO)。·用来传输实时数据，数据从一个创建者传到一个或多个接收者。数据传送限制在 1 到 8 个字节。·每个 CANopen 设备包含 8 个缺省的 PDO 通道， 4 个发送 PDO 通道和 4 个接收 PDO 通道。·PDO 包含同步和异步两种传输方式，由该 PDO 对应的通信参数决定。·PDO 消息的内容是预定义的，由该 PDO 对应的映射参数决定。 4） 同步对象 (SYNC)同步对象是由 CANopen 主站周期性地广播到 CAN 总线的报文，用来实现基本的网络时钟信号，每个设备可以根据自己的配置，决定是否使用该事件来跟其它网络设备进行同步通信。 5） 紧急报文 (EMCY)设备内部通信故障或者应用故障错误时发送的报文。 四、对象字典对象字典是设备规范中最重要的部分。它是一组参数和变量的有序集合，包含了设备描述及设备网络状态的所有参数。 通过网络可以采用有序的预定义的方式来访问的一组对象。这里就牵涉到定义对象字典的生成问题，后面我会讲述关于对象字典生成工具相关内容。 CANopen 协议采用了带有 16 位索引和 8 位子索引的对象字典。你可以理解为一本汉语字典，我们需要查找里面的某个汉子（可以理解定义的某个数据），我们就会从拼音或笔画（索引）进去找到对应位置。 CANOpen 协议对象字典主索引如下图，这只是一个主要的索引。其实还能细分下去，这里不过多讲述，后续会进一步讲述。 五、应用应用这一块的内容包含应用程序、设备子协议实现。可以从CANopen 的设备模型明白，对外就是IO接口，也就是供我们调用的接口。 应用这一块包含CANOpen协议上层的内容，可以简单理解封装的一些供用户读写操作的函数。 应用这一块内容在后面结合实例分析会牵涉，初学者可以简单了解有这么一块，且知道这一块在CANOpen协议中大致的作用即可。 六、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程06_结合代码理解CAN底层收发数据（含STM32例程）]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E7%BB%93%E5%90%88%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3CAN%E5%BA%95%E5%B1%82%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%88%E5%90%ABSTM32%E4%BE%8B%E7%A8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 该教程前面讲述了许多关于CAN协议的一些概念，可能许多初学者看的云里雾里，那么本文将结合代码让大家理解之前讲述的内容。 因为关注我的人大部分都在学习STM32，我将结合STM32F103、标准外设库例程来让大家理解之前讲述的一些概念。 本文主要讲述内容： ·1.传输数据相关参数 ·2.位时序及传输波特率 为方便大家理解，我将在最后提供对应例程「CANOpen系列教程06_CAN底层收发例程」。当然，本文只讲述代码中部分内容，某些配置参数放在后面讲述。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、传输数据相关参数传输数据相关参数其实主要就是前面《CANOpen系列教程04》讲述的“帧类型及格式说明”那一章节内容，建议先看下那些概念内容。 CAN总线传输的内容主要就是发送和接收，下面我将结合代码中发送和接收参数来让大家理解我们编程控制CAN总线上那些参数。 2.1 CAN总线数据帧本文提供例程主要是CAN总线使用最多的数据帧为例，让大家理解数据帧传输由我们编程控制的参数。 先看下图回顾一下数据帧格式，其中有些字段内容由控制器自动完成，如：帧起始，CRC校验。而有些就是由我们编程控制，如：ID、数据等。 2.2 CAN发送代码A.CAN发送数据结构下图主要就是CAN发送由我们编程控制的参数。其实你会发现，主要就是上面帧格式中部分内容：ID、IDE、RTR、DLC、Data。 B.发送配置参数下图为实际发送配置的参数。 2.3 CAN接收代码CAN接收其实和发送类似，CAN总线上的字段就那些，在接收端接收的那些参数无非就是发送端发送出来的那些参数。针对STM32内部集成的CAN，接收数据结构多了一个FMI参数，大概意思就是接收消息邮箱筛选器索引。 接收操作为方便初学者理解，这里这要就是使用中断接收CAN总线数据，在中断函数里面打印也主要是用于测试，一般实际项目打印不会出现在中断函数（打印相对耗时）。 三、位时序及传输波特率同样，在前面《CANOpen系列教程04》中有讲述“位时序及传输波特率”的概念。其实，位时序间接决定了传输的波特率。换句话说，传输的波特率由位时序几个参数决定。 看下图，回顾一下波特率计算公式： 3.1 波特率配置代码结合上图计算公式和下图代码，可以看出位时序中几个参数和波特率的关系。波特率为1M时，几个位时序参数可以配置为如下图值： 提示：36M代表CAN时钟，具体要看时钟相关配置。 波特率固定，位时序参数可以不同。比如波特率固定为1M，位时序参数可以为上图配置；也可以修改其中的值，如修改位段1为CAN_BS1_5tq，位段2为CAN_BS2_3tq。只要遵循波特率计算公式即可。 四、例程下载CANOpen系列教程06_CAN底层收发例程：https://pan.baidu.com/s/1LzD0Epc-Z8vlHsb-sD3WVw提取码：l2dc 提示： 链接后期可能会失效，可关注公众号回复【CANOpen系列教程】查看更新链接。 五、说明1.该文档部分内容来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程05_CAN总线同步与位填充、优先级的决定]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_CAN%E6%80%BB%E7%BA%BF%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BD%8D%E5%A1%AB%E5%85%85%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%B3%E5%AE%9A.html</url>
    <content type="text"><![CDATA[一、写在前面 继续为大家更新CAN总线协议相关内容，这些内容其实也比较重要，会直接影响到你后期CAN总线的编程，夸张一点的说会影响到你的软件架构。 本文内容相对来说比较容易理解，初学者有必要了解一下。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、位填充位填充是为防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据。 这个功能很好理解，如下图所示。位填充的数据不需要编程控制，由控制器自动完成。其目的也是提高CAN总线的稳定性。 (1) 发送单元的工作在发送数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，在下一个位（第 6 个位）则要插入 1 位与前 5 位反型的电平。 (2) 接收单元的工作在接收数据帧和遥控帧时， SOF～CRC 段间的数据，相同电平如果持续 5 位，需要删除下一个位（第 6 个位）再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送错误帧。 三、优先级的决定前面讲述“CAN 总线差分信号”时描述了显性和隐性，其实这是CAN总线的特点，也是决定CAN总线优先级比较重要的功能。 在CAN总线空闲态，最先开始发送消息的单元获得发送权。 多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。 上图描述了CAN控制仲裁的过程，单元2最终获得了抢占CAN总线的权利，也就是说单元2具有更高的优先级。 当单元1 仲裁失利时，自动转换为接收（本来该发送，优先级比别人低，就开始接收数据了。 同时，控制器将会在下一轮继续发送这次未完成的数据）。 3.1 数据帧和遥控帧的优先级具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。 数据帧和遥控帧的仲裁过程如下图： 3.2 标准格式和扩展格式的优先级标准格式 ID 与具有相同 ID 的遥控帧或者扩展格式的数据帧在总线上竞争时，标准格式的 RTR 位为显性位的具有优先权，可继续发送。 提示：不明白数据帧和遥控帧，标准格式和扩展格式之间差异的朋友，建议参看我上一篇文章《CANOpen系列教程04》。 四、其他CAN总线协议的重要内容在这前面基本是讲述的差不多了，还有一些不是很重要的内容，比如硬件设计需要在CAN_H和CAN_L之间添加一个120欧电阻，总线的传输距离等。 接下来的文章会结合STM32芯片集成CAN控制器、例程讲述如何编程控制CAN总线数据的收发等。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程04_CAN总线波特率、位时序、帧类型及格式说明]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_CAN%E6%80%BB%E7%BA%BF%E6%B3%A2%E7%89%B9%E7%8E%87%E3%80%81%E4%BD%8D%E6%97%B6%E5%BA%8F%E3%80%81%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章讲述了CAN收发器的重要作用，也提及了一下CAN总线的优势主要在于CAN控制器。CAN控制器在CAN网络中所处的位置如下图： 本文讲述的CAN控制器实现的几个重要功能：CAN总线波特率、位时序、帧类型。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CAN总线波特率CAN总线属于异步通信，因此就有通信波特率，而这个波特率发生器就位于CAN控制器内部。我们不需要了解它是如何产生的，但需要了解它的含义。这章节针对初学者讲述以下两点内容。 2.1 异步通信在串行通信中，主要分异步通信和同步通信。 同步通信：通信设备之间通过同步信号（CLK时钟）来实现数据传输的通信叫同步通信。如I2C、SPI这类通信中都具有一个时钟信号，其实在STM32中USART也具有同步功能，只是我们大多数人都只用了它的异步功能。 异步通信：简单来说，就是通信设备之间通过约定一样的时间来收发数据。而这个时间就会决定本节说的波特率。 2.2 波特率很多工程师一直都没彻底搞明白什么是波特率，我这里还是结合UART波特率来简述一下其含义。 在电子通信领域，波特（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号。 UART每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。 从上面的描述可以总结：比特率：即单位时间内传送的二进制位数； 波特率：即单位时间内传输的符号个数； 只有在每个符号只代表一个比特信息的情况下，波特率与比特率才在数值上相等，但是它们的意义并不相同。 三、位时序上一章节讲述了波特率，而决定波特率大小的就是本节说的位时序。在CAN标准中一个位可分为4段：·同步段（SS）·传播时间段（PTS）·相位缓冲段1（PBS1）·相位缓冲段2（PBS2） 这些段又由可称为 Time Quantum（简称Tq）的最小时间单位构成。 1位分为4个段，每个段又由若干个Tq构成，这称为位时序。 而在STM32参考手册中，将位时序分为三段，但它将它传播段和位段1合并在一起了，如下图： 1位由多少个Tq构成、每个段又由多少个Tq构成等，可任意设定位时序。通过设定位时序，决定传输的波特率： 这几个参数会在以后编程中进行配置，从而决定通信的波特率。 关于同步，还有硬件同步、再同步等操作。但初学者可以不必过多理解，掌握上面基础内容就行了。更多关于位时序的内容可以参看 ISO 11898 标准。 四、帧类型及格式说明CAN总线是通过以下5种类型的帧进行通信：数据帧：用于发送单元向接收单元传送数据的帧。遥控帧：用于接收单元向具有相同 ID 的发送单元请求数据的帧。错误帧：用于当检测出错误时向其它单元通知错误的帧。过载帧：用于接收单元通知其尚未做好接收准备的帧。帧间隔：用于将数据帧及遥控帧与前面的帧分离开来的帧。 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。 4.1 数据帧 如上图，数据帧由7个段构成：(1) 帧起始表示数据帧开始的段。(2) 仲裁段表示该帧优先级的段。(3) 控制段表示数据的字节数及保留位的段。(4) 数据段数据的内容，可发送 0～8 个字节的数据。(5) CRC 段检查帧的传输错误的段。(6) ACK 段表示确认正常接收的段。(7) 帧结束表示数据帧结束的段。 理解数据帧的含义，请从认真理解它的定义：用于发送单元向接收单元传送数据的帧。 一般的CAN总线通信，总线上通信绝大部分时候都是数据帧。像在CANOpen协议中，用的最多的PDO过程数据对象就是通过数据帧进行的通信。 初学者可以先理解数据帧，然后其他就容易理解了。下面再来讲述一下数据帧7段的详情。 4.1.1 帧起始标准和扩展格式相同。表示帧开始的段，1个位的显性位（如下图）： 关于显性和隐性电平，请参看我上一篇文章差分信号章节。 总线上的电平有显性电平和隐性电平两种。总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。 “显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平。并且，“隐性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强） 4.1.2 仲裁段标准格式和扩展格式在此的构成有所不同。仲裁段表示该帧优先级的段，扩展格式多了18位ID（如下图）： RTR = 0代表数据帧，RTR = 1代表远程帧。 为什么叫仲裁段，就是通过ID来判断总线上哪一个节点具有优先发送的权利。ID越小（0代表显性），优先级越高。 4.1.3 控制段标准和扩展格式的构成有所不同。控制段由 6 个位构成（如下图）： 它们除了都有4位表示数据段长度代码（DLC）外，标准帧有IDE（数值为0）位和r0保留位，扩展帧有r0和r1保留位。 保留位必须全部以显性电平发送。但接收方可以接收显性、隐性及其任意组合的电平。 4.1.4 数据段标准和扩展格式相同。数据段表示传输数据的内容，从 MSB（最高位）开始输出，可发送 0～8 个字节的数据，长度由前面控制段决定。 4.1.5 CRC段标准和扩展格式相同。CRC段是检查帧传输错误的帧，由 15 个位的 CRC 顺序和 1 个位的 CRC 界定符（用于分隔的位）构成。 相比485这类通信，CAN控制器就已经把CRC校验做了，不需要你的程序再次去计算，从而节约了处理器资源。 4.1.6 ACK段标准和扩展格式相同。ACK段用来确认是否正常接收。由 ACK 槽(ACK Slot)和 ACK 界定符 2 个位构成。 A.发送单元在 ACK 段发送 2 个位的隐性位。B.接收到正确消息的单元在 ACK 槽(ACK Slot)发送显性位， 通知发送单元正常接收结束。这称作“发送 ACK”或者“返回 ACK”。 4.1.7 帧结束标准和扩展格式相同。帧结束是表示该该帧的结束的段。由 7 个位的隐性位构成。 4.2 遥控帧 和数据帧相比，遥控帧是接收单元向发送单元请求发送数据所用的帧。所以，遥控帧没有数据段。因此，遥控帧由如下 6 个段组成：(1) 帧起始（SOF）表示帧开始的段。(2) 仲裁段表示该帧优先级的段。可请求具有相同 ID 的数据帧。(3) 控制段表示数据的字节数及保留位的段。(4) CRC 段检查帧的传输错误的段。(5) ACK 段表示确认正常接收的段。(6) 帧结束表示遥控帧结束的段。 这6个段和上面数据帧的内容基本一样，这里就不一一讲述了。讲一下遥控帧和数据帧的区别：遥控帧的 RTR 位为隐性位，没有数据段。没有数据段的数据帧和遥控帧可通过 RTR 位区别开来。 问题一：遥控帧没有数据段，数据长度码该如何表示？遥控帧的数据长度码以所请求数据帧的数据长度码表示。 问题二：没有数据段的数据帧有何用途？例如，可用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。 4.3 错误帧 用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。 (1) 错误标志错误标志包括主动错误标志和被动错误标志两种。主动错误标志： 6 个位的显性位。被动错误标志： 6 个位的隐性位。 (2) 错误界定符错误界定符由 8 个位的隐性位构成。 4.4 过载帧 过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。(1) 过载标志6 个位的显性位。过载标志的构成与主动错误标志的构成相同。 (2) 过载界定符8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。 4.5 帧间隔 帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。 过载帧和错误帧前不能插入帧间隔。 (1) 间隔3 个位的隐性位。 (2) 总线空闲隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。 (3) 延迟传送（发送暂时停止）8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程03_CAN收发器功能、原理及作用]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_CAN%E6%94%B6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8.html</url>
    <content type="text"><![CDATA[一、写在前面 前面文章是从大方向介绍了CAN网络，让大家对CAN网络有一定的认识。本文将范围缩小，讲述整个CAN网络其中的一个CAN收发器。如下图标记出来的部分： 本文结合众多初学者容易产生的疑问来讲述CAN收发器相关的知识点，大概有如下几点： ·什么是CAN收发器？ ·CAN总线差分信号 ·CAN收发器芯片和485芯片差异 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、什么是CAN收发器？CAN收发器在整个CAN网络中所处的位置如上图所示。CAN收发器就是一块类似232或485的转换芯片，它的主要功能是将CAN控制器的TTL信号转换成CAN总线的差分信号。 2.1 什么CAN控制器TTL信号？现在的CAN控制器一般都与MCU集成在一起，其发送和接收TTL信号就是MCU引脚（高或低）信号。 以前还有独立的CAN控制器，一个CAN网络节点会包含三块芯片：MCU芯片、CAN控制器、CAN收发器。现在是将前两者集成在一起了（看文章开篇图片）。 三、CAN总线差分信号CAN总线信号从CAN收发器出来，为「两线」「差分」信号，用隐形代表逻辑1，显性代表逻辑0。 1.CAN收发器两线芯片引脚CAN_H、CAN_L 2.CAN_H和CAN_L电压电压的大小根据芯片型号而定，一般常见的CAN收发芯片有3.3V和5V两种芯片。 如上图，为5V CAN收发芯片，在逻辑0和逻辑1时电压情况：逻辑0时：显性，CAN_H=3.5V，CAN_L=1.5V；逻辑1时：隐性，CAN_H=2.5V，CAN_L=2.5V； 当然，3.3V电压芯片的总线电压原理类似。而实际应用中，总线电压并非绝对的像上面说的3.5V、2.5V、1.5V这种电压，会受到导线电阻、外界干扰等影响。 3.隐性和显性学过生物都知道，基因有隐性和显性，隐性的基因实际存在，但不会表现出来。有显性的基因就会变现出来。这里CAN总线隐性信号和显性信号道理一样，当总线两者信号都有时，总线表现出来的就是显性信号。 提示：我们这里说的显性和隐性信号，指的是总线传输的bit位信号。 所以，CAN总线平时空闲表现为隐性状态。如果想要发送的信号为隐性位，那么总线才会呈现出来隐性。否则，只要其它有一个节点发送显性信号，你这个节点发送出来的隐性信号就无效。 4.CAN收发器R引脚CAN收发器R引脚就是与CAN控制器接收相连的引脚。如下图： R引脚的信号是表示总线当前的信号，用于控制器实时监测总线信号。主要两个目的：A.监测其它节点发送出来的信号：别人给它发送数据；B.监测自身节点发送出去的信号：自己发送是否失败。就像上面说的，自己发送一个隐形信号，结果监测出来是显性信号，那就说明是别人在发送数据。 四、CAN收发器芯片和485芯片差异CAN通信和485通信一样，属于半双工。但是，为什么CAN总线相比485通信不管在速度和稳定性上都具有明显优势呢？ 4.1 总线利用率CAN收发器工作原理与485具有较大差异。从上面的差分信号可以看得出来，两种芯片同时存在，只有显性信号有效，而不会影响总线传输。简单来说就是CAN总线具有自动仲裁功能，这样就提高了总线的利用率。 RS485总线是一种常规的通信总线，它不能够做总线的自动仲裁，也就是不能够同时发送数据以避免总线竞争，所以整个系统的通信效率必然较低，数据冗余量较大，对于速度要求高的应用场所不适应用RS485总线。 提示：CAN总线没有被发送出去的隐性信号，会由CAN控制器后续发送出去。这里牵涉到CAN总线优先级的问题，后续进一步讲述。当然，CAN相比485具有明显优势，主要原因还是在于CAN控制器。 4.2 可以不使用CAN收发器吗？UART可以直接通过TX连接对方的RX引脚，利用TTL信号进行通信，那么CAN也可以吗？ 答案：单向传输可以，双向传输就不行。原因很简单，上面说了，CAN控制器会实时监测发送出去的信号是否正确。也就是说TX要与RX信号一致才行，否则CAN控制器认为你发送失败。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程02_理解CAN总线协议]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E7%90%86%E8%A7%A3CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章讲述了CAN和CANOpen，相信大家CAN和CANOpen有一定理解了。本文说的CAN即是一种总线，也是一种协议。因此，我们常听见CAN总线，也常听见CAN协议。 CAN协议和CANOpen协议是两套不同的协议。从软硬件层次来划分，CAN协议属于硬件协议，而CANOpen属于软件协议。 本篇文章先概述一下CAN网络，让大家对CAN总线协议有一个全局的概念，再到底层的CAN总线协议知识。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、CAN网络CAN网络可以理解为多台CAN设备连接在同一条CAN总线上组合成的网络，其中的CAN设备我们称之为节点。CAN网络拓扑结构如下图： 如上图，一个CAN节点主要包含三类：MCU应用程序、CAN控制器、CAN收发器。 2.1 MCU应用程序MCU应用程序我将其分为三块：业务逻辑代码、协议层代码、底层驱动代码。 A.业务逻辑代码：是根据项目需求而定，也很好理解。比如我读取一个传感器数据，并对其做出相应逻辑处理。 B.协议层代码：比如后续要讲述的CANOpen。 C.底层驱动代码：配置CAN总线相应参数、控制收发的代码。 2.2 CAN控制器CAN控制器内部结构还是挺复杂的，一般现在CAN控制器都是与处理器集成在一起。 其实对于编程的人来说，无非也就是包含一些控制、状态、配置等寄存器。 比如我们看到有些STM32芯片带有CAN，也就是说CAN控制器已经集成在STM32芯片中了，我们只需要编程操作其中的寄存器即可。 2.3 CAN收发器CAN收发器：将CAN收发引脚（CAN_TX和CAN_RX）的TTL信号转换成CAN总线的电平信号。 PS：你可以把CAN总线通信认为是UART通过485进行通信：CAN控制器就如UART的控制器，而CAN收发器就如485转换芯片。 三、ISO标准化的CAN协议写这一章节的主要目的就是想让大家了解CAN总线位于OSI所在层次。 3.1 ISO/OSI基本参照模型 【注】ISO：International Standardization Organization国际标准化组织；OSI：Open Systems Interconnection开放式系统间互联； 3.2 CAN在OSI模型中的定义 【注】LLC：Logical Link Control逻辑链路控制；MAC：Medium Access Control媒介访问控制； 从上图可以知道CAN总线底层硬件的内容（CAN控制器、收发器）主要位于OSI的第1层和第2层。 四、概述CAN总线协议CAN总线协议：就是为了保证通信（收发）数据在CAN总线上能稳定传输而制订的一套协议。 CAN总线协议的内容很多，为方便初学者理解，本文先大概描述一下CAN总线协议，后续文章详细讲述CAN总线协议的内容。 4.1 总线信号CAN总线为「两线」「差分」信号，用隐形代表逻辑1，显性代表逻辑0。如下图： 4.2 优先级假如某一时刻，一个设备（节点）往总线发0，一个设备往总线发1。那么总线会呈现什么现象？ 答案：最后总线呈现为显性，也就是0。 4.3 位时序位时序逻辑将监视串行总线，执行采样并调整采样点，在调整采样点时，需要在起始位边沿进行同步并后续的边沿进行再同步。 简单的说就是对一个bit位分几段进行采样，目的就是提高数据传输稳定性。在STM32中底层驱动代码就需要进行位时序编程，在STM32参考手册中也会发现如下位时序图： 4.4 帧的种类和格式帧的种类有多种：数据帧：用于发送单元向接收单元传送数据的帧。遥控帧：用于接收单元向具有相同 ID 的发送单元请求数据的帧。错误帧：用于当检测出错误时向其它单元通知错误的帧。过载帧：用于接收单元通知其尚未做好接收准备的帧。帧间隔：用于将数据帧及遥控帧与前面的帧分离开来的帧。 数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有11个位的标识符ID，扩展格式有29个位的ID。 4.5 位填充位填充是为防止突发错误而设定的功能。当同样的电平持续 5 位时则添加一个位的反型数据。如下图： 4.6 错误的种类 CAN总线协议内容很多，初学者先了解这些，后面文章具体到每一个点上，相信大家就会更明白其中的含义。 五、说明1.该文档部分文字来自网络，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANOpen系列教程01_初识CAN与CANOpen及相关内容]]></title>
    <url>%2FCANOpen%2FCANOpen%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_%E5%88%9D%E8%AF%86CAN%E4%B8%8ECANOpen%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[一、写在前面 我之前学习CANOpen的时候，网上有用的资料极少，走了不少弯路。到目前为止，网上关于CANOpen的资料依然很少。所以，特地写下该系列教程，帮助初学者跨过这道坎。 从我个人学习CANOpen的经历来看，学会使用CANOpen难度其实不大。难点在于需要掌握的基础知识很多，而且许多都有关联性，容易把人绕晕。 那么，我希望通过结合之前我的学习经历，以及工作经验，站在小白的角度写下该系列教程。当然，该教程由我个人编辑并整理，难免有些废话，或者错误，还请谅解。 本文章收录于【CANOpen系列教程】，在我的博客分类“CANOpen系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看。 二、初识CAN与CANOpen2.1 什么是CAN?CAN：是Controller Area Network的缩写，即控制器局域网络，属于工业现场总线，是ISO国际标准化的串行通信协议。 从OSI（Open System Interconnection开放系统互联）7层网络模型的角度来看，CAN现场总线仅仅定义了第 1 层（物理层）和第 2 层（数据链路层）。 而在实际设计中，这两层完全由硬件实现，设计人员无需再为此开发相关软件或固件（Firmware），只要了解如何调用相关的接口和寄存器，即可完成对CAN的控制。 上面介绍的内容可能太官方，初学者可能看了之后还是不明白。简单的说：CAN总线就是一层硬件协议。比如：差分信号电平的定义、数据帧的定义等等。 PS：初学者可以结合UART来理解，比如UART串口发送一个字符’A’，它就是一种串行通信的方式。 2.2 什么是CANOpen?CANopen是一种架构在CAN控制局域网上的高层软件通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线协议。 CANopen协议是在20世纪90年代末，由总部位于德国纽伦堡的 CiA 组织——CAN-in-Automation，在 CAL（CAN Application Layer）的基础上发展而来。 所以，关于CANOpen协议内容请参看：http://www.can-cia.org 由于CAN总线只定义了OSI中的物理层和数据链路层，因此对于不同的应用出现了不同的【应用层协议】，为了使不同厂商的产品能够相互兼容，世界范围内需要通用的CAN应用层通信协议。 在过去的二三十年中涌现出许多的协议，不过到现在为止能够广泛被承认的协议却不多，现在应用较广的CAN应用层协议主要有以下三种：CANopen协议：主要应用在汽车、工业控制、自动化仪表等领域，目前由 CIA 负责管理和维护； J1939协议：CAN总线在商用车领域占有绝大部分市场份额的应用层协议，由美国机动车工程师学会发起，现已在全球范围内得到广泛的应用； DeviceNet协议：在美国等地占有相当大的市场份额，主要用于工业通信及控制和仪器仪表等领域。 而本文说的CANOpen也是目前应用较广的一种协议。简单的说，CANOpen就是CAN总线应用层协议。 PS：学习CANOpen应用层协议之前请务必先了解CAN总线协议。 三、CAN总线特点CAN总线采用差分信号传输，通常情况下只需要两根信号线（CAN-H和CAN-L）就可以进行正常的通信。在干扰比较强的场合，还需要用到屏蔽地即CAN-G（主要功能是屏蔽干扰信号）， CAN协议推荐用户使用屏蔽双绞线作为CAN总线的传输线。 CAN总线通信的优势和特点：A.CAN总线上任意节点，均可在任意时刻主动的向其它节点发起通信，但在同一时刻优先级高的节点能获得总线的使用权。 B.标准CAN总线传输波特率可达到1Mbps。在5Kbps的通信波特率下最远传输距离可以达到 10Km，即使在1Mbps的波特率下也能传输40m的距离。 C.CAN总线定义使用了硬件报文滤波，可实现点对点及点对多点的通信方式，不需要软件来控制。 D.CAN总线所挂接的节点数量主要取决于CAN总线收发器或驱动器，目前的驱动器一般都可以使同一网络容量达到110个节点。 E.CAN总线通信介质可采用双绞线、同轴电缆或光纤，选择极为灵活。可大大节约组网成本。 当然，CAN总线的优势还有许多，当你掌握之后就会明白为什么CAN总线应用得如此广泛了。 四、教程规划CAN总线及CANOpen协议相关的内容相对比较多，如果每一个细节知识点都写出来，可能花掉我业余时间写一年也写不完。 我写该教程目的在于引导初学者入门，我会结合实例代码让大家边学边理解，至于实际项目编程应用不一定讲述的很多（这个看后面情况）。 首先从CAN底层讲起，再到CANOpen协议相关基础知识，最后实际应用。当然，中间每一个环节内容相对可能较多，也有可能会遗漏部分内容。 五、说明1.该文档部分文字来自周立功的相关教程，仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【CANOpen系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>CANOpen系列教程</category>
      </categories>
      <tags>
        <tag>CAN</tag>
        <tag>CAN总线</tag>
        <tag>CANOpen</tag>
        <tag>CanFestival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【MAVLink学习之路】做了整理并汇总，会随着该系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、教程列表1.MAVLink学习之路01_认识MAVLink 2.MAVLink学习之路02_工具下载、环境搭建 3.MAVLink学习之路03_XML中定义MSG并生成C代码 4.MAVLink学习之路04_MAVLink移植到STM32具体步骤 5.MAVLink学习之路05_MAVLink应用编程接口分析 正在努力更新中，敬请等待…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路05_MAVLink应用编程接口分析]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF05_MAVLink%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[一、写在前面 前面写的几篇文章你掌握了，说明你离成功很近了。那么本文就带你真正进入编程的世界，让你进一步掌握MAVLink应用编程的重要知识点。 本文主要内容： ·MAVLink应用编程主要内容 ·MAVLink函数接口详细说明 提示：本文结合上一篇文章提供给大家下载的“MAVLink发送接收例程”进行讲解，请结合例程理解本文。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、MAVLink应用编程主要内容2.1 发送和接收说明利用MAVLink通信协议进行编程，主要实现的功能就是： 1.发送端将需要发送的数据（如：SysState, BatVol），添加MAVLink通信协议，通过硬件（如：UART、CAN）发送出去。 2.接收端硬件（如：UART、CAN）接收到的数据，通过MAVLink协议解析，得到一帧完整的MAVLink数据包，提取发送端发送的数据（如：SysState, BatVol），将得到的数据应用到我们程序中。 主要流程：数据 -&gt; MAVLink封装 -&gt; 发送 -&gt; 接收 -&gt; MAVLink解析 -&gt;数据 2.2 发送和接收流程图 该流程图是结合我上一篇文章提供的源代码例程画出来，包含的只是主要内容，更多细节没有在流程图中呈现。 提示：我提供例程是针对初学者提供比较单一发送和接收例程（MDK-ARM和EWARM包含各自的发送和接收工程）。 而实际项目可能会：1.发送和接收在一个工程；2.包含操作系统；3.发送、接收数据FIFO（队列）处理； 所以，实际项目，请按需修改我提供的源码。 三、MAVLink函数接口详细说明这一章节讲述发送和接收主要用到的函数接口，请参考我提供的源代码例程理解。为方便初学者理解，我将其分为发送和接收两个部分来讲述。 3.1 发送主要函数接口 上面是我提供例程的代码，主要讲4个接口。 1.MAVLink_SendTest这个接口是根据自己情况进行封装函数，用于应用程序调用，这里不多说。 2.mavlink_msg_sys_info_pack这个函数接口主要目的：将变量信息（SysID、CompID、SysState、BatVol）打包，最终得到MAVLink_Msg这个消息包。 3.mavlink_msg_to_send_buffer将上一步得到的MAVLink_Msg转换成我们要发送的数据BUF缓存。 4.MAV_USART_SendNByte这个函数接口也是我自己根据硬件（UART）封装的，如果你是其它硬件通信，只需要封装一个类似的接口（参数具有BUF，LEN）即可。 发送数据的流程：从应用代码 -&gt; 底层硬件（发送出去）。 如果要深入了解，可以先熟悉软件流程，再结合源代码工程，同时参看接口函数具体实现。相信你很快就明白了。 3.2 接收主要函数接口 上面是我提供例程的代码（方便截图，去掉了部分），主要讲以上4点内容。 1.MAV_USART_GetByte该函数接口也是硬件底层通信接口，请根据自己情况修改，只需要传递数据（流）进来即可。 2.mavlink_parse_charMAVLink解析是按照一个一个字符进行解析，我们接收到一个字符，就对其进行解析，直到解析完（根据返回标志判断）一帧数据为止。 3.if(MAVLINK_MSG_ID_SYS_INFO == MAVLinkMsg.msgid)这里就是对解析好的一包完整消息进行分类判断吧。其实，我是想说，这个地方还有两个ID需要进行判断，SysID系统ID和CompID部件ID。 我提供例程为方便初学者快速理解，未提供SysID和CompID判断，在后续应用编程中会用到。 4.mavlink_msg_sys_info_get_voltage_battery通过该接口获取消息变量，看图中说明文字，前面是消息，后面是消息变量。 接收数据的流程：从应用代码 -&gt; 底层硬件（发送出去）。 以上就是发送和接收的主要函数接口，如果你只是简单的进行通信，这几个接口就够你使用了。当然，更高级的编程应用还需要你进一步掌握其中的内容。 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路04_MAVLink移植到STM32具体步骤]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF04_MAVLink%E7%A7%BB%E6%A4%8D%E5%88%B0STM32%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4.html</url>
    <content type="text"><![CDATA[一、写在前面 《MAVLink学习之路》前面三篇文章，可以说是一些基础知识，也是为本文做的准备工作（建议初学者先了解前面三篇文章）。 本文主要内容： ·MAVLink移植主要步骤 ·MAVLink移植过程要点 提示：为方便广大初学者朋友尽快掌握MAVLink，我在文末提供MAVLink发送接收例程（基于STM32硬件、MDK-ARM和EWARM开发环境）。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、MAVLink移植主要步骤2.1 移植说明 本文主要针对MAVLink C源代码移植进行讲述。其中，MAVLink的C源代码可以下载网上预生成的C源代码库，也可以通过生成器工具生成。 A.下载预生成C代码库 如果是使用标准MAVLink的MSG消息，则可以现在官方指定地址预先生成的C代码库。预先生成C代码库总共两个版本：MAVLink V1版：https://github.com/mavlink/c_library_v1MAVLink V2版：https://github.com/mavlink/c_library_v1 B.生成器生成C代码 如果你需要自定义MSG消息，则需要自己通过工具生成C代码，具体生成方法请参看文章：《MAVLink学习之路03_XML中定义MSG并生成C代码.》 提示： 官方预生成C代码库就是通过生成器而生成的，官方提供的生成器工具、预生成C代码库不定期更新。也就是说可能你不同时期看到的预生成库不同，不同时期的生成器及其生成的代码也有所不同。 如上图，官方预生成的C代码（V1版），与通过生成器生成的代码完全一样。如common.xml通过生成器生成的C代码就和上面紫红色框出来的代码一样。当然，生成器版本也是这最新的才对。 2.2 移植主要步骤1.下载相关工具2.环境搭建3.生成C代码（如果下载官方预生成代码，前面两步可以不用）4.将C代码添加到工程5.配置（如添加MAVLink路径、修改代码适配工程）6.添加MAVLink发送接收（及应用）代码 步骤1， 2， 3已经在前面文章详细讲述了，本文主要讲述步骤4， 5。步骤6下一篇文章详细讲述。 三、MAVLink移植过程要点本节主要内容讲述将C代码添加到工程，然后配置，到编译没有错误这一过程中的一些重要知识点。 3.1 代码添加到工程代码添加到工程其实很简单，将代码拷贝工程文件下，类似如下图，添加组，添加源文件。 但是，MAVLink源代码都是.h头文件，可以不用像上面那样添加到工程。当然，添加头文件到工程的好处就是可以快速打开头文件，查找相关代码。 说这一小节是想提示大家：MAVLink的C源代码都是.h头文件。头文件只需要添加对应路径，包含头文件即可（#include “mavlink.h”）。 3.2 配置1.添加路径Keil MDK-ARM和IAR EWARM添加路径这项内容我就不在这里详细讲述了，不会的朋友可以参看看我的文章：Keil MDK-ARM系列教程（一）_新建软件工程详细过程IAR EWARM系列教程（一）_新建软件工程详细过程 3.3 修改代码这小节内容可以参看网上一篇博文：https://www.cnblogs.com/lovechen/p/5809709.html那篇文章讲述的很多，我讲一下重点：它修改的代码是针对老版本主要需要修改两个地方。而且新版本MAVLink生成器已经优化了一个项，也就是只有一个地方需要修改：修改mavlink_types.h. 1.针对Keil MDK-ARM 2.针对IAR EWARM 12添加预定义：#pragma anon_unions替换代码：#define MAVPACKED( __Declaration__ ) __Declaration__ 那篇文章针对的是老版MAVLink还需要修改一个const的地方，我这里就不说了（新来的建议用新版的）。 为什么这里要修改呢？原因在于编译器的差异导致的。 3.4 补充知识点1.#pragma anon_unionskeil中默认是不支持匿名结构体的，需要编译指令#pragma anon_unions指名。 2.MAVPACKED如果不修改代码，直接编译，发现有许多错误，原因都来自MAVPACKED。结合修改的内容，再看下图，有什么启发没有。 四、源代码下载地址：https://pan.baidu.com/s/1xraErAnmL-BN9CMwE6aQ密码：cusq 提示：包含四个工程：Keil、IAR各自的发送和接收工程。如果链接失效，请到公众号回复【MAVLink学习之路】查看更新链接。 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路03_XML中定义MSG并生成C代码]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF03_XML%E4%B8%AD%E5%AE%9A%E4%B9%89MSG%E5%B9%B6%E7%94%9F%E6%88%90C%E4%BB%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[一、写在前面 如果你前面两篇文章掌握了，说明你已经入门了。本文带你掌握如何在XML文件中定义Message（MSG消息）并生成C代码。 本文主要内容： ·如何在XML文件中定义Message（消息） ·如何通过生成器工具生成MAVLink C代码 提示：本文将结合上一篇文章提供下载的“MAVlink代码生成工具包”来讲述。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、XML文件中定义MSG2.1 关于MSGMAVLink的MSG消息定义在XML文件中，通过生成器工具（Mavenerate或Mavgen）生成MAVLink C代码； 在MAVLink协议中，每一条MSG消息都具有一个ID，且ID具有唯一性。MSG消息ID其实就是对应协议格式中msgid，如下图： 简单来说：在xml中定义一条Message消息，通过生成器工具就能生成该Message对应的C代码（一条Message也可以理解成一条通信命令）。 提示：在MAVLink V1版本中，消息ID有效数字的范围为0到255。 其中0到149为公共消息ID（飞控系统共有消息，一般不建议用于自定义）。而150到240为用于自定义消息的ID范围。 比如，打开前面下载的工具包消息定义的文件夹（如下图），可以看到：common.xml文件主要是一些公共消息ID范围为：0到149。而其它xml文件是针对不同系统定义的消息，主要集中在150到240之间。 2.2 MSG的定义方法 MAVLink的MSG消息定义在XML文件中，所以遵循XML语法规则。语法很简单（只需要记住部分常用的就行），我们可以参考MAVLink定义好的xml文件。 解压上一篇文章下载“MAVlink代码生成工具包”，打开（路径MAVLink \ message_definitions \ v1.0下）common.xml文件，我们以“心跳”为例： 从上图可以看出：“心跳”消息包含：消息ID、描述（注释）以及各项参数（可以理解为一个函数，及函数的参数）。 1.《message》《/message》标签每条消息都被定义在这样一个消息标签内。 2.id=“0”表示此消息的id或index编号为0。 3.name=“HEARTBEAT”该ID编号对应的名称。 4.《description》《/description》对该消息的描述，是一个非常重要，但可选的领域（意思是可以不用定义），可以理解为代码的注释。 5.《field》《/field》对消息的一个字段进行定义，它类似于C语言中的一个变量，可以是8,16,32和64位长度（有符号或无符号），以及浮点类型等。 6.type=“uint8_t”将此字段定义为8位无符号整数。数组的定义如下：type=“uint8_t[5]”。可以理解为一个函数参数的数据类型。 7.name = “type” 该字段的名称，可以理解为一个函数参数的名称。 8.Type of the MAV字段说明，可以理解为函数参数的注释。 上面文字描述可能理解起来比较困难，看下图心跳消息对应生成的C代码： 以上举例，只是提供其中一个函数接口，其实还会生成更多与该消息相关的接口、结构体等。 2.3 enum的定义方法上面2.2节在xml中定义消息明白了，这节enum（枚举）的定义就很容易理解了，原理一样。 枚举和消息只是内容有所差异，定义原理都类似。枚举包含：枚举名称，成员（元素）名称，成员值等。 枚举的定义就不详细描述出来，提供枚举xml定义和生成C代码，相信你一看就能明白。 xml中定义的MAV_AUTOPILOT： 生成的C代码： 提示：关于消息定义，更多的内容可以参看：http://qgroundcontrol.org/mavlink/create_new_mavlink_message 三、通过生成器工具生成MAVLink C代码上面第二章节在xml文件中定义好了MSG消息和enum枚举，那么，就需要通过生成器工具生成我们最终需要的代码（我主要讲述生成C代码）。 MAVLink项目提供有生成器有两种：Mavgenerate（GUI）和Mavgen（命令行）； 使用生成器工具前提需要搭建好环境，请参考：MAVLink学习之路02_工具下载、环境搭建 3.1 Mavgenerate生成C代码这个工具使用方法很简单，环境搭建好之后，解压下载工具包，在当前路径下输入命令“python mavgenerate.py”，或者双击mavgenerate.py即可打开： 3.2 Mavgen生成C代码 Mavgen生成器是一个通过命令实现的工具，命令很简单，比如：python -m pymavlink.tools.mavgen –lang=C –wire-protocol=1.0 –output=generated/include/mavlink/v1.0 message_definitions/v1.0/common.xml 命令的具体描述请看下图： 3.3 关于生成器几点提示1.Mavgen支持的语言及版本 2.路径因为命令行生成器支持相对路径，建议将xml文件拷贝到如下路径：MAVLink\message_definitions\v1.0 3.命令语法和选项说明 初学者不用深入理解，只需要知道如何生成C代码即可（参考我上面提供的哪一条命令）。 关于生成器工具更多的内容可以参考：https://mavlink.io/en/getting_started/generate_libraries.html 四、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路02_工具下载、环境搭建]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF02_%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[一、写在前面初学者学习本文之前，建议参看我的上一篇文章：《MAVLink学习之路01_认识MAVLink》 本文主要两个内容： ·下载相应安装包及工具 ·环境搭建 其中环境搭建是很多初学朋友从入门到放弃的一个重要阶段。环境搭建难度不大，解决问题重要的一点：针对问题找解决办法。不要看到问题就撤退，否则，只有一个结果：就是放弃。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、下载2.1 下载说明1.git工具建议提前git工具，方便下载、环境搭建、启动GUI等。（当然，不使用git也行，下载压缩包，使用Windows自带命令行） 2.系统MAVLink开发环境可以搭建在Windoes和Linux系统，本教程只讲述基于Windows搭建环境以及后期的开发。（基于Linux系统的环境搭建可以自己研究一下） 3.下载内容第一类：MAVlink环境搭建工具包 ·Python ·Future 第二类：MAVlink代码生成工具包 ·MAVLink（含pymavlink） 我把它分为以上两类（当然，这是我自己的分类方式，可能不完全正确），主要就是下载Python、Future、MAVLink、pymavlink四项内容。 下载的方式： ·官网（推荐） ·百度网盘（可能会失效） 2.2 环境搭建安装包下载2.2.1 PythonPython版本分Python2和Python3。官方推荐安装：Python 2.7+ or 3.3+. 因为许多使用Python支持的工具对Python 2具有更好的兼容性（比如我接下来要讲述的CANOpen文章，生成对象字典同样需要Python 2的支持），我一般推荐使用Python 2.7。 官网下载地址：https://www.python.org/downloads 百度网盘：https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA密码: q8ic （目前2018年8月最新Python 2.7.15，网盘后期地址可能会失效，建议到官网下载最新版本） 2.2.2 Futurefuture可以下载安装文件进行离线安装，也可以输入命令在线安装。（下章节讲述安装） 官网下载地址：https://pypi.org/project/future/#files 百度网盘：https://pan.baidu.com/s/1431mrvqMA-oucVPPGPHyDA密码: q8ic 2.3 MAVlink代码生成工具包MAVlink代码生成工具包，环境搭建完成之后，用于代码生成的一项工具包（后面文章讲述代码生成会用到这工具包）。 官网下载地址：https://github.com/mavlink/mavlink 建议使用Git工具下载（当然，也可以直接下载压缩包）。 百度网盘：https://pan.baidu.com/s/1dIzR3YzYsyecBGZgReSpYg密码: t9pi 三、环境搭建3.1 环境搭建说明环境搭建也就是安装相关软件，主要是安装Python和Future这两个软件。 安装这两个软件很容易，难点在于有些细节问题，下面我会针对常见问题提出来（当然，因系统或配置等各种原因，所体现出来的问题也有所不同）。 3.2 安装Python1.直接双击Python安装，会出现类似如下图错误 所以，不建议直接双击Python安装包进行安装，按照下面方式：以管理员方式运行安装。 2.以管理员是身份运行cmd Win -&gt; 输入cmd -&gt; 选中“命令提示符”右键 -&gt; 以管理员身份运行 3.安装 路径 + 安装文件（含后缀）：D:\Desktop\python-2.7.15.msi（根据自己路径修改） 安装的很多步骤按照提示操作即可（一般点击next即可），重要的内容下面我提示一下。 4.添加路径 这一步添加路径的作用就是添加系统环境变量（也是很多朋友失败的原因）。不选择的话，就需要安装好之后自己在环境变量中添加路径。 安装Python主要注意以上两点即可。 5.检验是否安装成功A.查看系统环境变量，是否具有python路径。B.CMD输入python，验证是否安装成功，如下图： 3.3 安装Future安装future有两种方法：1.输入命令在线安装； 2.下载安装文件，离线安装。（这里可以使用windows自带命令行，也可以使用git命令行） 1.在线安装输入命令：pip install future （推荐使用该方法） 2.离线安装前提是下载好安装包，进入安装包路径，输入安装命令：python setup.py install 四、验证环境变量验证环境变量是否安装成功：下载“MAVlink代码生成工具包” -&gt; 解压 -&gt; 进入MAVlink路径 -&gt; 输入命令python mavgenerate.py，出现如下对话框则成功。 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink学习之路01_认识MAVLink]]></title>
    <url>%2FMAVLink%2FMAVLink%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF01_%E8%AE%A4%E8%AF%86MAVLink.html</url>
    <content type="text"><![CDATA[一、写在前面1.MAVLink是一种非常轻量级的通信协议，在简单的8位单片机上也可以运行。 2.MAVLink的初衷主要是用于无人机上，但它的通用性和可移植性非常好，它也可以应用于其它很多场合。 3.MAVLink的设计方式值得学习通信的朋友研究一下。 因此，学习无人机开发、学习通信原理、需要实现设备间通信的朋友都值得参看本文。 本文章收录于【MAVLink学习之路】，在我的博客分类“MAVLink学习之路”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看。 二、关于MAVLink2.1 描述MAVLink：Micro Air Vehicle Link，即微型飞行器连接通信协议，于2009年初由Lorenz Meier首次发布。 Mavlink协议是在串口通讯基础上的一种更高层的开源通讯协议。 MAVLink是一种非常轻量级的通信协议，主要用于与无人机（以及板载无人机组件之间）进行通信。 2.2 主要特征1.效率很高MAVLink V1每帧最少只有8个字节的数据，包括帧头和数据包丢弃检测；MAVLink V2每帧最少只有14个字节的数据(是一个更加安全和可扩展的协议); 2.非常可靠自2009年以来，MAVLink一直被用于在各种不同且具有挑战性的通信信道上的许多不同车辆，地面站（和其他节点）之间进行通信。它提供了检测数据包丢失，损坏和数据包身份验证的方法。 3.支持多种编程语言可在多种MCU（如：STM32、Atmega、ARM7）和操作系统（如：Windows，Linux，MacOS，Android和iOS）上运行。 4.支持网络上最多255个并发系统 2.3 参考网址官网：https://mavlink.io/en 地面站：http://qgroundcontrol.org/mavlink/start 维基百科：https://en.wikipedia.org/wiki/MAVLink 三、MAVLink协议格式目前MAVLink有两个版本：V1和V2版本，差异及详情请看下图： MAVLink V2是V1的拓展版本，是一个更加安全和可扩展的协议。 由于市面上应用较广的还是V1版本，且支持的编程语言也是V1多余V2。因此，接下来（MAVLink学习之路）我都会结合MAVLink V1来讲述（学会V1，V2和容易就掌握了）。 3.1 MAVLink V1格式MAVLink通信内容包含常见通信协议帧头、帧尾、长度、校验等。协议格式及详情见下图： 四、MAVLink使用方法和步骤MAVLink之所以受广大无人机开发朋友的喜爱，原因就在于MAVLink移植方便、操作简单，以及它的兼容性很好（当然，这些都是它的优点，缺点肯定也是有的）。 要想使用MAVLink，一些基本的操作肯定还是得有。方便初学者对MAVLinK有进一步的认识，我先罗列主要步骤。 4.1 主要步骤1.下载相应安装包及工具 2.环境搭建 3.通过xml配置MSG 4.移植到STM32 5.结合实例应用编程 当然，以上几点只是概要内容，后续的文章会详细讲述其中的内容，敬请等待… 五、说明1.该文档仅供个人学习使用，版权所有，禁止商用。 2.本文由我一个人编辑并整理，难免存在一些错误。 3.为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该教程同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【MAVLink学习之路】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 我的微信公众号（ID：strongerHuang）还在分享STM8、STM32、Keil、IAR、FreeRTOS、UCOS、RT-Thread、CANOpen、Modbus…等更多精彩内容，如果想查看更多内容，可以关注我的微信公众号。]]></content>
      <categories>
        <category>MAVLink学习之路</category>
      </categories>
      <tags>
        <tag>MAVLink</tag>
        <tag>无人机</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 本文对【EWSTM8系列教程】做了整理并汇总，会随着系列教程的更新而更新。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、教程列表1.EWSTM8系列教程01_IAR介绍、下载、安装和注册 2.EWSTM8系列教程02_新建基础软件工程 3.EWSTM8系列教程03_主窗口、工具栏的概述 4.EWSTM8系列教程04_菜单概述（一） 5.EWSTM8系列教程05_菜单概述（二） 6.EWSTM8系列教程06_工程节点选项配置（一） 7.EWSTM8系列教程07_工程节点选项配置（二） 8.EWSTM8系列教程08_IDE选项配置（一） 9.EWSTM8系列教程09_IDE选项配置（二） 10.EWSTM8系列教程10_一个工程添加多个节点 11.EWSTM8系列教程11_一个工作空间添加多个工程 12.EWSTM8系列教程12_IAR文件类型描述 正在努力更新中，敬请等待…… 三、说明1.该文档仅供个人学习使用，版权所有，禁止商用。2.本文主要针对个人学习使用的朋友，若你是商业用途，建议购买正版软件。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 四、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程12_IAR文件类型描述]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B12_IAR%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面1.你保存、或者打包拷贝一个项目时，你会删掉不必要的文件吗？2.你知道这些eww、ewp、ewd……是什么文件吗？ 主要文件： 现象or疑问：1.购买一块开发板，厂家提供的源代码例程没有几个，但文件大小却有几百兆。2.百度网盘下载一个别人提供的代码压缩包，大小几十兆。3.打开别人下载的源代码工程，各种类型文件混杂在一起。4.我看有些人提供的源代码没有dep文件，这个文件可以删除吗？ 删除了会有什么影响？ 当你看完本文，理解这些文件类型的含义，你就不会有上面这些烦恼了。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、IAR文件类型概述 IAR中用到的文件类型很多，大概有四五十种，一般就是源代码和工程文件（含配置，编译生成文件）。下面会重点讲述常用的文件类型，一些不重要的，或者不常见的只简单概述。 分类：1.源代码类：.c、 .h、 .cpp、 .asm、 .a等；2.工程文件类：.eww、 .ewp、 .ewd、 .ewt、 .dep等；3.Exe文件类：hex、 .bin、 .out等；4.List类：.map、 .lst等；5.Obj类：.o、 .pbi、 .xcl等；6.settings类：.dbgdt、 .bat、 .ps1等； 下面我就按照上面分类，进行分章节讲述，重要的会标记出来，请注意查看标注内容。 三、源代码类文件这类文件类型编程时我们最先了解的，不多说，只概述。1.cC语言源代码文件 2.h头文件 3.cppC plus plus的意思，也就是C++源代码文件 4.asm汇编源代码文件 5.s汇编程序源代码文件 6.aIAR的库文件 7.inc汇编头文件 四、工程类文件这类文件比较重要，下面前两个eww、 ewp是一个项目中最重要的文件，是不可删除的文件。 1.eww全拼：Embedded Workbench Workspace，即IAR工作空间文件（不可删除）。 我们新建一个工作空间就会产生该文件，一个项目必须包含一个eww文件。所以，改文件不可删除。 参看文章：EWSTM8系列教程11_一个工作空间添加多个工程 2.ewp全拼：Embedded Workbench Project，即IAR工程文件（不可删除）。 新建一个工程，工程包含的信息就在这个文件里面。 参看文章：EWSTM8系列教程10_一个工程添加多个节点 3.ewd工程配置文件，主要是Debug相关的配置。删除之后Debug相关的配置恢复默认设置（一般不建议删除）。 4.ewt工程配置文件，主要是工程静态分析（C-STAT and C-RUN）配置文件。C-STAT and C-RUN文件 Project -&gt; Options -&gt; Static Analysis可以看见C-STAT，也就是静态分析相关的文件，如果不配置静态分析，可以删除这个ewt文件。 5.depDep：Dependency information，即依赖信息。 6.icf链接器配置文件： Project -&gt; Options -&gt; Linker -&gt; Config -&gt; configuration file。 五、Exe类文件默认位于Exe文件夹下面的文件，如Project\Debug\Exe，这类文件可删除。 1.hexIntel格式固件文件（用于下载的可执行文件）。Project -&gt; Options -&gt; Output Coverter。 2.Bin二进制格式固件文件（用于下载的可执行文件），与hex主要区别在于：bin文件不包含地址信息。 3.out编译输出的调试信息文件，若不输出调试信息，则没有。 六、List类文件默认位于List文件夹下面的列表文件，如Project\Debug\List，这类文件可删除。 1.map映射文件。该文件是分析代码内存占用情况的重要的文件，但可以删除。很多遇到问题之后会进入硬件故障（HardFault_Handler）等中断，就需要进一步分析map文件。 七、Obj类文件默认位于Obj文件夹下面的目标文件，如Project\Debug\Obj。在编译之后会输出许多这类目标文件，属于中间文件。因此，这类文件之后保存工程时可以删除。1.o目标模块文件，该文件就是对应每一个.c文件编译后的文件“Object module”。 2.browse浏览文件，主要用于“Go to Definition of”功能。使能开关：Tools -&gt; Options -&gt; Project -&gt; Generatie browse information。 3.pbi、.pbd主要也是用于浏览信息的文件。 4.inf链接器配置文件。 5.xcl扩展命令行文件 八、settings类默认位于settings文件夹下面的文件，如Project\settings。这类文件属于中间文件，可以删除。 1.wsdt工作区桌面设置文件，打开工作空间就会存在该文件。 2.bat批处理文件 好啦，就讲述到这里，更多文件类型及说明请看下图： 汇总文件类型： 九、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 十、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程11_一个工作空间添加多个工程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B11_%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 如果你是初学者，还没有理解IAR中（工作空间 &gt; 工程 &gt; 节点）相关基础知识，建议先参看我的另外两篇文章： EWSTM8系列教程06_工程节点选项配置（一） EWSTM8系列教程10_一个工程添加多个节点 当你明白工作空间和工程之间的关系，这篇文章的知识你很快就能明白了。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、工作空间与工程的关系 本章节算是回顾知识点：工作空间与工程其实是包含的关系，一个工作空间可以包含多个工程。下图是工作空间、 工程、 节点三者的关系： 提示：在IAR中叫Node（节点），而在Keil中叫Target（目标）。其实这两者意思一样，都是隶属于工程的下一级。 三、为什么一个工作空间要添加多个工程简单回答：为了统一管理项目。 例如：1.某个项目有一个主机，多个从机，而且每个从机代码不一样。当公司有多个类似项目的情况下，公司为了统一管理项目，就会将一个项目规定为一个工作空间。 2.因公司很多工程都会使用到同样的代码（如算法库、标准外设库等），公司就会将这些工程整理到一个工作空间下。 当然，以上举例说的可能有点笼统，对于初学者，首先要掌握工程。 比如我之前文章提供的工程：STM8S-A01_GPIO基础知识、STM8S-A02_TIM精确延时、STM8S-A03_TIM定时中断……等。我可以将这些工程添加到一个工作空间下。 提示：关于工作空间添加多工程的作用和意义，初学者不必深入理解，当你学到一定程度自然就明白了。 四、工作空间如何添加多个工程工作空间添加工程可以说没有一点难度，添加一个工程10秒钟之内就能完成。而难点在于新建工程以及工程节点相关的配置。 本文工作空间添加工程，很多相关知识点是基于该系列教程前面分享的一些内容。主要两点内容：新建工程、节点选项配置。请参考下面文章：EWSTM8系列教程02_新建基础软件工程EWSTM8系列教程06_工程节点选项配置（一）EWSTM8系列教程07_工程节点选项配置（二） 按照上面文章新建好工程及相应节点配置好之后，就可在工作空间中添加这些工程了。 这里默认新建并配置好了三个工程：Project1、Project2、Project3。将这三个工程添加到工作空间Workspace中。 提示：最后我将提供这个例子代码下载。但这里只是提供例子，Project1、2、3这三个工程的源代码和功能都类似（一般实际项目源码和功能不会相同）。同时，Project1、Workspace这种命名也是方便理解（请根据项目实际情况命名）。 4.1 整理文件夹及文件 4.2 新建工作空间打开IAR软件 -&gt; File -&gt; New Workspace -&gt; Save Workspace As…保存在上面新建的Workspace文件夹下面。 具体请看下面动画效果： 新建工作空间动画效果： 4.3 添加已存在工程本文默认工程已经建立（具体过程请参考文章“新建基础软件工程”），所以只需要添加已存在工程即可。 菜单Project -&gt; Add Existing Project -&gt; 选择需要添加的工程（重复一样动作，添加三个已存在工程）： 添加已存在工程动画效果： 4.4 工作空间与工程预览按照上面步骤最后得出工作空间和工程的结构，如下图： 再次提示：此方法仅仅提供一种方法和思路，方便大家学习和掌握。具体内容根据实际项目情况而定。 五、多工程工作空间源代码下载为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。百度网盘下载地址：https://pan.baidu.com/s/1qIfaF0c-I_I4xGveFqwLDA密码: mpm2 GitHub下载地址：https://github.com/EmbeddedDevelop/STM8S_Multi-Project.git （提示：下载链接后期可能会失效， 若失效请关注微信公众号获取） 六、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程10_一个工程添加多个节点]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B10_%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9.html</url>
    <content type="text"><![CDATA[一、写在前面 使用IAR新建一个工程，默认会创建Debug（调试）和Release（释放）两个Node（节点）。 什么是节点？ 为什么要创建这两个节点？ 创建多个节点目的和意义？ 如何创建多个节点？ 带着这些疑问来学习本文才会有更多收获。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、什么是节点 本文讲述添加多个节点，就需要了解什么是节点。之前文章《EWSTM8系列教程06_工程节点选项配置（一）》初略讲述了一下工作空间、 工程、 节点三者的关系： 提示：在IAR中叫Node（节点），而在Keil中叫Target（目标）。其实这两者意思一样，都是隶属于工程的下一级。 三、Debug与Release节点区别新建一个工程，默认创建两个节点，如下图： 在上一节了解了工程与节点之间的关系，那么为什么要一个工程下创建两个节点呢？ 两个节点的区别：Debug节点：主要用于调试使用，包含调试信息。Release节点：主要用于生成代码（正式产品），不包含调试信息。 细心的朋友会发现，这两个节点选项配置中有几个地方不同，如：C/C++ Compiler下的Output和Preprocessor选项、Assembler下的Output选项等。 关于节点选项配置内容可以参看文章《EWSTM8系列教程06_工程节点选项配置（一）》。 看了Debug和Release这两个节点的区别，相信你应该大概理解了为什么一个工程下要创建多个节点了。 其实，实际项目中还有很多用途，比如：同款产品，不同配置（不同芯片型号，不同编译等级…等节点选项配置不同）。 四、如何创建多个节点4.1 主要步骤1.创建一个工程2.添加组，添加文件3.工程节点选项配置4.基于某一个节点添加新的节点 其实这四个步骤中前三个都已经在文章《EWSTM8系列教程02_新建基础软件工程》中实现了，这里列出来主要是给初学者一个（从前到后的）提示。 下面就基于《EWSTM8系列教程02_新建基础软件工程》建好的工程，在Debug节点基础上添加一个Test节点。 4.2 添加Test节点1.Project -&gt; Edit Configurations进入编辑配置 2.点击“New”进入添加新节点配置 A.填写节点名称；B.基于某节点，这里相当于拷贝选择节点选项配置；C.默认设置为Debug或Release; 配置好之后，点击OK，再点击OK就行了。 3.修改节点选项配置比如：修改Test节点输出格式从hex格式修改为bin格式； 选择Test节点 -&gt; 选中节点右键 -&gt; Options -&gt; Output Converter -&gt;修改成bin格式。具体操作可以参看下面动画效果： 修改节点选项配置动画效果： 最后提示： 多个节点之间的区别总结来说就是：各自节点的选项配置不同。当然，可能就一个选项配置不同，也可能多个。节点选项的配置内容很多，请参看《EWSTM8系列教程06_工程节点选项配置（一）》。 五、多节点工程源代码下载为方便大家学习，我这里提供可直接编译运行的源代码供大家下载。百度网盘下载地址：https://pan.baidu.com/s/16elpok-5IdPYoeNGXXFszw密码：m9pa GitHub下载地址：https://github.com/EmbeddedDevelop/STM8S_Multi-Node.git （提示：下载链接后期可能会失效， 请关注微信公众号公告消息） 六、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程09_IDE选项配置（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B09_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章《EWSTM8系列教程08_IDE选项配置（一）》讲述了IDE选项中前五项（Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息）的内容。 本文讲述剩余的几项内容：Project工程、Source Code Control源代码控制、Debugger调试器、Stack堆栈、Terminal I/O终端（Terminal I/O项只有在调试模式下才有）。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Project工程该IDE选项配置与工程相关，比如下面讲述的在编译工程的时遇到错误是否停止编译、在编译之前保存Workspace工作空间、Project工程等。 此页面用于Make和Build命令设置选项。 1.Stop build operation on：在如下情况停止编译操作A.Never：从不停止编译B.Warnings：遇到警告停止编译C.Errors：遇到错误停止编译 2.Save editor windows before building：在编译之前保存编辑（修改）过的文件A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 3.Save workspace and projects before building：在编译之前保存工作空间和工程A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 4.Make before debugging：在调试之前编译（Make）一下A.Never：从不编译B.Ask：询问是否编译C.Always：总是编译 5.Reload last workspace at startup：启动IAR时重新加载（打开）最近的工作空间 6.Play a sound after build operations：在编译操作之后播放声音 7.Generate browse information：生成浏览信息比如：Go to Definition跟踪代码的信息 8.No source browser and build status updates when the IDE is not the foreground process：当IDE不是前台进程时，不浏览源码和编译状态等更新操作 9.Enable project connections：使能工程链接使能该选项，需结合Project -&gt; Add Project Connection一起操作； 10.Enable parallel build：使能并行编译编译器在几个并行进程中运行，以便更好地使用CPU中的可用内核。后面参数为并行处理数。 三、Source Code Control源代码控制 1.Keep items checked out when checking in：当检查时保持项目输出 2.Save editor windows before performing source code control commands：在执行源代码控制命令之前保存编辑器窗口A.Never：从不保存B.Ask：询问是否保存C.Always：总是保存 提示：该IDE配置选项属于老版本配置选项，不适合新版本。 四、Debugger调试器 此页面特定用于调试器环境的配置。 1.When source resolves to multiple function instances：当源解析为多个函数实例时Automatically choose all instances：自动选择所有实例 2.Source code color in disassembly window：汇编窗口源代码颜色 3.Step into functions：跳入运行函数单步（Step into）调试时执行的操作：All functions：（一步一步）跳入所有函数Functions with source only：只跳入（当前）源代码函数 4.STL container expansion：STL容器扩展Depth：深入数 5.Update intervals：更新时间间隔指定Live Watch窗口和Memory窗口的内容更新的频率（单位：毫秒）。 6.Default integer format：默认整型格式Binary：二进制Octal：八进制Decimal：十进制Hexadecimal：十六进制 7.Window classification by background color：窗口分类的背景颜色比如：汇编窗口是一种背景色，内存窗口又是另外一种背景色。 五、Stack堆栈 此页面用于堆栈窗口的选项配置。 1.Enable graphical stack display and stack usage tracking：使能图形堆栈显示和堆栈使用跟踪stack usage threshold：堆栈使用阈值Warn when exceeding stack threshold：超过堆栈阈值时发出警告 2.Warn when stack pointer is out of bounds：当堆栈指针超出范围时发出警告 3.Stack pointer(s) not valid until program reaches：堆栈指针直到程序到达如下位置（main）时才有效在应用程序代码中指定您希望堆栈显示和验证发生的位置，如图，在程序运行到main函数才有效（进行校验）。 4.Warnings：警告选择应该发出警告的位置：Log：日志Log and alert：日志和警告 5.Limit stack display to：限制堆栈显示大小比如：如果你有一个大的堆栈，或者你只需要查看堆栈的最上面的部分，该选项就有用。 提示:堆栈窗口不会影响应用程序的执行性能，但它可能会读取大量数据，以便在执行停止时更新显示的信息。 六、Terminal I/O终端 此页面只有在调试模式才由，用于I/O终端的选项配置。 1.Input mode：输入模式终端I/O输入选择：Keyboard：键盘输入 Buffered：Buf模式 Direct：直接输入模式File：文件（内容）作为输入 Text：文本 Binary：二进制 2.Input echoing：输入呼应Log file：日志文件Terminal I/O window：终端窗口 3.Encoding：编码选择SystemUTF-8 4.Show target reset in Terminal I/O window：在终端I/O窗口显示复位目标 七、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程08_IDE选项配置（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B08_IDE%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 前面两篇文章针对的是工程节点各选项的配置，而本文讲述的是关于集成开发环境（IDE）各选项的配置。 本文讲述的内容包含字体、快捷键、语言、编辑、消息等许多与IDE相关的配置。因为属于Tools菜单，我也把它称为“工具配置选项”。也就是菜单Tools -&gt; Options下IDE选项，如下图： 由于IDE选项的配置较多，我将其分为IDE选项配置（一）和IDE选项配置（二）两篇文章来讲述，本文主要讲述前五项内容：Common Fonts普通字体、Key Bindings快捷键配置、Language语言、Editor编辑器、Messages消息。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Common Fonts普通字体2.1 Custom Tool Configuration自定义工具配置 本节内容主要是配置除编辑窗口（如代码）之外的其它窗口的字体设置（如工程窗口、编译窗口等）。 1.Fixed Width Font：固定宽度字体比如：Sysbolic Memory窗口中数据“0xCDCDCDCD”的字体。 2.Proportional Width Font：比例宽度字体比如：Sysbolic Memory窗口中数据“Data”这个标识的字体。 从字面意思翻译有点别扭，请结合下面动画效果理解。 普通字体配置动画效果： 提示：这里的字体不包含编辑器的字体，编辑器相关的字体见下面【5.3Colors and Fonts颜色和字体】说明。 三、Key Bindings快捷键配置 Key Bindings：直译为：键绑定，也就是配置快捷键。 Menu主菜单，下面对应的就是其中的子菜单。关于主菜单和子菜单里面具体内容，建议参看该系列教程：EWSTM8系列教程04_菜单概述（一）EWSTM8系列教程05_菜单概述（二） 具体操作：选择主菜单，再选中子菜单，按住需要配置的快捷键，点击Set或Add添加，点击Clear删除，点击Reset All复位所有快捷键（出厂默认）。具体可参看下面动画效果。 提示：primary：首要快捷键Alias：次要（别名）快捷键所以：点击Set是设置首要快捷键，点击Add是添加次要快捷键。 快捷键配置动画效果： 四、Language语言 这个配置选项比较简单，选择语言，目前EWSTM8只支持英语，像EWARM支持英语和日语。 五、Editor编辑器编辑器选项下面还包含External Editor外部编辑器、Setup Files设置文件、Colors and Fonts颜色和字体三个子选项。 第1区域：Tab1.Tab size：Tab键尺寸假如为2，则一个Tab键尺寸相当于2个空格大小。 2.Indent size：缩进尺寸 3.Tab Key Function：Tab键功能Insert tab：插入Tab符Indent with spaces：缩进为空格符 第2区域：边缘线1.Show right margin：显示右边缘线Printing edge：打印边缘（打印范围）Columns：根据列数显示 一条浅灰色的竖线，默认勾选上并显示（第80列） 第3区域：File Encoding：文件编码1.Default character encoding：默认字符编码有多种类型可选择，默认System（系统）； 2.Auto-detect character encoding：自动检测字符编码勾选上则自动检测文件。 3.EOL characters：结束符可选择：PC、 UNIX、 Preserve。 第4区域：show：显示1.Syntax highlighting：语法高亮显示默认勾选，按照语法规则高亮显示文字。如关键字（if、 while），注释语句，预定于#include等。 2.Auto indent：配置自动缩进 勾选上，则自动缩进。如上图，如果我在“case 0:”按下回车（换行），则在下一行自动缩进到return的r这个位置。（不勾选，则到每行的开始位置） 3.Show line numbers：显示行数（见下图）这个很好理解，就是显示代码、文本前面的行数； 4.Scan for changed files：扫描修改的文件比如：main.c在EWSTM8中打开（未修改），这时又通过其他软件把main.c打开，添加了一行i++代码，并保存。则这时将自动显示添加了一行i++的文件。 如果打开修改过，则会提示（是否更新，并显示那边添加了i++的文件）。 5.Show bookmarks：显示书签（见下图）包含错误、警告、断点、书签等一些标记符号。 6.Show fold margin：显示折叠边缘（见下图） 书签、行数、折叠说明图： 7.Enable virtual space：使能虚拟空间勾选上则光标可以放在编辑窗口任何一个位置编辑（则前面多处许多空格）。 8.Remove trailing blanks：去除末尾的空白当保存文件时（如Ctrl+S），删除每行后面的空格符号。 9.Auto code completion and parameter hints：自动代码完形和参数提示 10.Show source browser tooltips：显示源代码浏览器工具提示 11.Show line break characters：显示换行字符勾选则显示换行符。如下图：默认的换行符CR+LF（一般不建议勾选） 5.1 External Editor外部编辑器 勾选“Use External Editor”，则使用外部编辑器。 1.Type：类型有两种可选类型：Command Line：命令行DDE(Dynamic Data Exchange)：Windows动态数据交换 2.Editor：编辑器指定外部编辑器的文件名和路径。可以通过“浏览按钮”方便操作。 3.Arguments：参数指定要传递给编辑器的任何参数。这只适用于选择命令行类型。 类型为DDE时，对应的配置不同，如下图： 4.Service：服务指定由编辑器使用DDE服务名称，指定由编辑器使用DDE服务名称。 5.Command：命令指定要传递给编辑器的命令字符串序列。 5.2 Setup Files设置文件 1.Use Custom Keyword File：使用自定义关键字文件自定义关键字文件，如添加uint32_t这种自定义的数据类型，在文本中就会高亮显示。 提示：文件类型：txt本文文件一行一个关键字 2.Use Code Templates：使用代码模板使用方法请参考文章《EWSTM8系列教程04_菜单概述（一）》4.1 插入/编辑模板。 5.3 Colors and Fonts颜色和字体 1.Editor Font编辑字体字体和大小 2.语法颜色这里包含关键字、字符串、数字…等的字体颜色和背景颜色配置。 六、Messages消息 1.Enable All Dialogs使能所有对话框类似如下图对话框，如果勾选“Don’t show again”，就禁用该对话框。使用此选项可以重新启用所有被禁止的对话框。 七、说明1.本文大部分内容也适合IAR其它版本，如EWARM、EW430等。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程07_工程节点选项配置（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B07_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 上一篇文章《EWSTM8系列教程06_工程节点选项配置（一）》讲述了节点选项中前五项（Target目标、Static Analysis静态分析、C/C++ Compiler编译器、Assembler汇编器、Output Converter输出转换器）的内容。 本文讲述剩余的几项内容：Custom build自定义、Build Actions执行动作、Linker链接器、Debugger调试器、ST-LINK工具。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Custom build自定义2.1 Custom Tool Configuration自定义工具配置 1.Filename extensions：文件扩展名如：extension.lex 2.Command line：命令行命令格式为：flex $FILE_PATH$ -o$FILE_BNAME$.c 3.Output file：输出文件格式：$FILE_BPATH$.c$FILE_BPATH$.h 4.Additional input files：额外的输入文件比如：$TOOLKIT_DIR$\inc\stdio.h 5.Run this tool before all other tools：在运行其他工具之前运行这个工具 以上5个选项内容其实是协同完成一个功能，比如：使用工具（命令）将一个输入文件，转化并输出。 三、Build Actions执行动作3.1 Build Actions Configuration执行动作配置 1.Pre-build command line：在“Build”之前执行命令行如：在编译之前拷贝一个文件，或者修改一个文件内容等。 2.Post-build command line ：在“Build”之后执行命令行如：在编译完成之后，拷贝hex，或者bin文件，或在bin文件末尾添加校验等。 四、Linker链接器4.1 Config配置 1.Linker configuration file：链接器配置文件根据项目设置自动选择默认链接器配置文件。如果要覆盖默认文件，勾选“Override default”即可。 2.Configuration file symbol definitions：配置文件的符号定义定义要在配置文件中使用的常量配置符号。这种符号的效果与使用链接器配置文件中的define symbol指令定义的符号相同。 4.2 Library库 1.Automatic runtime library selection：自动运行时库选择使链接器根据您的项目设置自动选择适当的库。 2.Include C-SPY debugging support：包括C-SPY调试支持包含用于调试应用程序和调试器本身之间通信的调试库。 3.Buffered write：写缓冲在程序执行期间缓冲终端输出，而不是立即将每个新字符打印到C-SPY终端I/O窗口。当您使用通信缓慢的调试器系统时，此选项非常有用。 4.Additional libraries：附加库指定您希望链接器在链接过程中包含的其他库。每行只能指定一个库，并且必须指定到库的完整路径。可以通过“Browse按钮”来添加（类似新建工程添加路径）。 5.Override default program entry：覆盖默认的程序入口默认情况下，程序条目是__iar_program_start。链接器确保包含了包含程序条目标签的模块，并且不丢弃包含该标签的部分。Entry symbol：输入符号Defined by application：由应用程序定义 4.3 Input输入 1.Keep symbols：保留符号 2.Raw binary image：原始二进制图像链接图像纯二进制文件，指定参数:File：文件Symbol：符号Section：部分区域Align：对齐 4.4 Optimizations优化这里就不贴图了，链接器优化只有一个勾选项： 1.Merge duplicate sections：合并重复的部分使链接器仅保留等效只读部分的一个副本。注意，这可能会导致不同的函数或常量具有相同的地址，因此依赖于不同地址的应用程序不能正确地使用所选的选项。 4.5 Output输出 1.Output filename：输出文件名设置链接器输出文件的名称。默认情况下，链接器将使用带有文件名扩展名的项目名称。 2.Include debug information in output：输出中包含调试信息使链接器生成一个ELF输出文件，包括用于调试信息的DWARF。 4.6 List列表 1.Generate linker map file：生成链接器映射文件 2.Generate log file：生成日志文件Automatic library selection：自动库选择Initialization decisions：初始化决策Module selections：模块选择Redirected symbols：重定向符号Section selections：段选择Unused section fragments：未使用的部分片段 4.7 #define预定义这里不贴图了，预定义一些符号。 例如：TESTVER=1注意：一行一条，“=”两边不能有空格。 4.8 Diagnostics诊断具体内容请参考《EWSTM8系列教程06》中“5.7 Diagnostics 诊断”的内容。 4.9 Checksum校验和 1.Fill unused code memory：填充未使用代码的内存Fill pattern：填充形式Start address：起始地址End address：结束地址 2.Generate checksum：生成校验和Checksum size：校验和尺寸（数据类型），可以是1、2、4字节。Alignment：校验和对齐方式。Algorithm：选择算法类型。Result in full size：结果为全尺寸Complement：补充Bit order：位顺序Reverse byte order within word：字节顺序颠倒Checksum unit size：校验和单元尺寸（8、16、32Bit） 4.10 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行对链接器相关选项进行配置。具体命令后续抽空单独整理成相关文章。 五、Debugger调试器本章节主要讲述与调试下载相关的一些选项配置。 5.1 Setup设置 1.Driver：驱动器选择调试仿真驱动器（工具） 2.Run to：运行到复位之后运行到指定位置 3.Setup macros：设置宏Use macro file：使用宏文件 4.Device description file：设备描述文件根据项目设置自动选择默认设备描述文件。要覆盖默认文件，勾选“Override default”并指定一个替代文件。 5.2 Images镜像 可以使用三组Download extra Images：下载外部镜像文件Path：路径Offset：偏移地址Debug info only：是否只调试 5.3 Extra Options额外选项配置这里不讲述，后续专门整理一篇命令行相关文章。 5.4 Plugins插件 1.Select plugins to load：选择要加载的插件2.Description：插件描述3.Location：插件位置4.Originator：插件来源5.Version：插件版本 六、ST-LINK工具其它两个工具simulator和STice就不讲述了，讲一下常用的ST-LINK。 6.1 setup设置 1.Download：下载默认情况下，当进入调试时，下载应用程序到RAM或flash中。下载选项允许您修改下载的行为。 Suppress：抑制禁止下载代码，同时保留flash的当前内容。如果您想调试已经下载在目标内存中的应用程序，这个命令非常有用。 Erase：擦除在下载代码之前删除内存(FLASH、EEPROM和选项字节)。 EraseVerify：擦除验证验证下载代码的地址是否被擦除。 Use option bytes configuration file：使用选项字节配置文件在下载前将在选项字节配置文件(obc)中定义的选项字节设置写入设备。 2.Communication options：通信选项配置Use SWIM interface：使用SWIM接口Communication log：通信日志 七、说明1.因IAR各种IDE针对的处理器差异较大，所以关于节点选项的配置差异也较大。本文讲述关于EWSTM8的许多节点选项可能在其他IDE中没有。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程06_工程节点选项配置（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B06_%E5%B7%A5%E7%A8%8B%E8%8A%82%E7%82%B9%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 Options for node即节点选项，而node节点位于Project工程的下一级。本文讲述的工程节点选项配置，即菜单Project -&gt; Options下Options for node节点选项中的前五项配置，如下图： 由于节点选项较多，我将其分为工程节点选项配置（一）和工程节点选项配置（二）两篇文章来讲述。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、拓展内容 本文讲述的工程节点选项配置，其中的工程与节点是包含关系，而工作空间与工程也是包含关系。 2.1 工作空间、 工程、 节点三者的关系三者之间就是包含关系：工作空间 &gt; 工程 &gt; 节点。一个工作空间可以包含多个工程，一个工程可以包含多个节点，见下图： 请关注系列教程新建多工程，多节点的文章。 2.2 打开节点选项配置的三种方法1.选中节点 -&gt; 快捷键Alt + F7这种方法简单、快捷，推荐使用。 2.选中节点 -&gt; 右键 -&gt; Options 3.选中节点 -&gt; 菜单Project -&gt; Options 三、General Options普通选项3.1 Target目标 1.Device：器件即选择MCU芯片型号，如上图选择的是STM8S103F3P. 2.Code model：代码模式包含三种：小、中、大；Small：小Medium：中Large：大对于初学者，可以理解为：如果选择Large大的话，编译出来的Code代码就会更大。具体的差异可以查看生产的.map文件。 3.Date model：数据模式原理类似上面代码模式，同样有三种：Small：小Medium：中Large：大 3.2 utput输出 1.Output file：输出文件输出文件类型有两种，但只能二选一。A.Executable：生成可执行的文件。如Hex、Bin等；B.Library：生成库文件。 2.Output directories：输出目录（路径）编译过程中生成的文件分别存放的目录（路径）。默认在Debug文件夹下面就会发现三个文件夹：Exe、Obj、List。A.Executables/Libraies：生成可执行/库文件的路径B.Object files：生成目标文件的路径C.List files：生成列表文件的路径 提示：路径为相对工程文件（如Demo.ewp）的路径。 3.3 Library Configuration库配置 1.Library：选择运行时库运行时库有四种可选择：None：无Normal：选择常规配置的运行时库Full：选择完整配置的运行时库Custom：选择定制运行时库 2.Description：运行时库的描述 3.Configuration：运行时库的配置 提示：第2、3点是随第1点选择的库改变而改变，第3点配置只有在选择“定制运行时库”时才可修改。请参看下图动画效果： 选择运行时库动画效果： 3.4 Library Options库选项 1.Printf formatter：选择Printf（打印输出）格式器总共有8种类型：Auto：自动格式Full：完整格式Full without multibytes：完整无多字节格式Large：大格式（不区分a或A）Large without multibytes：大格式（不区分a或A）,无多字节格式Small：小格式（不区分a或A，无Float）Smallwithout multibytes：小格式（不区分a或A，无Float）,无多字节格式Tiny：微小格式； 2.Scanf formatter：选择Scanf（打印输入）格式器类似上面printf，总共有7种类型：Auto：自动格式Full：完整格式Full without multibytes：完整无多字节格式Large：大格式Large without multibytes：大格式,无多字节格式Small：小格式Smallwithout multibytes：小格式,无多字节格式 3.Math functions：数学函数有两种可选择类型：Default：默认。包含cos, sin, tan, log, log10等函数；Smaller：精简。函数体积小，执行速度快，精度低，输入范围小等。 3.5 Stack/Heap栈和堆 1.Stack size：栈大小。 2.Heap size：堆大小。 提示：堆和栈位于内存中两块不同区域，使用的大小根据实际情况而定，修改此值之前请认真了解堆栈的含义。 3.6 MISRA C标准 MISRA-C:1998和MISRA-C:2004年的选项控制IDE如何检查源代码与MISRA C规则的偏差，这些设置用于编译器和链接器。 General Options普通与C/C++ Compiler编译器中的MISRA C选项配置相关联，本文章不讲述，后续单独讲述关于MISRA C的内容。 四、Static Analysis静态分析4.1 C-STAT静态分析 1.Select C-STAT Checks：选择C静态检查项目里面可选择的项目较多，通过手动选择（使能/失能）相关选项，使用前需了解C-STAT相关知识。 2.Import Settings：导入设置导入静态检查配置文件（类型为.xml文件）。 3.Export Settings：导出设置导出（当前第1点中）静态检查配置文件。 4.Enable parallel analysis：使能并行分析后面参数为并行分析（进程）数。 5.Enable module timeout：使能模块超时值后面参数为单个模块超时时间（单位：秒） 6.Enable false-positives analysis：使能“误报”分析 7.Limit messages per check and file：限制每次检查文件的消息数 提示：静态分析各项参数配置好之后，在菜单Project -&gt; C-STAT Static Analysis中执行。 4.2 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行进行静态检查相关的配置，具体命令后续抽空单独整理成相关文章。 五、C/C++ Compiler编译器5.1 Language语言1 1.Language：选择语言三选一，选择C语言，就不能C++相关特性。选择Auto自动，会根据文件后缀自动判别。 2.Language conformance：语言一致性控制编译器如何严格遵守标准C或c++语言。Standard with IAR extensions：接受IAR（STM8）特定的关键字作为标准C或c++语言的扩展。Standard：禁用IAR系统扩展，但不严格遵循C/C++语言。Strict：严格遵守C/C++语言。 3.C dialect：选择C标准C 89 C 99 Allow VLA：运行可变长度数组； C++ inline semantics：支持内联函数； Require prototypes：需要原型强制编译器验证所有函数都有合适的原型。 4.C++ dialect：选择C++标准Embedded C++：嵌入C++Extended Embedded C++：扩展嵌入C++Destroy static objects：清除静态对象 5.2 Language语言2 1.Plain ‘char’解析为Signed或者Unsigned. 2.Floating-point semantics：浮点语句Strict conformance：严格一致，使编译器严格遵守浮点表达式的C和浮点标准。Relaxed：放松，使编译器放松语言规则并对浮点表达式执行更积极的优化。 3.Enable multibyte support：启用多字节的支持默认情况下不支持多字节，启用多字节支持使编译器可以根据主机的默认设置多字节支持来解释源代码中的多字节字符。 5.3 Optimizations优化 1.Level：优化等级None：无Low：低Medium：中High：高选择High优化等级为高时，可以选择Balanced平衡、Size大小、Speed速度（速度时可选择不收大小限制）,请参看下图动画效果。 2.Enabled transformations：使能转换选择不同的优化等级，对应优化转换不同，也可自定义转换项目。 3.Number of virtual byte registers：虚拟寄存器的字节数 优化选项动画效果： 5.4 Output编译输出 1.Generate debug information：生成（输出）调试信息如果需要调试，此选项需勾选。 5.5 List列表 1.Output list file：输出列表文件Assembler mnemonics：输出汇编助记符Diagnostics：输出诊断信息 2.Output assembler file：输出汇编文件Include source：包含源文件Include call frame information：包含调用信息 5.6 Preprocessor预处理 1.Ignore standard include directories：忽略标准包含目录（路径） 2.Additional include directories：添加路径最好是相对工程目录的相对路径。 3.Preinclude file：预包含文件 4.Defined symbols：预定义类似代码中#define，这里截图预定义STM8S103，相当于定义在stm8s.h文件中。 5.Preprocessor output to file：预处理输出到文件 5.7 Diagnostics诊断Diagnostics诊断选项卡，用于规定诊断信息的分类和显示。编译过程中可能产生三种错误诊断信息：remark(注意)、waining(警告)和error(错误)。 1.remark是一种次要的诊断信息，表明按源程序结构生成的代码可能出现不正常。 2.warning表示源程序中存在错误，但编译过程不会停止。 3.error表示源程序中存在违反C/C++语言规则的现象，将导致无法生成目标代码。error信息不能被禁止，也不能重新分类。 1.Enable remarks：使能注意信息勾选则允许编译器产生remark注意诊断信息。 2.Suppress these diagnostics：禁止显示这些（指定）诊断信息比如：我们希望禁止显示（输出）Pa091和Pe001这两类信息，可以在此写入【Pa091, Pe001】。 3.Treat these as remarks：将这些（指定）信息作为注意信息显示比如：我们希望将Pe177这类警告信息作为注意信息显示，只需要在此输入Pe177即可。 4.Treat these as warnings：将这些（指定）信息作为警告信息显示与上面第3点同理。 5.Treat these as errors：将这些（指定）信息作为错误信息显示与上面第3点同理。 6.Treat all warnings as errors：将所有警告作为错误处理（并显示） 5.8 MISRA C标准 MISRA-C:1998和MISRA-C:2004年的选项用于编译器和链接器。General Options普通选项与C/C++ Compiler编译器中的MISRA C选项配置相关联，本文章不讲述，后续单独讲述关于MISRA C的内容。 5.9 Extra Options额外选项配置这里就不贴图了，主要就是使用命令行对编译相关选项进行配置。具体命令后续抽空单独整理成相关文章。 六、Assembler汇编器这一章节内容和上面C/C++编译器原理类似，只是这里是针对汇编。 6.1 Language语言 1.User symbols are case sensitive：用户符号区分大小写 2.Enable multibyte support：使能多字节的支持 3.Allow mnemonics in first column：允许在第一列中使用助记符 4.Allow directives in first column：允许在第一列中使用指令 5.Macro quote characters：宏引用字符选择有四种字符可选择：A.()B.[]C.{}D.&lt;&gt; 6.2 Output编译输出这里就不贴图了，和上面一章节C/C++的Output一样，Generate debug information：生成（输出）调试信息，如果需要调试汇编，此选项需勾选。 6.3 List列表 1.Output list file：输出列表文件A.Do not include diagnostics：不包括诊断B.Include cross-reference：包括交叉引用C.List macro definitions：宏定义列表D.Disable macro expansion：禁用宏扩展E.List only assembled parts：只列出部分列表（除假条件汇编）F.Truncate multiline data field：截断多行数据字段 6.4 Preprocessor预处理 1.Ignore standard include directories：忽略标准包含目录（路径） 2.Additional include directories：添加路径 3.Preinclude file：预包含文件 4.Defined symbols：预定义 5.Preprocessor output to file：预处理输出到文件 提示：这里选项和上面C/C++中预处理类似，只是这里针对的是汇编。 6.5 Diagnostics诊断这里就不贴图了，本节Diagnostics诊断几乎与上一章节中Diagnostics诊断一样，只是这里针对的是汇编，详情请参看上一章节C/C++的Diagnostics诊断描述。 6.6 Extra Options额外选项配置这里就不贴图了，本节Extra Options额外选项配置同样与上一章节一样。 七、Output Converter输出转换器7.1 Output输出 1.Generate additional output：使能生成额外的输出（文件） 2.Output format：输出格式A.MotorolaB.Intel-extendedC.BinaryD.Simple 3.Output file：输出文件Override default：默认覆盖 八、说明1.因IAR各种IDE针对的处理器差异较大，所以关于节点选项的配置差异也较大。本文讲述关于EWSTM8的许多节点选项可能在其他IDE中没有。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 九、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程05_菜单概述（二）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B05_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 在上一篇【EWSTM8系列教程04_菜单概述（一）】文章中概述了File文件、Edit编辑、View视图、Project工程前面四个重要菜单的内容。 本文讲述Debug调试、ST-Link下载调试工具、Tools工具、Window窗口、Help帮助后面五个菜单的内容。 其中“Debug调试”菜单是在调试模式时才有（编辑模式下没有）。“下载调试工具”是由你工程目标配置所决定的（上面截图是配置ST-Link）。 本文主要概述后五个菜单的内容： 1.Debug调试菜单 2.下载调试工具菜单 3.Tools工具菜单 4.Window窗口菜单 5.Help帮助菜单 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、Debug调试菜单 Debug调试菜单只有在调试模式下才会显示出来，里面大部分常用子菜单会显示在【调试工具栏】，可以参看【EWSTM8系列教程03_主窗口、工具栏的概述】文章中“3.2调试工具栏”的章节。 1.Go：全速运行 F52.Break：停止运行3.Reset：复位4.Stop Debugging：结束调试 Ctrl + Shift + D5.Step Over：逐行运行 F106.Step Into：跳入运行 F117.Step Out：跳出运行 Shift + F118.Next Statement：运行到下一语句9.Run to Cursor：运行到光标行10.AutoSetp：自动按步骤运行11.Set Next Statement：设置下一条语句12.C++ Exceptions：C++异常13.Memory：内存保存/复位14.Refresh：调试更新15.Logging：调试日志 Debug菜单前面10个子菜单比较常用，也比较重要。这里再文字解释其中几个子菜单的含义，教程后面针对性详细讲述其中子菜单内容。 Step Over、Step Into、Step Out这三个子菜单都具有“逐步/单步”调试的意思。Step Into遇到函数会进入函数执行，而Step Over则不会进入函数。Step Out是跳出当前函数。 Run to Cursor运行到光标行：在暂定状态，将光标放在程序某一行，执行该操作程序运行到你所在行则会停下来（当然，如果那一行程序永远都执行不到，则程序一直执行，直到你执行其他操作）。 AutoSetp自动按步骤运行：可以设置按照指定方式（Step Over、Step Into）、 间隔时间自动运行。 三、下载调试工具菜单 这个菜单的内容会随你工程配置的下载调试器改变而改变，而不同下载调试器的子菜单内容也不一样，如下图： 可以看见我上面截图中两种类型（ST-Link和Simulator）菜单中的子菜单内容不一样。 这个菜单里面的内容使用频率相对较低，而目前来说主要是选择ST-Link来下载调试。下面概述一下ST-Link下各子菜单内容。 1.Leave Target Runing：离线运行（离开目标运行）2.Disable Interrupts When Stepping：当单步调试时禁止中断3.Option bytes：选项字4.Data Sample Setup：数据采样设置5.Data Sample：数据样本6.Sampled Graphs：采样图7.Breakpoint Usage：使用断点 四、Tools工具菜单Tools工具菜单包含了IDE相关的一些配置，包括字体、快捷键、语言、编辑、消息、工程等一系列配置。 1.Options：工具配置选项2.Filename Extension：文件扩展名3.Configure Viewers：配置预览4.Configure Custom Argument Variables：配置自定义参数变量5.Configure Tools：配置工具 4.1 Options工具配置选项Options工具配置选项是比较重要的一个子菜单，里面包含了我们字体大小、颜色、快捷键、工程输出信息等一系列比较重要且实用的内容。本文重点在于概述菜单内容，该系列教程后面会详细讲述里面具体内容。 五、Window窗口菜单Window窗口菜单需要和View视图菜单具有相似的地方（像打开/关闭工具栏，IAR之前版本就是在View视图菜单操作），但需要区分开来。 Window窗口菜单为操作IDE窗口和改变它们在屏幕上排列的一个菜单。 1.Close Document：关闭当前活动的文档编辑窗口 Ctrl + F42.Close Window：关闭当前活动的IDE窗口（工程、参考、浏览等窗口）3.Split：拆分窗口4.Move Tab to New Vertical Editor Window：移动选项卡到新的垂直编辑器窗口5.Move Tab to New Horizontal Editor Window：将选项卡移动到新的水平编辑器窗口6.Move Tab to the Next Window：将选项卡移到下/后一个窗口7.Move Tab to the Previous Window：将选项卡移动到上/前一个窗口8.Close All Tabs Except Active：关闭除活动以外的所有选项卡9.Close All Tabs to the Right of Active：关闭活动右边的所有选项卡10.Close All Editor Tabs：关闭所有选项卡编辑11.Toolbars：工具栏12.Status bar：状态栏 5.1 拆分窗口Split拆分窗口就是将一个窗口拆分为上下左右四个窗口，各个窗口大小可自由分配，如下图： 5.2 移动选项卡到Move Tab to New Vertical Editor Window和Move Tab to New Horizontal Editor Window类似，一个是垂直，一个是水平，下图为垂直效果： 5.3 工具栏、状态栏这两个子菜单的内容之前IAR版本是放在View视图菜单下面，它俩的功能类似视图菜单的功能，打开/关闭的功能。 注意：工具栏菜单在编辑模式下只有Main主工具栏，在调试模式下会增加Debug调试工具栏，如下图： 六、Help帮助菜单这个菜单里面内容比较实用哦，从字面意思理解“帮助”，我写的大部分内容都是参考这里面的，其实重要的就是帮助文档。 6.1 帮助文章Content内容、Index索引、Search搜索是对应帮助文档里面的内容，如下如： 6.2 Guide指导手册如上图子菜单中，红色框住的那一部分都属于IDE的指导手册，包含版本历史信息、管理、参考信息等。 6.3 其它IAR on the Web：IAR网站Information Center：信息中心Lincense Manager：许可证管理，注册的时候就是这里进入About：关于软件的版本信息 七、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩内容我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程04_菜单概述（一）]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_%E8%8F%9C%E5%8D%95%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、写在前面 IAR软件针对不同处理器存在多个版本，比如EWARM、EWMSP430、EWSTM8等，但为了让软件在使用上“兼容”，IAR推出的多个版本软件在使用上很多地方都有相似之处。因此，本文针对EWSTM8讲述的大部分内容也适用于IAR其他系列软件。 由于菜单内容较多，我将其分为“菜单概述（一）”和“菜单概述（二）”两篇文章来讲述。为了使文章内容精简，下面大部分菜单内容只简单概述，该系列教程后面文章会逐步深入每一个细节的功能。 本文主要概述前四个菜单的内容： 1.File文件菜单 2.Edit编辑菜单 3.View视图菜单 4.Projcet工程菜单 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、主菜单内容 主菜单在不同状态下会有一些差异，比如在编辑模式和调试模式下存在差异，不同调试下载工具也存在差异。 2.1 编辑/调试模式差异在编辑模式下有8个主菜单，在调试模式下会增加Debug调试菜单，共有9个主菜单。 2.2 不同调试下载工具差异上面主菜单中有一个ST-Link菜单选项，其实这个菜单是根据你工程配置选择的调试下载工具改变而改变的。 如在仿真、J-Link、ST-Link下的区别： 三、File文件菜单File文件菜单是比较常见的菜单，主要包含对文件的新建、打开、关闭、打印等一些常见的操作，在编辑和调试模式下完全一样。 1.New File：新建文件 Ctrl + N2.New Workspace：新建工作空间3.Open File：打开文件/工作空间 Ctrl + O4.Open Workspace：打开工作空间5.Open Header/Source File：打开头文件或源文件6.Close：关闭文件7.Save Workspace：保存工作空间8.Save Workspace As：另存工作空间9.Close Workspace：关闭工作空间10.Save：保存文件 Ctrl + S11.Save As：另存文件12.Save All：保存所有文件/工作空间13.Page Setup：打印页面设置14.Print：打印 Ctrl + P15.Recent Files：最近打开文件16.Recent Workspaces：最近打开工作空间17.Exit：退出软件 四、Edit编辑菜单 这个Edit菜单在编辑和调试模式下相同，在编辑的时候使用较多，也比较常用。 这个菜单下面大部分内容和默认主工具栏按钮一样，可以参看我的另一篇文章：EWSTM8系列教程03_主窗口、工具栏的概述. 1.Undo：撤销编辑 Ctrl + Z2.Redo：恢复编辑 Ctrl + Y3.Cut：剪切 Ctrl + X4.Copy：复制 Ctrl + C5.Paste：粘贴 Ctrl + V6.Select All：全选 Ctrl + A7.Find and Replace&gt;Find：查找 Ctrl + F Find and Replace&gt;Find Next：查找下一目标 F3 Find and Replace&gt;Find Previous：查找上一目标 Shift + F3 Find and Replace&gt;Find Next (Selected) ：在选中对象里查找下一目标 Ctrl + F3 Find and Replace&gt;Find Previous (Selected)：在选中对象里查找上一目标 Ctrl + Shift + F3 Find and Replace&gt;Replace：替换 Ctrl + H Find and Replace&gt;Find in Files：在对话框中指定条件查找 Find and Replace&gt;Replace in Files：在对话框中指定条件替换 Find and Replace&gt;Incremental Search：在对话框中查找字符 Ctrl + I8.Navigate&gt;Go To：前往行列 Ctrl + G Navigate&gt;Toggle Bookmark：标记/取消书签 Ctrl + F2 Navigate&gt;Previous Bookmark：跳转到上一个书签 Shift + F2 Navigate&gt;Next Bookmark：跳转到下一个书签 F2 Navigate&gt;Navigate Backward：跳转到上一步 Alt + 左箭头 Navigate&gt;Navigate Forward：跳转到下一步 Alt + 右箭头 Navigate&gt;Go to Definition：跳转到定义 F129.Code Templates&gt;Insert Template：插入模板 Ctrl + Alt + V Code Templates&gt;Edit Templates：编辑模板10.Next Error/Tag：显示下一错误/目标 F411.Previous Error/Tag：显示上一错误/目标 Shift + F412.Complete Word：完型语句 Ctrl + Alt + 空格13.Complete Code：完型类/结构体代码 Ctrl + 空格14.Parameter Hint：参数提示 Ctrl + Shift + 空格15.Match Brackets：括号匹配16.Toggle All Folds：折叠/打开当面编辑代码 Ctrl + Alt + F17.Auto Indent：自动缩进（对齐） Ctrl + T18.Block Comment：块注释 Ctrl + K19.Block Uncomment：块取消注释 Ctrl + Shift + K20.Toggle Breakpoint：添加/取消断点 F921.Enable/Disable Breakpoint：使能/失能断点 Ctrl + F9 上面是简述每一个子菜单的内容（有一部分子菜单和工具栏按钮一样，这里不再详细讲述，可以点击文章链接查看）。下面将详细讲述几个常用、重要的Edit子菜单菜单。 4.1 插入/编辑模板如果你经常使用同样一段代码，就可以使用这个功能。 IAR默认只有if、for这两个模板，我们可以自己添加（编辑）模板，比如添加一个while模板，点击“编辑模板”菜单就可以进入编辑状态，编辑的语法很简单，可以参考自带模板。添加内容如下：1234#TEMPLATE "&amp;Statement&gt;&amp;while"while(1)&#123;&#125; 插入/编辑模板动画效果： 4.2 完形语句完形填空就是词组补全，类似上小学时词语完形填空。比如完整的代码为LED_Initializes（前提是具有这个词组），而实际只需要输入LED_字母就可以补全。 完形填空动画效果： 4.3 自动缩进这个功能比较实用，在你代码比较凌乱（也就是不对齐的情况），使用该功能就可使代码自动对齐。自动缩进是空格（空几格）还是Tab需要在Tools-&gt;Options中配置，后面详细讲述。 自动缩进动画效果： 五、View视图菜单 View这个菜单的意思就是打开（已关闭的）视图窗口，比如我们的工作空间窗口不见了，就可以通过该菜单打开。 由于在调试模式下增加了一些视图窗口，所以在编辑模式和调试模式下存在一些差异。 本节内容简单，参看下面动画效果就很容易理解。但有些视图窗口功能有点相似，可能初学者理解起来比较困难，下面列出视图菜单的内容，接着会讲述一些相似子菜单的区别。 1.Messages&gt;Build：编译信息 Messages&gt;Find in Files：查找信息 Messages&gt;Tool Output：工具信息 Messages&gt;Debug Log：调试信息2.Workspace：工作空间窗口3.Source Browser&gt;Source Browser：浏览源码窗口 Source Browser&gt;References：引用窗口 Source Browser&gt;Declarations：声明窗口 Source Browser&gt;Call Graph：调用图窗口4.C-STAT Message：静态分析窗口5.Breakpoints：调试断点窗口6.Call Stack：调用栈窗口7.Watch：普通查看表达式/变量值窗口8.Live Watch：查看实时表达式/变量值窗口9.Quick Watch：快速查看表达式/变量值窗口10.Auto：自动显示表达式/变量窗口11.Locals：局部变量窗口12.Statics：静态变量窗口13.Memory：内存窗口14.Registers：寄存器窗口15.Disassembly：反汇编窗口16.Stack：堆栈地址窗口17.Symbolic Memory：内存标记窗口18.Terminal I/O：终端窗口19.Macros：宏指令窗口20.Symbols：符号表窗口21.Code Coverage：代码覆盖（利用）率窗口22.Images：图片窗口23.Cores：内核状态窗口 View视图菜单可以打开被关闭了的窗口，打开的窗口也可以随意拖动（后面新增的功能）：上、下、左、右、浮动等。 打开视图窗口并拖动动画效果： 细心的朋友其实会发现，View视图子菜单是进行了分类的（用横线隔开），而分类里面的内容具有相似的地方。下面我将详细讲述一下Watch和Memory这两类。 5.1 Watch类窗口 View视图菜单中Watch、 Live Watch、 Quick Watch、 Auto、 Locals、 Statics这6个子菜单功能其实类似，但各有差异。 6个视图子菜单窗口的显示内容都类似，总共四个属性： Expression：表达式名称，一般指变量和函数等。Value：对应的值；Location：对应所在位置，寄存器、RAM、Flash等。Type：变量/函数类型。 这里可以将6个子菜单再次细分，前面3个菜单分为一类：Watch查看窗口；后面3个菜单分为一类：Atuo自动窗口。 1.Watch普通查看表达式/变量值窗口Watch菜单下面有4个子菜单：Watch1 ~4，但都是一样的，可以分别开4个窗口出来同时查看表达式/变量值。一般这个窗口我们比较常用，添加自己想要查看的变量值。A.通过手动添加需要查看的表达式/变量；B.只有暂停调试才会更新对应的值； 2.Live Watch查看实时表达式/变量值窗口与上面Watch窗口类似，差别在于：A.变量须为静态（全局）;B.变量实时更新（程序在运行时）; 3.Quick Watch快速查看表达式/变量值窗口快速浏览变量窗口主要结合另外一个视图菜单Macro Quicklaunch一起使用，达到精确地控制变量值。 4.Auto：自动显示表达式/变量窗口当程序暂停在某一个地方，自动显示暂停坐在位置的表达式/变量，而不需要像Watch要手动添加。 5.Locals：局部变量窗口这个子菜单和Atuo类似，也是自动显示，区别在于：Locals是显示的局部表达式变量，而静态/全局变量不会显示。 6.Statics：静态变量窗口该子菜单同样具有Atuo的特性，自动显示。但是，它显示的内容是静态变量（静态局部、静态全局、全局变量）。 5.2 Memory类窗口这一类窗口主要是显示内存（ROM、 RAM、 Flash、 外设等）地址的值，同时还包含堆栈、反汇编等与内存相关的内容。 1.Memory内存Memory菜单下面有4个子菜单，包含Memory1~4。都一样，可同时打开4个。严格来说翻译成内存是不正确的，里面的内容其实不是我们常说的内存。见下图： 2.Register寄存器窗口这里不用多说，就是内核里面寄存器，如：SP、 PC等寄存器。 注意：我们常说的外设寄存器不在这里，外设寄存器是有地址的，可以在Memory中查看。 3.Disassembly反汇编反汇编窗口显示了通过C语言汇编出来的具体代码。对分析每一条汇编语言的人有帮助，但相信很小有人仔细研究汇编语言了。 4.Symbolic Memory这个有点不好翻译，简单来说：内存上面有数据，那么就会标记相应的表达式，及对应的数值，而没有数据的则不标记。 还有，被标记的内容就是Menmory中那些，见下图： 六、Projcet工程菜单 工程菜单在实际使用中比较常用，而且内容相对较多，部分内容也相对较复杂。本章节只概述子菜单主要内容，该系列教程后面还会有多篇文章专门讲述里面详细内容。 Project菜单下的子菜单内容在编辑模式和调试模式下一样，但呈现的状态有差异（有的在编辑模式下不可用，有的在调试模式下不可用）。 1.Add Files：添加文件2.Add Group：添加组3.Import File List：导入文件列表4.Add Project Connection：添加工程链接5.Edit Configurations：编辑配置6.Remove：移除工作空间工程7.Create New Project：创建新项目8.Add Existing Project：添加已存在工程9.Options：目标选项配置 Alt + F710.Version Control System：版本控制系统11.Make：编译工程 F712.Compile：编译文件/组 Ctrl + F713.Rebuild All：重新编译14.Clean：清除编译等中间文件15.Batch Build：构建批处理 F816.C-STAT Static Analysis：静态分析17.Stop Build：停止编译 Ctrl + Break18.Download and Debug：下载并调试 Ctrl + D19.Debug without Downloading：调试（不下载）20.Attach to Running Target：附加运行目标21.Make &amp; Restart Debugger：编译并重新调试 Ctrl + R22.Restart Debugger：重新调试 Ctrl + Shift + R23.Download：下载24.SFR Setup：SFR设置25.Open Device Description File：打开设备描述文件26.Save List of Registers：保存寄存器列表 七、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 八、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程03_主窗口、工具栏的概述]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_%E4%B8%BB%E7%AA%97%E5%8F%A3%E3%80%81%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%9A%84%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[一、写在前面 为了让初学者更容易掌握IAR这个工具的相关知识，我先从整体概述，再到具体的细节内容。 本文先概述一下默认主窗口界面， 对 IAR 集成开发环境有一个大概的了解，再次概述其中一个常用的 Toolbar 工具栏。 本文主要概述如下两部分内容： 1.主窗口（Main Window） 2.工具栏（Toolbar） 主工具栏概述 调试工具栏概述 工具栏选项配置 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、主窗口 为了让大家对 IAR 集成开发环境有一个大概的了解，这里先概述一下（IAR 默认编辑状态） 主界面下各个窗口的含义。 说明：IAR的窗口在编辑模式与调试模式下存在一定差异，本章节主要基于【编辑模式】进行简单的概述，里面详细的内容、以及调试模式下的窗口在该系列教材后续会逐步讲述。 打开IAR工程，一般会出现类似下图的主窗口界面，主要包含6个窗口（如下图）。 Menu Bar：菜单栏相信大家对该窗口都不陌生，但凡一个常规一点的软件，都有诸如File文件、 Edit编辑 、 View视图、Help帮助等这样的一栏窗口，这就是菜单栏窗口。该窗口是 IAR 比较重要的一个窗口，包含IAR 几乎所有操作的内容，在编辑模式和调试模式下存在一些不同，后续会讲述。 Tool Bar：工具栏该窗口是一些常见的快捷按钮，本文下面会讲述。 Workspace Window：工作空间窗口一个工作空间可以包含多个工程，该窗口主要显示工作空间下面工程项目的内容（工程、 组、 源代码文件等）。 如上图窗口中包含多个工程（Project1、 Project2······），可以关注后面讲述新建多个工程的文章。 Edit Window：编辑窗口该窗口不用多解释，就是我们平时编辑代码的窗口。 Message Window：信息窗口该窗口包括编译信息、调试信息、查找信息等一些信息的窗口。 Status Bar：状态栏该窗口包含就绪状态、错误警告数量、光标行列、字符编码、键盘Num锁定等一些状态信息。 三、工具栏 IAR的工具栏Tool Bar共有两种：Main主工具栏和Debug调试工具栏。在编辑（默认）状态下只显示Main主工具栏，在进入调试模式后会增加显示Debug工具栏，如下图： 3.1 主工具栏 在编辑（默认）状态下，只有主工具栏，这个工具栏里面内容也是在编辑状态下常用的快捷按钮。当然，这些按钮的功能基本上都可以通过快捷键来实现。 New Document新建文件 Ctrl + NOpen打开文件 Ctrl + OSave保存文件 Ctrl + SSave All保存所有文件Print打印文件 Ctrl + PCut剪切 Ctrl + XCopy复制 Ctrl + CPaste粘贴 Ctrl + VUndo撤销编辑 Ctrl + ZRedo恢复编辑 Ctrl + YQuick Search Text Box快速搜索文本框Find Previous向前查找 Shift + F3Find Next向后查找 F3Find查找（增强） Ctrl + FReplace替换 Ctrl + HGo to前往行列 Ctrl + GToggle Bookmark标记/取消书签 Ctrl + F2Previous Bookmark跳转到上一个书签 Shift + F2Next Bookmark跳转到下一个书签 F2Navigate Backward跳转到上一步 Alt + 左箭头Navigate Forward跳转到下一步 Alt + 右箭头Compile编译当前（文件、组） Ctrl + F7Make编译工程（构建） F7Stop Build停止编译 Ctrl + BreakToggle Breakpoint编辑/取消断点 Ctrl + F9Download and Debug下载并调试 Ctrl + DDebug without Downloading调试（不下载）Toolbar Options工具栏选项（下面3.3节重点讲述） 上面只是简述了各个快捷按钮的基本意思，下面再详细说一下部分常用按钮的具体意思。 A.书签书签在编译的时候比较实用，可以快速找到标记书签所在行。可以使用快捷按钮，当然，平时推荐使用快捷键（F2、 Ctrl + F2、 Shift + F2）。 书签动画效果： B.跳转到上/下一步跳转是在编译代码通过跟踪代码留下的“脚步”，我们可以通过该方式找到这些“脚步”，同样也可以通过快捷键操作。 跳转到上/下一步动画效果： C.下载和调试很多人问“Download and Debug”和“Debug without Downloading”这两个按钮的区别是什么？答：Download and Debug：是下载代码之后再进行调试。Debug without Downloading：只调试不下载。也就是说你之前下载过了代码，只需要再点击该按钮即可，否则会出现错误。 这两个按钮图标在编辑和调试模式下略有点差异，在调试模式下可以再次下载/调试。 3.2 调试工具栏调试工具栏只有在调试状态下才会出现的一行快捷按钮，在编辑状态下，没有这些按钮。 当点击调试按钮，进入调试状态之后，菜单栏会增加一个Debug菜单（里面内容和调试工具栏类似）。同样，工具栏也会增加一个调试工具栏，如下图： 从左往右依次是：Step Over逐行运行 F10Step Into跳入运行 F11Step Out跳出运行 Shift + F11Next Statement运行到下一条语句Run to Cursor运行到光标行Go全速运行 F5Break停止运行Reset复位 逐行运行也叫逐步运行，跳入运行也叫单步运行，运行到下一语句和逐行运行类似。 3.3 工具栏选项配置这一小节主要教大家如何自定义工具栏（图标）按钮。假如我们不想要工具栏中有些按钮（如：复制、粘贴），或我们又想添加一个工具按钮，怎么实现呢？ A.进入自定义工具栏 B.删除工具栏如删除复制按钮：按住复制按钮 -&gt; 拖出工具栏即可。 删除按钮动画效果： C.添加工具按钮如：添加一个工具配置按钮，在命令中找到【工具配置】按钮，按住 -&gt; 拖到工具栏（你想要到位置）即可。 添加按钮动画效果： D.添加显示文本标签显示文本标签，也就是图标下面显示该图标按钮的意思，这样方便一眼明白含义，同时可以增大显示距离，点击操作也比较方便。当然，也会占用一定显示区域。如下图： 显示文本标签动画效果： F.放大图标这个很好理解，图标太小，将其放大，如下图： 放大图标动画效果： 四、说明1.上面内容只是概述，相对都比较粗略，更详细的内容，请参看该系列教程后续文章。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 五、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程02_新建基础软件工程]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B02_%E6%96%B0%E5%BB%BA%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、写在前面 我们常说的IAR for STM8，其实指的就是EWSTM8，它的全称是IAR Embedded Workbench for STM8。 本文针对初学者，利用EWSTM8集成开发环境，基于STM8S标准外设库新建基础软件工程。（后面会讲述如何新建多工程、多目标） 本文分如下内容来讲述： 1.准备工作 下载安装EWSTM8 下载STM8标准外设库 整理工程文件夹 2.新建软件工程 创建工程 添加文件 配置工程 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、准备工作 俗话说“磨刀不误砍柴工”，做好了准备工作，后面新建基础软件工程的工作就很容易实现了。 2.1 下载安装EWSTM8 详情请参看该系列教程上一篇文章【EWSTM8系列教程01_IAR介绍、下载、安装和注册】。 2.2 下载STM8标准外设库 本文基于STM8标准外设库（STM8S_StdPeriph_Lib）来新建基础软件工程，所以需要下载标准库。如果你不使用标准外设库（如：使用寄存器）开发，本节内容可以略过。 A.官网下载https://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm8-embedded-software/stsw-stm8069.html 提示：在官网下载需要登录账户，如果嫌麻烦可以在ST中文网，或下面百度网盘下载（和官网一样）。 B.百度网盘http://pan.baidu.com/s/1qYbBKMK 提示：如果以上链接失效， 可以关注微信公众号， 获取更新链接。 2.3 整理工程文件夹 这一小节的内容可根据自己习惯来整理，我整理的文件及文件夹结构是按照常规的整理方式。你如果觉得合理，可以直接引用；如果觉得不习惯这个结构方式，可以自己整理。 本节所讲述的文件夹及里面的内容不是本文新建软件工程的重点，若需要详细了解库文件、文件夹及里面源代码内容，可以参看我的另一教程【STM8S标准外设库教程】。 A.新建工程文件夹首先建立一个存放工程文件的文件夹：STM8S_Demo B.提取ST标准外设库文件解压下载的标准外设库（STM8S_StdPeriph_Lib）可以看见下面四个文件夹和参考资料： _htmresc：图片文件夹（不提取）Libraries：标准驱动库（提取大部分）Project： 示例工程（提取少部分）Utilities：公共代码、评估板代码（不提取）MCD-ST Liberty：软件许可协议（不提取）Release_Notes：发行说明stm8s-a_stdperiph_lib_um：库说明文档 ST官网下载的标准外设库里面有很多例程源代码和其他文件，但我们主要使用Libraries目录下STM8S_StdPeriph_Driver源代码，其他参考文件用于开发学习时参考使用。1.拷贝Libraries文件夹到我们的STM8S_Demo工程文件夹下面。2.拷贝STM8S_StdPeriph_Lib\Project\STM8S_StdPeriph_Template下面stm8s_conf.h、stm8s_it.c和stm8s_it.h三个文件到我们STM8S_Demo \ App下面。 C.新建文件夹和文件除了标准外设库文件之外，我们需要新建存放自己代码的文件和文件夹。我这里主要需要新建4个文件夹：App: 应用程序代码Bsp: 底层驱动代码Doc: 说明文档Project：工程文件 在自己新建的文件夹下面还需要新建自己的文件，文件里面添加必要的源代码文件。我提供的Demo工程，实现的功能比较简单，就是一个LED闪烁。本文重点讲述建立工程的过程，这里不描述源代码，具体可以自己下载查看。 上面几个步骤完成之后，我们就可以看到在工程文件夹“STM8S_Demo”下面整理的文件夹（如下图）： 至此，准备工作算完成了，上面提取的文件、新建的文件里面具体的内容请下载Demo工程查看（文末下载）。 三、新建软件工程 新建一个简单、基础的软件工程大概需要有三个步骤：创建工程、添加文件和配置工程。 上面的准备工作做好之后，就可以在Project文件夹下新建自己的软件工程了，下面将一步一步讲述从零开始新建一个软件工程的详细过程。 3.1 创建工程创建工程：就是新建工作空间及工程，步骤比较简单。 A.打开软件，新建工作空间（File -&gt; New Workspace） B.新建工程（Project -&gt;Create New Project） C.创建一个空工程 D.选择保存路径、名称 E.空基础工程 F.保存工作空间（File -&gt; Save Workspace） 至此，一个空的基础工程就创建好了，需要进一步添加文件到工程和配置工程。 3.2 添加文件 准确的来说，是在上面创建的空工程中添加组（文件夹）和添加源代码文件。简单的说，就是将你自己的源代码文件（前面提取的库、新建的文件等）添加到工程中。 这里的工程项目管理可根据自己的想法来定义（类似于自己分类、命名文件夹和文件），我这里按照常规的方式进行管理项目。 为了方便大家理解，我们单级目录方式分组，先在工程中添加组，再在组中添加源代码文件。 A.工程中添加组 B.填写组的名称 C.组中添加文件 D.按住Ctrl，鼠标选中要添加的文件 E.重复上面4个步骤，直到添加完成 3.3 配置工程 配置工程对于初学者来说，大部分内容只需要默认即可，这里只讲述几个常见的配置，能满足基本的功能。更多配置将在该教程后面的文章中讲述。 A.进入配置选项 B.选择器件 C.库配置Library Configration如果需要使用某些标准的库函数接口（如我们使用的printf 、scanf），就需要选择Full（见下图）。 D.预处理Preprocessor（添加路径）添加的路径最好是相对路径，而不是绝对路径。使用绝对路径工程位置改变之后就找不到文件，就会出错。 1.可以点击按钮选择路径；2.或者通过复制文件路径进行配置。 ···直到完成 E.预处理Preprocessor（预定义）这里的预定义类似于在源代码中的#define xxx 这种宏定义。这里的STM8S103可以在stm8s.h中打开即可。 F.输出Hex文件很多初学的朋友都会问怎么输出 Hex（ 可直接下载的程序文件），只需要按照下面配置即可输出Hex文件。 G.选择下载调试工具根据自己情况选择的下载调试工具。 至此，一个基本工程的配置算完成了。如果源代码正确，就可以编译、下载、调试了。 四、下载1.STM8标准外设库百度网盘下载地址：http://pan.baidu.com/s/1qYbBKMK 2.本文完整代码工程（可运行）下载地址：链接：https://pan.baidu.com/s/1MyAOZcOn04AnRq8zNZrL6w密码：3lkl 提示：如果下载链接失效， 可以关注微信公众号， 获取更新链接。 五、说明1.上面新建基础软件工程主要是针对初学者，写的比较基础的。2.该文档仅供个人学习使用，版权所有，禁止商用。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 六、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EWSTM8系列教程01_EWSTM8介绍、下载、安装和注册]]></title>
    <url>%2FIAR%2FEWSTM8%2FEWSTM8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B01_IAR%E4%BB%8B%E7%BB%8D%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E5%92%8C%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[一、写在前面 我们常说的IAR for STM8，其实指的就是EWSTM8，它的全称是IAR Embedded Workbench for STM8。 本文章收录于【EWSTM8系列教程】，在我的博客分类“EWSTM8系列教程”也能查找到。 为了方便大家平时公交、地铁、外出办事也能用手机随时随地查看该教程，该系列教程也同步更新于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看。 二、IAR介绍2.1 关于IAR IAR是一家公司的名称，也是一种集成开发环境（IDE）的名称，我们平时所说的IAR主要是指的集成开发环境，当然，我们也称它为一种工具：IAR开发工具。 IAR这家公司的发展也是经历了一系列历史变化，从开始针对8051做C编译器，逐渐发展至今，已经是一家庞大的、技术力量雄厚的公司。而IAR集成开发环境也是从单一到现在针对不同处理器，拥有多种IAR版本的集成开发环境。 IAR针对不同内核处理器，有不同的集成开发环境，本文讲述的只是其中的一款集成开发环境EWSTM8，而IAR拥有多个版本，支持的芯片有上万种，详情请参看官网：https://www.iar.com/device-search/#!?tab=devices 2.2 关于EWSTM8 EWSTM8全称是IAR Embedded Workbench for STM8，其实也是我们常说的IAR for STM8，即（用于开发STM8的）嵌入式工作平台。 Embedded Workbench for STM8是IAR Systems公司为 STM8 微处理器开发的一个集成开发环境(简称IAR EWSTM8，也简称为IAR for STM8)。比较其他的 STM8 开发环境，IAR EWSTM8 具有入门容易、使用方便和代码紧凑等特点。 2.3 EWSTM8支持芯片现在（2018年07月）EWSTM8最新版本V3.10，支持市面上所有的STM8系列芯片，目前有一百多种（184种），具体可以到IAR官方网站查看。 https://www.iar.com/device-search/#!?tab=devices 三、下载EWSTM8这个软件安装包推荐大家到官网下载最新版本。当然，如果你嫌麻烦，也可以到我百度网盘下载（含老版本，定期更新）。 3.1 官方下载目前（2018年07月）EWSTM8官方最新版本是V3.10。下载地址：https://www.iar.com/iar-embedded-workbench/#!?currentTab=free-trials 3.2 网盘下载为了方便大家下载，我将其安装包上传到百度云盘。当然，我会定期更新，里面也包含之前老版本，建议大家下载最新那一个版本。 百度网盘地址：http://pan.baidu.com/s/1slF5kYx 提示：如果网盘链接失效，可以关注微信公众号，获取更新链接。 四、安装 EWSTM8集成开发环境的安装比较简单（基本上就是一路Next下去）。本章节主要针对初学者，按照常规安装教程（图文）讲述一下吧，以下载最新的“EWSTM8-3104-Autorun.exe”软件安装包为例来讲述。 4.1 准备过程A.双击EWSTM8安装包，准备安装 B.选择EWSTM8安装 4.2 安装向导、配置C.进入安装向导 D.选择接受许可 E.选择安装路径 安装路径一般默认，你也可以修改到你指定路径下。 F.选择需要安装的驱动 一般也默认都勾选。提示：这里勾选了的驱动，会在后面安装。默认有多个，所以后面会安装多个。 G.选择安装文件夹 默认新建一个文件夹。 4.3 安装EWSTM8H.安装准备就绪 如果准备好之后，点击Install进入安装过程。如果前面配置不对，可以点击Back返回修改。 I.等待安装完成 4.4 安装驱动EWSTM8安装完成之后，接下来就是安装驱动，如果上面勾选多个，那么这里就会弹出多个驱动等待安装（与上面配置有关）。 J.安装驱动提示 K.准备安装过程 L.安装ST-Link···这里会安装多个驱动，大致都差不多，根据提示操作就行。··· M.安装完成 安装完成之后，可能会弹出注册许可向导（License Wizard），此时，选择取消 -&gt; 确定就行。 五、注册EWSTM8是一款收费的商业软件，若你用于商业请购买正版。如果是个人学习，可以使用官方30天的免费试用版本。 本文主要针对个人学习的朋友而言，进行非商业用途的使用。以下所有注册信息来自网络，如有侵权，请联系作者删除。 上面百度网盘提供下载的地址里面有一个“IAR注册机.zip”压缩文件，本章将利用该注册机进行注册。 IAR的注册过程有点绕，先讲一下主要步骤：打开IAR软件 -&gt; 注册界面 -&gt; 到输入许可号 -&gt; 转到注册机（获取许可号） -&gt; 回来粘贴许可号 -&gt; 保存激活信息 -&gt; 到等待激活 - &gt; 转到注册机（利用激活信息）生成激活文件 -&gt; 回来打开激活文件注册 -&gt; 成功。 5.1 打开软件 -&gt; 进入注册许可管理界面A.打开安装好的EWSTM8软件：Help -&gt; License Manager进入许可管理 B.弹出许可向导：1取消 -&gt; 2确定即可 C.进入许可管理 此时，看到有个红色的“×”，说明未注册。 5.2 打开离线激活 -&gt; 得到并粘贴许可号D.离线激活方式： License -&gt; Offline Activation 进入离线激活界面 E.打开注册机获取注册号 (1)选择IAR类型（STM8）； (2)获取许可号； (3)复制许可号 F.粘贴许可号 5.3 保存激活信息 -&gt; 到等待激活G.生成并保存激活信息ActivationInfo.txt H.进入等待激活界面 5.4 生成激活文件 -&gt; 激活I.生成激活文件 转到注册机：(1)打开前面（路径下）生成的激活信息文件(2)点击激活 -&gt; 保存激活文件（ActivationResponse.txt）到相同路径下。 J.激活 -&gt; 完成 K.弹出提示 L.查看状态 至此，注册已经完成了。 六、说明1.该文档仅供个人学习使用，版权所有，禁止商用。2.本文主要针对个人学习使用的朋友，若你是商业用途，建议购买正版软件。3.本教程收录于微信公众号【EmbeddedDevelop】，关注微信公众号回复【EWSTM8系列教程】即可查看全系列教程。 七、最后我的博客：http://www.strongerhuang.com我的GitHub：https://github.com/EmbeddedDevelop 更多精彩文章我将第一时间在微信公众号里面分享， 如果不想错过,可以关注我的微信公众号。]]></content>
      <categories>
        <category>EWSTM8系列教程</category>
      </categories>
      <tags>
        <tag>IAR</tag>
        <tag>STM8</tag>
        <tag>EWSTM8</tag>
        <tag>IAR for STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F%E8%AF%B4%E6%98%8E%E6%96%87%E7%AB%A0%2F%E5%85%AC%E5%91%8A.html</url>
    <content type="text"><![CDATA[一、博客搬家了 欢迎您来到我个人的新博客网站：http://www.strongerhuang.com 在这里，我会以专栏形式分享。当然，更多精彩内容我会在我的个人公众号「strongerHuang」分享。 1.1 原CSDN博客 由于我原来的【CSDN博客】文章比较杂乱，也没有整理归类，不方便查找，文章中提供的代码工程下载地址都失效了。还有个主要原因，在别人地盘写文章总觉得不爽。所以，决定自己搭建博客，在自己的地盘写出属于自己的博客文章。 我的CSDN博客目前没有更新文章了，最后一次更新文章应该是停留在去年八九月份的样子，所以那个时候都有计划搭建属于自己的博客了。后续可能很少在CSDN上面更新文章了（兴许哪一天高兴了，会整理一下CSDN博客）。 原CSDN博客主页：https://blog.csdn.net/ybhuangfugui 1.2 我的新博客 其实，我去年就打算自己搭建博客，但是由于工作原因，没有足够的时间（自己搭建博客也是挺折腾的），一直耽搁了。直到今年，终于狠下心，搭建成功了属于自己的个人博客网站。 个人新博客主页：http://www.strongerhuang.com 二、后续计划 我的博客文章正在努力更新中。。。关注我微信公众号：strongerhuang，随时获取最新资讯。]]></content>
      <categories>
        <category>说明文章</category>
      </categories>
      <tags>
        <tag>说明</tag>
        <tag>公告</tag>
      </tags>
  </entry>
</search>
